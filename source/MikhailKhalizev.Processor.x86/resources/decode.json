{
  "Instructions": [
    {
      "Mnemonic": "AAA",
      "Description": "ASCII Adjust After Addition",
      "Url": "https://www.felixcloutier.com/x86/AAA.html",
      "Table": [
        {
          "Opcode": "37",
          "Instruction": "AAA",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "ASCII adjust AL after addition."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "AAD",
      "Description": "ASCII Adjust AX Before Division",
      "Url": "https://www.felixcloutier.com/x86/AAD.html",
      "Table": [
        {
          "Opcode": "D5 0A",
          "Instruction": "AAD",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "ASCII adjust AX before division."
        },
        {
          "Opcode": "D5 ib",
          "Instruction": "AAD imm8",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Adjust AX before division to number base imm8."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "AAM",
      "Description": "ASCII Adjust AX After Multiply",
      "Url": "https://www.felixcloutier.com/x86/AAM.html",
      "Table": [
        {
          "Opcode": "D4 0A",
          "Instruction": "AAM",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "ASCII adjust AX after multiply."
        },
        {
          "Opcode": "D4 ib",
          "Instruction": "AAM imm8",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Adjust AX after multiply to number base imm8."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "AAS",
      "Description": "ASCII Adjust AL After Subtraction",
      "Url": "https://www.felixcloutier.com/x86/AAS.html",
      "Table": [
        {
          "Opcode": "3F",
          "Instruction": "AAS",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "ASCII adjust AL after subtraction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "ADC",
      "Description": "Add with Carry",
      "Url": "https://www.felixcloutier.com/x86/ADC.html",
      "Table": [
        {
          "Opcode": "14 ib",
          "Instruction": "ADC AL, imm8",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry imm8 to AL."
        },
        {
          "Opcode": "15 iw",
          "Instruction": "ADC AX, imm16",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry imm16 to AX."
        },
        {
          "Opcode": "15 id",
          "Instruction": "ADC EAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry imm32 to EAX."
        },
        {
          "Opcode": "REX.W + 15 id",
          "Instruction": "ADC RAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with carry imm32 sign extended to 64-bits to RAX."
        },
        {
          "Opcode": "80 /2 ib",
          "Instruction": "ADC r/m8, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry imm8 to r/m8."
        },
        {
          "Opcode": "REX + 80 /2 ib",
          "Instruction": "ADC r/m8*, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with carry imm8 to r/m8."
        },
        {
          "Opcode": "81 /2 iw",
          "Instruction": "ADC r/m16, imm16",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry imm16 to r/m16."
        },
        {
          "Opcode": "81 /2 id",
          "Instruction": "ADC r/m32, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with CF imm32 to r/m32."
        },
        {
          "Opcode": "REX.W + 81 /2 id",
          "Instruction": "ADC r/m64, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with CF imm32 sign extended to 64-bits to r/m64."
        },
        {
          "Opcode": "83 /2 ib",
          "Instruction": "ADC r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with CF sign-extended imm8 to r/m16."
        },
        {
          "Opcode": "83 /2 ib",
          "Instruction": "ADC r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with CF sign-extended imm8 into r/m32."
        },
        {
          "Opcode": "REX.W + 83 /2 ib",
          "Instruction": "ADC r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with CF sign-extended imm8 into r/m64."
        },
        {
          "Opcode": "10 /r",
          "Instruction": "ADC r/m8, r8",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry byte register to r/m8."
        },
        {
          "Opcode": "REX + 10 /r",
          "Instruction": "ADC r/m8*, r8*",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with carry byte register to r/m64."
        },
        {
          "Opcode": "11 /r",
          "Instruction": "ADC r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry r16 to r/m16."
        },
        {
          "Opcode": "11 /r",
          "Instruction": "ADC r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with CF r32 to r/m32."
        },
        {
          "Opcode": "REX.W + 11 /r",
          "Instruction": "ADC r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with CF r64 to r/m64."
        },
        {
          "Opcode": "12 /r",
          "Instruction": "ADC r8, r/m8",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry r/m8 to byte register."
        },
        {
          "Opcode": "REX + 12 /r",
          "Instruction": "ADC r8*, r/m8*",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with carry r/m64 to byte register."
        },
        {
          "Opcode": "13 /r",
          "Instruction": "ADC r16, r/m16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with carry r/m16 to r16."
        },
        {
          "Opcode": "13 /r",
          "Instruction": "ADC r32, r/m32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add with CF r/m32 to r32."
        },
        {
          "Opcode": "REX.W + 13 /r",
          "Instruction": "ADC r64, r/m64",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add with CF r/m64 to r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ADCX",
      "Description": "Unsigned Integer Addition of Two Operands with Carry Flag",
      "Url": "https://www.felixcloutier.com/x86/ADCX.html",
      "Table": [
        {
          "Opcode": "66 0F 38 F6 /r",
          "Instruction": "ADCX r32, r/m32",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "ADX",
          "Description": "Unsigned addition of r32 with CF, r/m32 to r32, writes CF."
        },
        {
          "Opcode": "66 REX.w 0F 38 F6 /r",
          "Instruction": "ADCX r64, r/m64",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "ADX",
          "Description": "Unsigned addition of r64 with CF, r/m64 to r64, writes CF."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ADD",
      "Description": "Add",
      "Url": "https://www.felixcloutier.com/x86/ADD.html",
      "Table": [
        {
          "Opcode": "04 ib",
          "Instruction": "ADD AL, imm8",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm8 to AL."
        },
        {
          "Opcode": "05 iw",
          "Instruction": "ADD AX, imm16",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm16 to AX."
        },
        {
          "Opcode": "05 id",
          "Instruction": "ADD EAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm32 to EAX."
        },
        {
          "Opcode": "REX.W + 05 id",
          "Instruction": "ADD RAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add imm32 sign-extended to 64-bits to RAX."
        },
        {
          "Opcode": "80 /0 ib",
          "Instruction": "ADD r/m8, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm8 to r/m8."
        },
        {
          "Opcode": "REX + 80 /0 ib",
          "Instruction": "ADD r/m8*, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add sign-extended imm8 to r/m8."
        },
        {
          "Opcode": "81 /0 iw",
          "Instruction": "ADD r/m16, imm16",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm16 to r/m16."
        },
        {
          "Opcode": "81 /0 id",
          "Instruction": "ADD r/m32, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add imm32 to r/m32."
        },
        {
          "Opcode": "REX.W + 81 /0 id",
          "Instruction": "ADD r/m64, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add imm32 sign-extended to 64-bits to r/m64."
        },
        {
          "Opcode": "83 /0 ib",
          "Instruction": "ADD r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add sign-extended imm8 to r/m16."
        },
        {
          "Opcode": "83 /0 ib",
          "Instruction": "ADD r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add sign-extended imm8 to r/m32."
        },
        {
          "Opcode": "REX.W + 83 /0 ib",
          "Instruction": "ADD r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add sign-extended imm8 to r/m64."
        },
        {
          "Opcode": "00 /r",
          "Instruction": "ADD r/m8, r8",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r8 to r/m8."
        },
        {
          "Opcode": "REX + 00 /r",
          "Instruction": "ADD r/m8*, r8*",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add r8 to r/m8."
        },
        {
          "Opcode": "01 /r",
          "Instruction": "ADD r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r16 to r/m16."
        },
        {
          "Opcode": "01 /r",
          "Instruction": "ADD r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r32 to r/m32."
        },
        {
          "Opcode": "REX.W + 01 /r",
          "Instruction": "ADD r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add r64 to r/m64."
        },
        {
          "Opcode": "02 /r",
          "Instruction": "ADD r8, r/m8",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r/m8 to r8."
        },
        {
          "Opcode": "REX + 02 /r",
          "Instruction": "ADD r8*, r/m8*",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add r/m8 to r8."
        },
        {
          "Opcode": "03 /r",
          "Instruction": "ADD r16, r/m16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r/m16 to r16."
        },
        {
          "Opcode": "03 /r",
          "Instruction": "ADD r32, r/m32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Add r/m32 to r32."
        },
        {
          "Opcode": "REX.W + 03 /r",
          "Instruction": "ADD r64, r/m64",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Add r/m64 to r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ADDPD",
      "Description": "Add Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ADDPD.html",
      "Table": [
        {
          "Opcode": "66 0F 58 /r",
          "Instruction": "ADDPD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed double-precision floating-point values from xmm2/mem to xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 58 /r",
          "Instruction": "VADDPD xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed double-precision floating-point values from xmm3/mem to xmm2 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 58 /r",
          "Instruction": "VADDPD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed double-precision floating-point values from ymm3/mem to ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 58 /r",
          "Instruction": "VADDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 58 /r",
          "Instruction": "VADDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 58 /r",
          "Instruction": "VADDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ADDPS",
      "Description": "Add Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ADDPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 58 /r",
          "Instruction": "ADDPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Add packed single-precision floating-point values from xmm2/m128 to xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 58 /r",
          "Instruction": "VADDPS xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed single-precision floating-point values from xmm3/m128 to xmm2 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 58 /r",
          "Instruction": "VADDPS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed single-precision floating-point values from ymm3/m256 to ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 58 /r",
          "Instruction": "VADDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 58 /r",
          "Instruction": "VADDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 58 /r",
          "Instruction": "VADDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add packed single-precision floating-point values from zmm3/m512/m32bcst to zmm2 and store result in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ADDSD",
      "Description": "Add Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ADDSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 58 /r",
          "Instruction": "ADDSD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add the low double-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 58 /r",
          "Instruction": "VADDSD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add the low double-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 58 /r",
          "Instruction": "VADDSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add the low double-precision floating-point value from xmm3/m64 to xmm2 and store the result in xmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ADDSS",
      "Description": "Add Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ADDSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 58 /r",
          "Instruction": "ADDSS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Add the low single-precision floating-point value from xmm2/mem to xmm1 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 58 /r",
          "Instruction": "VADDSS xmm1,xmm2, xmm3/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add the low single-precision floating-point value from xmm3/mem to xmm2 and store the result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 58 /r",
          "Instruction": "VADDSS xmm1{k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add the low single-precision floating-point value from xmm3/m32 to xmm2 and store the result in xmm1with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ADDSUBPD",
      "Description": "Packed Double-FP Add/Subtract",
      "Url": "https://www.felixcloutier.com/x86/ADDSUBPD.html",
      "Table": [
        {
          "Opcode": "66 0F D0 /r",
          "Instruction": "ADDSUBPD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Add/subtract double-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D0 /r",
          "Instruction": "VADDSUBPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add/subtract packed double-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D0 /r",
          "Instruction": "VADDSUBPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add / subtract packed double-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ADDSUBPS",
      "Description": "Packed Single-FP Add/Subtract",
      "Url": "https://www.felixcloutier.com/x86/ADDSUBPS.html",
      "Table": [
        {
          "Opcode": "F2 0F D0 /r",
          "Instruction": "ADDSUBPS xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Add/subtract single-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.F2.0F.WIG D0 /r",
          "Instruction": "VADDSUBPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add/subtract single-precision floating-point values from xmm3/mem to xmm2 and stores result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.F2.0F.WIG D0 /r",
          "Instruction": "VADDSUBPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add / subtract single-precision floating-point values from ymm3/mem to ymm2 and stores result in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ADOX",
      "Description": "Unsigned Integer Addition of Two Operands with Overflow Flag",
      "Url": "https://www.felixcloutier.com/x86/ADOX.html",
      "Table": [
        {
          "Opcode": "F3 0F 38 F6 /r",
          "Instruction": "ADOX r32, r/m32",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "ADX",
          "Description": "Unsigned addition of r32 with OF, r/m32 to r32, writes OF."
        },
        {
          "Opcode": "F3 REX.w 0F 38 F6 /r",
          "Instruction": "ADOX r64, r/m64",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "ADX",
          "Description": "Unsigned addition of r64 with OF, r/m64 to r64, writes OF."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESDEC",
      "Description": "Perform One Round of an AES Decryption Flow",
      "Url": "https://www.felixcloutier.com/x86/AESDEC.html",
      "Table": [
        {
          "Opcode": "66 0F 38 DE /r",
          "Instruction": "AESDEC xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AES",
          "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG DE /r",
          "Instruction": "VAESDEC xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Perform one round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESDECLAST",
      "Description": "Perform Last Round of an AES Decryption Flow",
      "Url": "https://www.felixcloutier.com/x86/AESDECLAST.html",
      "Table": [
        {
          "Opcode": "66 0F 38 DF /r",
          "Instruction": "AESDECLAST xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AES",
          "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG DF /r",
          "Instruction": "VAESDECLAST xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Perform the last round of an AES decryption flow, using the Equivalent Inverse Cipher, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from xmm3/m128; store the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESENC",
      "Description": "Perform One Round of an AES Encryption Flow",
      "Url": "https://www.felixcloutier.com/x86/AESENC.html",
      "Table": [
        {
          "Opcode": "66 0F 38 DC /r",
          "Instruction": "AESENC xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AES",
          "Description": "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG DC /r",
          "Instruction": "VAESENC xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Perform one round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128-bit round key from the xmm3/m128; store the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESENCLAST",
      "Description": "Perform Last Round of an AES Encryption Flow",
      "Url": "https://www.felixcloutier.com/x86/AESENCLAST.html",
      "Table": [
        {
          "Opcode": "66 0F 38 DD /r",
          "Instruction": "AESENCLAST xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AES",
          "Description": "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm1 with a 128-bit round key from xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG DD /r",
          "Instruction": "VAESENCLAST xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Perform the last round of an AES encryption flow, operating on a 128-bit data (state) from xmm2 with a 128 bit round key from xmm3/m128; store the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESIMC",
      "Description": "Perform the AES InvMixColumn Transformation",
      "Url": "https://www.felixcloutier.com/x86/AESIMC.html",
      "Table": [
        {
          "Opcode": "66 0F 38 DB /r",
          "Instruction": "AESIMC xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AES",
          "Description": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG DB /r",
          "Instruction": "VAESIMC xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Perform the InvMixColumn transformation on a 128-bit round key from xmm2/m128 and store the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AESKEYGENASSIST",
      "Description": "AES Round Key Generation Assist",
      "Url": "https://www.felixcloutier.com/x86/AESKEYGENASSIST.html",
      "Table": [
        {
          "Opcode": "66 0F 3A DF /r ib",
          "Instruction": "AESKEYGENASSIST xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "AES",
          "Description": "Assist in AES round key generation using an 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F3A.WIG DF /r ib",
          "Instruction": "VAESKEYGENASSIST xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "Both AES and AVX flags",
          "Description": "Assist in AES round key generation using 8 bits Round Constant (RCON) specified in the immediate byte, operating on 128 bits of data specified in xmm2/m128 and stores the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "AND",
      "Description": "Logical AND",
      "Url": "https://www.felixcloutier.com/x86/AND.html",
      "Table": [
        {
          "Opcode": "24 ib",
          "Instruction": "AND AL, imm8",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "AL AND imm8."
        },
        {
          "Opcode": "25 iw",
          "Instruction": "AND AX, imm16",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "AX AND imm16."
        },
        {
          "Opcode": "25 id",
          "Instruction": "AND EAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "EAX AND imm32."
        },
        {
          "Opcode": "REX.W + 25 id",
          "Instruction": "AND RAX, imm32",
          "OperandEncoding": "I",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "RAX AND imm32 sign-extended to 64-bits."
        },
        {
          "Opcode": "80 /4 ib",
          "Instruction": "AND r/m8, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m8 AND imm8."
        },
        {
          "Opcode": "REX + 80 /4 ib",
          "Instruction": "AND r/m8*, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m8 AND imm8."
        },
        {
          "Opcode": "81 /4 iw",
          "Instruction": "AND r/m16, imm16",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m16 AND imm16."
        },
        {
          "Opcode": "81 /4 id",
          "Instruction": "AND r/m32, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m32 AND imm32."
        },
        {
          "Opcode": "REX.W + 81 /4 id",
          "Instruction": "AND r/m64, imm32",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 AND imm32 sign extended to 64-bits."
        },
        {
          "Opcode": "83 /4 ib",
          "Instruction": "AND r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m16 AND imm8 (sign-extended)."
        },
        {
          "Opcode": "83 /4 ib",
          "Instruction": "AND r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m32 AND imm8 (sign-extended)."
        },
        {
          "Opcode": "REX.W + 83 /4 ib",
          "Instruction": "AND r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 AND imm8 (sign-extended)."
        },
        {
          "Opcode": "20 /r",
          "Instruction": "AND r/m8, r8",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m8 AND r8."
        },
        {
          "Opcode": "REX + 20 /r",
          "Instruction": "AND r/m8*, r8*",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 AND r8 (sign-extended)."
        },
        {
          "Opcode": "21 /r",
          "Instruction": "AND r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m16 AND r16."
        },
        {
          "Opcode": "21 /r",
          "Instruction": "AND r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r/m32 AND r32."
        },
        {
          "Opcode": "REX.W + 21 /r",
          "Instruction": "AND r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 AND r32."
        },
        {
          "Opcode": "22 /r",
          "Instruction": "AND r8, r/m8",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r8 AND r/m8."
        },
        {
          "Opcode": "REX + 22 /r",
          "Instruction": "AND r8*, r/m8*",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 AND r8 (sign-extended)."
        },
        {
          "Opcode": "23 /r",
          "Instruction": "AND r16, r/m16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r16 AND r/m16."
        },
        {
          "Opcode": "23 /r",
          "Instruction": "AND r32, r/m32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "r32 AND r/m32."
        },
        {
          "Opcode": "REX.W + 23 /r",
          "Instruction": "AND r64, r/m64",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "r64 AND r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ANDN",
      "Description": "Logical AND NOT",
      "Url": "https://www.felixcloutier.com/x86/ANDN.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.0F38.W0 F2 /r",
          "Instruction": "ANDN r32a, r32b, r/m32",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Bitwise AND of inverted r32b with r/m32, store result in r32a."
        },
        {
          "Opcode": "VEX.NDS.LZ. 0F38.W1 F2 /r",
          "Instruction": "ANDN r64a, r64b, r/m64",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Bitwise AND of inverted r64b with r/m64, store result in r64a."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ANDNPD",
      "Description": "Bitwise Logical AND NOT of Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ANDNPD.html",
      "Table": [
        {
          "Opcode": "66 0F 55 /r",
          "Instruction": "ANDNPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F 55 /r",
          "Instruction": "VANDNPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F 55/r",
          "Instruction": "VANDNPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 55 /r",
          "Instruction": "VANDNPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 55 /r",
          "Instruction": "VANDNPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 55 /r",
          "Instruction": "VANDNPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical AND NOT of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ANDNPS",
      "Description": "Bitwise Logical AND NOT of Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ANDNPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 55 /r",
          "Instruction": "ANDNPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F 55 /r",
          "Instruction": "VANDNPS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND NOT of packed single-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F 55 /r",
          "Instruction": "VANDNPS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND NOT of packed single-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 55 /r",
          "Instruction": "VANDNPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 55 /r",
          "Instruction": "VANDNPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 55 /r",
          "Instruction": "VANDNPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ANDPD",
      "Description": "Bitwise Logical AND of Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ANDPD.html",
      "Table": [
        {
          "Opcode": "66 0F 54 /r",
          "Instruction": "ANDPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F 54 /r",
          "Instruction": "VANDPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F 54 /r",
          "Instruction": "VANDPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 54 /r",
          "Instruction": "VANDPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 54 /r",
          "Instruction": "VANDPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 54 /r",
          "Instruction": "VANDPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical AND of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ANDPS",
      "Description": "Bitwise Logical AND of Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ANDPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 54 /r",
          "Instruction": "ANDPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F 54 /r",
          "Instruction": "VANDPS xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F 54 /r",
          "Instruction": "VANDPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 54 /r",
          "Instruction": "VANDPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 54 /r",
          "Instruction": "VANDPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 54 /r",
          "Instruction": "VANDPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical AND of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ARPL",
      "Description": "Adjust RPL Field of Segment Selector",
      "Url": "https://www.felixcloutier.com/x86/ARPL.html",
      "Table": [
        {
          "Opcode": "63 /r",
          "Instruction": "ARPL r/m16, r16",
          "OperandEncoding": "ZO",
          "Bit64Mode": "N. E.",
          "CompatLegMode": "Valid",
          "Description": "Adjust RPL of r/m16 to not less than RPL of r16."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BEXTR",
      "Description": "Bit Field Extract",
      "Url": "https://www.felixcloutier.com/x86/BEXTR.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.0F38.W0 F7 /r",
          "Instruction": "BEXTR r32a, r/m32, r32b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Contiguous bitwise extract from r/m32 using r32b as control; store result in r32a."
        },
        {
          "Opcode": "VEX.NDS.LZ.0F38.W1 F7 /r",
          "Instruction": "BEXTR r64a, r/m64, r64b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Contiguous bitwise extract from r/m64 using r64b as control; store result in r64a"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "VEX.vvvv (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLENDPD",
      "Description": "Blend Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/BLENDPD.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 0D /r ib",
          "Instruction": "BLENDPD xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select packed DP-FP values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 0D /r ib",
          "Instruction": "VBLENDPD xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select packed double-precision floating-point Values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 0D /r ib",
          "Instruction": "VBLENDPD ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select packed double-precision floating-point Values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8[3:0]"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLENDPS",
      "Description": "Blend Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/BLENDPS.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 0C /r ib",
          "Instruction": "BLENDPS xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 0C /r ib",
          "Instruction": "VBLENDPS xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select packed single-precision floating-point values from xmm2 and xmm3/m128 from mask in imm8 and store the values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 0C /r ib",
          "Instruction": "VBLENDPS ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select packed single-precision floating-point values from ymm2 and ymm3/m256 from mask in imm8 and store the values in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLENDVPD",
      "Description": "Variable Blend Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/BLENDVPD.html",
      "Table": [
        {
          "Opcode": "66 0F 38 15 /r",
          "Instruction": "BLENDVPD xmm1, xmm2/m128 , &lt;XMM0&gt;",
          "OperandEncoding": "RM0",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select packed DP FP values from xmm1 and xmm2 from mask specified in XMM0 and store the values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 4B /r /is4",
          "Instruction": "VBLENDVPD xmm1, xmm2, xmm3/m128, xmm4",
          "OperandEncoding": "RVMR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally copy double-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the mask operand, xmm4."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 4B /r /is4",
          "Instruction": "VBLENDVPD ymm1, ymm2, ymm3/m256, ymm4",
          "OperandEncoding": "RVMR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally copy double-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the mask operand, ymm4."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM0",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "implicit XMM0"
          ]
        },
        {
          "OperandEncoding": "RVMR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8[7:4]"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLENDVPS",
      "Description": "Variable Blend Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/BLENDVPS.html",
      "Table": [
        {
          "Opcode": "66 0F 38 14 /r",
          "Instruction": "BLENDVPS xmm1, xmm2/m128, &lt;XMM0&gt;",
          "OperandEncoding": "RM0",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select packed single precision floating-point values from xmm1 and xmm2/m128 from mask specified in XMM0 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 4A /r /is4",
          "Instruction": "VBLENDVPS xmm1, xmm2, xmm3/m128, xmm4",
          "OperandEncoding": "RVMR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally copy single-precision floating-point values from xmm2 or xmm3/m128 to xmm1, based on mask bits in the specified mask operand, xmm4."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 4A /r /is4",
          "Instruction": "VBLENDVPS ymm1, ymm2, ymm3/m256, ymm4",
          "OperandEncoding": "RVMR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally copy single-precision floating-point values from ymm2 or ymm3/m256 to ymm1, based on mask bits in the specified mask register, ymm4."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM0",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "implicit XMM0"
          ]
        },
        {
          "OperandEncoding": "RVMR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8[7:4]"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLSI",
      "Description": "Extract Lowest Set Isolated Bit",
      "Url": "https://www.felixcloutier.com/x86/BLSI.html",
      "Table": [
        {
          "Opcode": "VEX.NDD.LZ.0F38.W0 F3 /3",
          "Instruction": "BLSI r32, r/m32",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Extract lowest set bit from r/m32 and set that bit in r32."
        },
        {
          "Opcode": "VEX.NDD.LZ.0F38.W1 F3 /3",
          "Instruction": "BLSI r64, r/m64",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Extract lowest set bit from r/m64, and set that bit in r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "VM",
          "Operands": [
            "VEX.vvvv (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLSMSK",
      "Description": "Get Mask Up to Lowest Set Bit",
      "Url": "https://www.felixcloutier.com/x86/BLSMSK.html",
      "Table": [
        {
          "Opcode": "VEX.NDD.LZ.0F38.W0 F3 /2",
          "Instruction": "BLSMSK r32, r/m32",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Set all lower bits in r32 to “1” starting from bit 0 to lowest set bit in r/m32."
        },
        {
          "Opcode": "VEX.NDD.LZ.0F38.W1 F3 /2",
          "Instruction": "BLSMSK r64, r/m64",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Set all lower bits in r64 to “1” starting from bit 0 to lowest set bit in r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "VM",
          "Operands": [
            "VEX.vvvv (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BLSR",
      "Description": "Reset Lowest Set Bit",
      "Url": "https://www.felixcloutier.com/x86/BLSR.html",
      "Table": [
        {
          "Opcode": "VEX.NDD.LZ.0F38.W0 F3 /1",
          "Instruction": "BLSR r32, r/m32",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Reset lowest set bit of r/m32, keep all other bits of r/m32 and write result to r32."
        },
        {
          "Opcode": "VEX.NDD.LZ.0F38.W1 F3 /1",
          "Instruction": "BLSR r64, r/m64",
          "OperandEncoding": "VM",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Reset lowest set bit of r/m64, keep all other bits of r/m64 and write result to r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "VM",
          "Operands": [
            "VEX.vvvv (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDCL",
      "Description": "Check Lower Bound",
      "Url": "https://www.felixcloutier.com/x86/BNDCL.html",
      "Table": [
        {
          "Opcode": "F3 0F 1A /r",
          "Instruction": "BNDCL bnd, r/m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m32 is lower than the lower bound in bnd.LB."
        },
        {
          "Opcode": "F3 0F 1A /r",
          "Instruction": "BNDCL bnd, r/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m64 is lower than the lower bound in bnd.LB."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDCN",
      "Description": "Check Upper Bound",
      "Url": "https://www.felixcloutier.com/x86/BNDCU:BNDCN.html",
      "Table": [
        {
          "Opcode": "F2 0F 1B /r",
          "Instruction": "BNDCN bnd, r/m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
        },
        {
          "Opcode": "F2 0F 1B /r",
          "Instruction": "BNDCN bnd, r/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB not in 1's complement form)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDCU",
      "Description": "Check Upper Bound",
      "Url": "https://www.felixcloutier.com/x86/BNDCU:BNDCN.html",
      "Table": [
        {
          "Opcode": "F2 0F 1A /r",
          "Instruction": "BNDCU bnd, r/m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m32 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
        },
        {
          "Opcode": "F2 0F 1A /r",
          "Instruction": "BNDCU bnd, r/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Generate a #BR if the address in r/m64 is higher than the upper bound in bnd.UB (bnb.UB in 1's complement form)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDLDX",
      "Description": "Load Extended Bounds Using Address Translation",
      "Url": "https://www.felixcloutier.com/x86/BNDLDX.html",
      "Table": [
        {
          "Opcode": "NP 0F 1A /r",
          "Instruction": "BNDLDX bnd, mib",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Load the bounds stored in a bound table entry (BTE) into bnd with address translation using the base of mib and conditional on the index of mib matching the pointer value in the BTE."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "SIB.base (r): Address of pointer SIB.index(r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDMK",
      "Description": "Make Bounds",
      "Url": "https://www.felixcloutier.com/x86/BNDMK.html",
      "Table": [
        {
          "Opcode": "F3 0F 1B /r",
          "Instruction": "BNDMK bnd, m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Make lower and upper bounds from m32 and store them in bnd."
        },
        {
          "Opcode": "F3 0F 1B /r",
          "Instruction": "BNDMK bnd, m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Make lower and upper bounds from m64 and store them in bnd."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDMOV",
      "Description": "Move Bounds",
      "Url": "https://www.felixcloutier.com/x86/BNDMOV.html",
      "Table": [
        {
          "Opcode": "66 0F 1A /r",
          "Instruction": "BNDMOV bnd1, bnd2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Move lower and upper bound from bnd2/m64 to bound register bnd1."
        },
        {
          "Opcode": "66 0F 1A /r",
          "Instruction": "BNDMOV bnd1, bnd2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Move lower and upper bound from bnd2/m128 to bound register bnd1."
        },
        {
          "Opcode": "66 0F 1B /r",
          "Instruction": "BNDMOV bnd1/m64, bnd2",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "NE/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Move lower and upper bound from bnd2 to bnd1/m64."
        },
        {
          "Opcode": "66 0F 1B /r",
          "Instruction": "BNDMOV bnd1/m128, bnd2",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/NE",
          "CpuidFeatureFlag": "MPX",
          "Description": "Move lower and upper bound from bnd2 to bound register bnd1/m128."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BNDSTX",
      "Description": "Store Extended Bounds Using Address Translation",
      "Url": "https://www.felixcloutier.com/x86/BNDSTX.html",
      "Table": [
        {
          "Opcode": "NP 0F 1B /r",
          "Instruction": "BNDSTX mib, bnd",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MPX",
          "Description": "Store the bounds in bnd and the pointer value in the index register of mib to a bound table entry (BTE) with address translation using the base of mib."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "SIB.base (r): Address of pointer SIB.index(r)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BOUND",
      "Description": "Check Array Index Against Bounds",
      "Url": "https://www.felixcloutier.com/x86/BOUND.html",
      "Table": [
        {
          "Opcode": "62 /r",
          "Instruction": "BOUND r16, m16&amp;16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Check if r16 (array index) is within bounds specified by m16&amp;16."
        },
        {
          "Opcode": "62 /r",
          "Instruction": "BOUND r32, m32&amp;32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Check if r32 (array index) is within bounds specified by m32&amp;32."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BSF",
      "Description": "Bit Scan Forward",
      "Url": "https://www.felixcloutier.com/x86/BSF.html",
      "Table": [
        {
          "Opcode": "0F BC /r",
          "Instruction": "BSF r16, r/m16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Bit scan forward on r/m16."
        },
        {
          "Opcode": "0F BC /r",
          "Instruction": "BSF r32, r/m32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Bit scan forward on r/m32."
        },
        {
          "Opcode": "REX.W + 0F BC /r",
          "Instruction": "BSF r64, r/m64",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Bit scan forward on r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BSR",
      "Description": "Bit Scan Reverse",
      "Url": "https://www.felixcloutier.com/x86/BSR.html",
      "Table": [
        {
          "Opcode": "0F BD /r",
          "Instruction": "BSR r16, r/m16",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Bit scan reverse on r/m16."
        },
        {
          "Opcode": "0F BD /r",
          "Instruction": "BSR r32, r/m32",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Bit scan reverse on r/m32."
        },
        {
          "Opcode": "REX.W + 0F BD /r",
          "Instruction": "BSR r64, r/m64",
          "OperandEncoding": "RM",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Bit scan reverse on r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BSWAP",
      "Description": "Byte Swap",
      "Url": "https://www.felixcloutier.com/x86/BSWAP.html",
      "Table": [
        {
          "Opcode": "0F C8+rd",
          "Instruction": "BSWAP r32",
          "OperandEncoding": "O",
          "Bit64Mode": "Valid*",
          "CompatLegMode": "Valid",
          "Description": "Reverses the byte order of a 32-bit register."
        },
        {
          "Opcode": "REX.W + 0F C8+rd",
          "Instruction": "BSWAP r64",
          "OperandEncoding": "O",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Reverses the byte order of a 64-bit register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BT",
      "Description": "Bit Test",
      "Url": "https://www.felixcloutier.com/x86/BT.html",
      "Table": [
        {
          "Opcode": "0F A3 /r",
          "Instruction": "BT r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag."
        },
        {
          "Opcode": "0F A3 /r",
          "Instruction": "BT r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag."
        },
        {
          "Opcode": "REX.W + 0F A3 /r",
          "Instruction": "BT r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag."
        },
        {
          "Opcode": "0F BA /4 ib",
          "Instruction": "BT r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag."
        },
        {
          "Opcode": "0F BA /4 ib",
          "Instruction": "BT r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag."
        },
        {
          "Opcode": "REX.W + 0F BA /4 ib",
          "Instruction": "BT r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BTC",
      "Description": "Bit Test and Complement",
      "Url": "https://www.felixcloutier.com/x86/BTC.html",
      "Table": [
        {
          "Opcode": "0F BB /r",
          "Instruction": "BTC r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and complement."
        },
        {
          "Opcode": "0F BB /r",
          "Instruction": "BTC r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and complement."
        },
        {
          "Opcode": "REX.W + 0F BB /r",
          "Instruction": "BTC r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and complement."
        },
        {
          "Opcode": "0F BA /7 ib",
          "Instruction": "BTC r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and complement."
        },
        {
          "Opcode": "0F BA /7 ib",
          "Instruction": "BTC r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and complement."
        },
        {
          "Opcode": "REX.W + 0F BA /7 ib",
          "Instruction": "BTC r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and complement."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BTR",
      "Description": "Bit Test and Reset",
      "Url": "https://www.felixcloutier.com/x86/BTR.html",
      "Table": [
        {
          "Opcode": "0F B3 /r",
          "Instruction": "BTR r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and clear."
        },
        {
          "Opcode": "0F B3 /r",
          "Instruction": "BTR r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and clear."
        },
        {
          "Opcode": "REX.W + 0F B3 /r",
          "Instruction": "BTR r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and clear."
        },
        {
          "Opcode": "0F BA /6 ib",
          "Instruction": "BTR r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and clear."
        },
        {
          "Opcode": "0F BA /6 ib",
          "Instruction": "BTR r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and clear."
        },
        {
          "Opcode": "REX.W + 0F BA /6 ib",
          "Instruction": "BTR r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and clear."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BTS",
      "Description": "Bit Test and Set",
      "Url": "https://www.felixcloutier.com/x86/BTS.html",
      "Table": [
        {
          "Opcode": "0F AB /r",
          "Instruction": "BTS r/m16, r16",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and set."
        },
        {
          "Opcode": "0F AB /r",
          "Instruction": "BTS r/m32, r32",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and set."
        },
        {
          "Opcode": "REX.W + 0F AB /r",
          "Instruction": "BTS r/m64, r64",
          "OperandEncoding": "MR",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and set."
        },
        {
          "Opcode": "0F BA /5 ib",
          "Instruction": "BTS r/m16, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and set."
        },
        {
          "Opcode": "0F BA /5 ib",
          "Instruction": "BTS r/m32, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Store selected bit in CF flag and set."
        },
        {
          "Opcode": "REX.W + 0F BA /5 ib",
          "Instruction": "BTS r/m64, imm8",
          "OperandEncoding": "MI",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Store selected bit in CF flag and set."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "BZHI",
      "Description": "Zero High Bits Starting with Specified Bit Position",
      "Url": "https://www.felixcloutier.com/x86/BZHI.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.0F38.W0 F5 /r",
          "Instruction": "BZHI r32a, r/m32, r32b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Zero bits in r/m32 starting with the position in r32b, write result to r32a."
        },
        {
          "Opcode": "VEX.NDS.LZ.0F38.W1 F5 /r",
          "Instruction": "BZHI r64a, r/m64, r64b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Zero bits in r/m64 starting with the position in r64b, write result to r64a."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "VEX.vvvv (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CALL",
      "Description": "Call Procedure",
      "Url": "https://www.felixcloutier.com/x86/CALL.html",
      "Table": [
        {
          "Opcode": "E8 cw",
          "Instruction": "CALL rel16",
          "OperandEncoding": "M",
          "Bit64Mode": "N.S.",
          "CompatLegMode": "Valid",
          "Description": "Call near, relative, displacement relative to next instruction."
        },
        {
          "Opcode": "E8 cd",
          "Instruction": "CALL rel32",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Call near, relative, displacement relative to next instruction. 32-bit displacement sign extended to 64-bits in 64-bit mode."
        },
        {
          "Opcode": "FF /2",
          "Instruction": "CALL r/m16",
          "OperandEncoding": "M",
          "Bit64Mode": "N.E.",
          "CompatLegMode": "Valid",
          "Description": "Call near, absolute indirect, address given in r/m16."
        },
        {
          "Opcode": "FF /2",
          "Instruction": "CALL r/m32",
          "OperandEncoding": "M",
          "Bit64Mode": "N.E.",
          "CompatLegMode": "Valid",
          "Description": "Call near, absolute indirect, address given in r/m32."
        },
        {
          "Opcode": "FF /2",
          "Instruction": "CALL r/m64",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "Call near, absolute indirect, address given in r/m64."
        },
        {
          "Opcode": "9A cd",
          "Instruction": "CALL ptr16:16",
          "OperandEncoding": "D",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Call far, absolute, address given in operand."
        },
        {
          "Opcode": "9A cp",
          "Instruction": "CALL ptr16:32",
          "OperandEncoding": "D",
          "Bit64Mode": "Invalid",
          "CompatLegMode": "Valid",
          "Description": "Call far, absolute, address given in operand."
        },
        {
          "Opcode": "FF /3",
          "Instruction": "CALL m16:16",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Call far, absolute indirect address given in m16:16. In 32-bit mode: if selector points to a gate, then RIP = 32-bit zero extended displacement taken from gate; else RIP = zero extended 16-bit offset from far pointer referenced in the instruction."
        },
        {
          "Opcode": "FF /3",
          "Instruction": "CALL m16:32",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = zero extended 32-bit offset from far pointer referenced in the instruction."
        },
        {
          "Opcode": "REX.W + FF /3",
          "Instruction": "CALL m16:64",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "In 64-bit mode: If selector points to a gate, then RIP = 64-bit displacement taken from gate; else RIP = 64-bit offset from far pointer referenced in the instruction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "D",
          "Operands": [
            "Offset"
          ]
        },
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CBW",
      "Description": "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CBW:CWDE:CDQE.html",
      "Table": [
        {
          "Opcode": "98",
          "Instruction": "CBW",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "AX ← sign-extend of AL."
        },
        {
          "Opcode": "98",
          "Instruction": "CWDE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "EAX ← sign-extend of AX."
        },
        {
          "Opcode": "REX.W + 98",
          "Instruction": "CDQE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "RAX ← sign-extend of EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CDQ",
      "Description": "Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CWD:CDQ:CQO.html",
      "Table": [
        {
          "Opcode": "99",
          "Instruction": "CWD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "DX:AX ← sign-extend of AX."
        },
        {
          "Opcode": "99",
          "Instruction": "CDQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "EDX:EAX ← sign-extend of EAX."
        },
        {
          "Opcode": "REX.W + 99",
          "Instruction": "CQO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "RDX:RAX← sign-extend of RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CDQE",
      "Description": "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CBW:CWDE:CDQE.html",
      "Table": [
        {
          "Opcode": "98",
          "Instruction": "CBW",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "AX ← sign-extend of AL."
        },
        {
          "Opcode": "98",
          "Instruction": "CWDE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "EAX ← sign-extend of AX."
        },
        {
          "Opcode": "REX.W + 98",
          "Instruction": "CDQE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "RAX ← sign-extend of EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLAC",
      "Description": "Clear AC Flag in EFLAGS Register",
      "Url": "https://www.felixcloutier.com/x86/CLAC.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 CA",
          "Instruction": "CLAC",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SMAP",
          "Description": "Clear the AC flag in the EFLAGS register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLC",
      "Description": "Clear Carry Flag",
      "Url": "https://www.felixcloutier.com/x86/CLC.html",
      "Table": [
        {
          "Opcode": "F8",
          "Instruction": "CLC",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Clear CF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLD",
      "Description": "Clear Direction Flag",
      "Url": "https://www.felixcloutier.com/x86/CLD.html",
      "Table": [
        {
          "Opcode": "FC",
          "Instruction": "CLD",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Clear DF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLFLUSH",
      "Description": "Flush Cache Line",
      "Url": "https://www.felixcloutier.com/x86/CLFLUSH.html",
      "Table": [
        {
          "Opcode": "NP 0F AE /7",
          "Instruction": "CLFLUSH m8",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Flushes cache line containing m8."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CLFLUSHOPT",
      "Description": "Flush Cache Line Optimized",
      "Url": "https://www.felixcloutier.com/x86/CLFLUSHOPT.html",
      "Table": [
        {
          "Opcode": "66 0F AE /7",
          "Instruction": "CLFLUSHOPT m8",
          "OperandEncoding": "M",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Flushes cache line containing m8."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CLI",
      "Description": "Clear Interrupt Flag",
      "Url": "https://www.felixcloutier.com/x86/CLI.html",
      "Table": [
        {
          "Opcode": "FA",
          "Instruction": "CLI",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Clear interrupt flag; interrupts disabled when interrupt flag cleared."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLTS",
      "Description": "Clear Task-Switched Flag in CR0",
      "Url": "https://www.felixcloutier.com/x86/CLTS.html",
      "Table": [
        {
          "Opcode": "0F 06",
          "Instruction": "CLTS",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Clears TS flag in CR0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CLWB",
      "Description": "Cache Line Write Back",
      "Url": "https://www.felixcloutier.com/x86/CLWB.html",
      "Table": [
        {
          "Opcode": "66 0F AE /6",
          "Instruction": "CLWB m8",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "CLWB",
          "Description": "Writes back modified cache line containing m8, and may retain the line in cache hierarchy in non-modified state."
        }
      ]
    },
    {
      "Mnemonic": "CMC",
      "Description": "Complement Carry Flag",
      "Url": "https://www.felixcloutier.com/x86/CMC.html",
      "Table": [
        {
          "Opcode": "F5",
          "Instruction": "CMC",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Complement CF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMOVcc",
      "Description": "Conditional Move",
      "Url": "https://www.felixcloutier.com/x86/CMOVcc.html",
      "Table": [
        {
          "Opcode": "0F 47 /r",
          "Instruction": "CMOVA r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 47 /r",
          "Instruction": "CMOVA r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "REX.W + 0F 47 /r",
          "Instruction": "CMOVA r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVAE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if above or equal (CF=0)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVAE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if above or equal (CF=0)."
        },
        {
          "Opcode": "REX.W + 0F 43 /r",
          "Instruction": "CMOVAE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if above or equal (CF=0)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVB r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if below (CF=1)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVB r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if below (CF=1)."
        },
        {
          "Opcode": "REX.W + 0F 42 /r",
          "Instruction": "CMOVB r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if below (CF=1)."
        },
        {
          "Opcode": "0F 46 /r",
          "Instruction": "CMOVBE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 46 /r",
          "Instruction": "CMOVBE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "REX.W + 0F 46 /r",
          "Instruction": "CMOVBE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVC r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if carry (CF=1)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVC r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if carry (CF=1)."
        },
        {
          "Opcode": "REX.W + 0F 42 /r",
          "Instruction": "CMOVC r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if carry (CF=1)."
        },
        {
          "Opcode": "0F 44 /r",
          "Instruction": "CMOVE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if equal (ZF=1)."
        },
        {
          "Opcode": "0F 44 /r",
          "Instruction": "CMOVE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if equal (ZF=1)."
        },
        {
          "Opcode": "REX.W + 0F 44 /r",
          "Instruction": "CMOVE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if equal (ZF=1)."
        },
        {
          "Opcode": "0F 4F /r",
          "Instruction": "CMOVG r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 4F /r",
          "Instruction": "CMOVG r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "REX.W + 0F 4F /r",
          "Instruction": "CMOVG r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "NA",
          "Description": "Move if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 4D /r",
          "Instruction": "CMOVGE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if greater or equal (SF=OF)."
        },
        {
          "Opcode": "0F 4D /r",
          "Instruction": "CMOVGE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if greater or equal (SF=OF)."
        },
        {
          "Opcode": "REX.W + 0F 4D /r",
          "Instruction": "CMOVGE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if greater or equal (SF=OF)."
        },
        {
          "Opcode": "0F 4C /r",
          "Instruction": "CMOVL r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if less (SF≠ OF)."
        },
        {
          "Opcode": "0F 4C /r",
          "Instruction": "CMOVL r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if less (SF≠ OF)."
        },
        {
          "Opcode": "REX.W + 0F 4C /r",
          "Instruction": "CMOVL r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if less (SF≠ OF)."
        },
        {
          "Opcode": "0F 4E /r",
          "Instruction": "CMOVLE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 4E /r",
          "Instruction": "CMOVLE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "REX.W + 0F 4E /r",
          "Instruction": "CMOVLE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 46 /r",
          "Instruction": "CMOVNA r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 46 /r",
          "Instruction": "CMOVNA r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "REX.W + 0F 46 /r",
          "Instruction": "CMOVNA r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVNAE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not above or equal (CF=1)."
        },
        {
          "Opcode": "0F 42 /r",
          "Instruction": "CMOVNAE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not above or equal (CF=1)."
        },
        {
          "Opcode": "REX.W + 0F 42 /r",
          "Instruction": "CMOVNAE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not above or equal (CF=1)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVNB r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not below (CF=0)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVNB r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not below (CF=0)."
        },
        {
          "Opcode": "REX.W + 0F 43 /r",
          "Instruction": "CMOVNB r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not below (CF=0)."
        },
        {
          "Opcode": "0F 47 /r",
          "Instruction": "CMOVNBE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 47 /r",
          "Instruction": "CMOVNBE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "REX.W + 0F 47 /r",
          "Instruction": "CMOVNBE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVNC r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not carry (CF=0)."
        },
        {
          "Opcode": "0F 43 /r",
          "Instruction": "CMOVNC r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not carry (CF=0)."
        },
        {
          "Opcode": "REX.W + 0F 43 /r",
          "Instruction": "CMOVNC r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not carry (CF=0)."
        },
        {
          "Opcode": "0F 45 /r",
          "Instruction": "CMOVNE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not equal (ZF=0)."
        },
        {
          "Opcode": "0F 45 /r",
          "Instruction": "CMOVNE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not equal (ZF=0)."
        },
        {
          "Opcode": "REX.W + 0F 45 /r",
          "Instruction": "CMOVNE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not equal (ZF=0)."
        },
        {
          "Opcode": "0F 4E /r",
          "Instruction": "CMOVNG r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 4E /r",
          "Instruction": "CMOVNG r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "REX.W + 0F 4E /r",
          "Instruction": "CMOVNG r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 4C /r",
          "Instruction": "CMOVNGE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "0F 4C /r",
          "Instruction": "CMOVNGE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "REX.W + 0F 4C /r",
          "Instruction": "CMOVNGE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "0F 4D /r",
          "Instruction": "CMOVNL r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not less (SF=OF)."
        },
        {
          "Opcode": "0F 4D /r",
          "Instruction": "CMOVNL r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not less (SF=OF)."
        },
        {
          "Opcode": "REX.W + 0F 4D /r",
          "Instruction": "CMOVNL r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not less (SF=OF)."
        },
        {
          "Opcode": "0F 4F /r",
          "Instruction": "CMOVNLE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 4F /r",
          "Instruction": "CMOVNLE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "REX.W + 0F 4F /r",
          "Instruction": "CMOVNLE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 41 /r",
          "Instruction": "CMOVNO r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not overflow (OF=0)."
        },
        {
          "Opcode": "0F 41 /r",
          "Instruction": "CMOVNO r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not overflow (OF=0)."
        },
        {
          "Opcode": "REX.W + 0F 41 /r",
          "Instruction": "CMOVNO r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not overflow (OF=0)."
        },
        {
          "Opcode": "0F 4B /r",
          "Instruction": "CMOVNP r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not parity (PF=0)."
        },
        {
          "Opcode": "0F 4B /r",
          "Instruction": "CMOVNP r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not parity (PF=0)."
        },
        {
          "Opcode": "REX.W + 0F 4B /r",
          "Instruction": "CMOVNP r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not parity (PF=0)."
        },
        {
          "Opcode": "0F 49 /r",
          "Instruction": "CMOVNS r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not sign (SF=0)."
        },
        {
          "Opcode": "0F 49 /r",
          "Instruction": "CMOVNS r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not sign (SF=0)."
        },
        {
          "Opcode": "REX.W + 0F 49 /r",
          "Instruction": "CMOVNS r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not sign (SF=0)."
        },
        {
          "Opcode": "0F 45 /r",
          "Instruction": "CMOVNZ r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not zero (ZF=0)."
        },
        {
          "Opcode": "0F 45 /r",
          "Instruction": "CMOVNZ r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if not zero (ZF=0)."
        },
        {
          "Opcode": "REX.W + 0F 45 /r",
          "Instruction": "CMOVNZ r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if not zero (ZF=0)."
        },
        {
          "Opcode": "0F 40 /r",
          "Instruction": "CMOVO r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if overflow (OF=1)."
        },
        {
          "Opcode": "0F 40 /r",
          "Instruction": "CMOVO r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if overflow (OF=1)."
        },
        {
          "Opcode": "REX.W + 0F 40 /r",
          "Instruction": "CMOVO r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if overflow (OF=1)."
        },
        {
          "Opcode": "0F 4A /r",
          "Instruction": "CMOVP r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity (PF=1)."
        },
        {
          "Opcode": "0F 4A /r",
          "Instruction": "CMOVP r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity (PF=1)."
        },
        {
          "Opcode": "REX.W + 0F 4A /r",
          "Instruction": "CMOVP r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if parity (PF=1)."
        },
        {
          "Opcode": "0F 4A /r",
          "Instruction": "CMOVPE r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity even (PF=1)."
        },
        {
          "Opcode": "0F 4A /r",
          "Instruction": "CMOVPE r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity even (PF=1)."
        },
        {
          "Opcode": "REX.W + 0F 4A /r",
          "Instruction": "CMOVPE r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if parity even (PF=1)."
        },
        {
          "Opcode": "0F 4B /r",
          "Instruction": "CMOVPO r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity odd (PF=0)."
        },
        {
          "Opcode": "0F 4B /r",
          "Instruction": "CMOVPO r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if parity odd (PF=0)."
        },
        {
          "Opcode": "REX.W + 0F 4B /r",
          "Instruction": "CMOVPO r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if parity odd (PF=0)."
        },
        {
          "Opcode": "0F 48 /r",
          "Instruction": "CMOVS r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if sign (SF=1)."
        },
        {
          "Opcode": "0F 48 /r",
          "Instruction": "CMOVS r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if sign (SF=1)."
        },
        {
          "Opcode": "REX.W + 0F 48 /r",
          "Instruction": "CMOVS r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if sign (SF=1)."
        },
        {
          "Opcode": "0F 44 /r",
          "Instruction": "CMOVZ r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if zero (ZF=1)."
        },
        {
          "Opcode": "0F 44 /r",
          "Instruction": "CMOVZ r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move if zero (ZF=1)."
        },
        {
          "Opcode": "REX.W + 0F 44 /r",
          "Instruction": "CMOVZ r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move if zero (ZF=1)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CMP",
      "Description": "Compare Two Operands",
      "Url": "https://www.felixcloutier.com/x86/CMP.html",
      "Table": [
        {
          "Opcode": "3C ib",
          "Instruction": "CMP AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Compare imm8 with AL."
        },
        {
          "Opcode": "3D iw",
          "Instruction": "CMP AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Compare imm16 with AX."
        },
        {
          "Opcode": "3D id",
          "Instruction": "CMP EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Compare imm32 with EAX."
        },
        {
          "Opcode": "REX.W + 3D id",
          "Instruction": "CMP RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "Compare imm32 sign-extended to 64-bits with RAX."
        },
        {
          "Opcode": "80 /7 ib",
          "Instruction": "CMP r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Compare imm8 with r/m8."
        },
        {
          "Opcode": "REX + 80 /7 ib",
          "Instruction": "CMP r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Compare imm8 with r/m8."
        },
        {
          "Opcode": "81 /7 iw",
          "Instruction": "CMP r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Compare imm16 with r/m16."
        },
        {
          "Opcode": "81 /7 id",
          "Instruction": "CMP r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Compare imm32 with r/m32."
        },
        {
          "Opcode": "REX.W + 81 /7 id",
          "Instruction": "CMP r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Compare imm32 sign-extended to 64-bits with r/m64."
        },
        {
          "Opcode": "83 /7 ib",
          "Instruction": "CMP r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Compare imm8 with r/m16."
        },
        {
          "Opcode": "83 /7 ib",
          "Instruction": "CMP r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Compare imm8 with r/m32."
        },
        {
          "Opcode": "REX.W + 83 /7 ib",
          "Instruction": "CMP r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Compare imm8 with r/m64."
        },
        {
          "Opcode": "38 /r",
          "Instruction": "CMP r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Compare r8 with r/m8."
        },
        {
          "Opcode": "REX + 38 /r",
          "Instruction": "CMP r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Compare r8 with r/m8."
        },
        {
          "Opcode": "39 /r",
          "Instruction": "CMP r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Compare r16 with r/m16."
        },
        {
          "Opcode": "39 /r",
          "Instruction": "CMP r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Compare r32 with r/m32."
        },
        {
          "Opcode": "REX.W + 39 /r",
          "Instruction": "CMP r/m64,r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Compare r64 with r/m64."
        },
        {
          "Opcode": "3A /r",
          "Instruction": "CMP r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Compare r/m8 with r8."
        },
        {
          "Opcode": "REX + 3A /r",
          "Instruction": "CMP r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Compare r/m8 with r8."
        },
        {
          "Opcode": "3B /r",
          "Instruction": "CMP r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Compare r/m16 with r16."
        },
        {
          "Opcode": "3B /r",
          "Instruction": "CMP r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Compare r/m32 with r32."
        },
        {
          "Opcode": "REX.W + 3B /r",
          "Instruction": "CMP r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Compare r/m64 with r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX (r)",
            "imm8/16/32"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CMPPD",
      "Description": "Compare Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CMPPD.html",
      "Table": [
        {
          "Opcode": "66 0F C2 /r ib",
          "Instruction": "CMPPD xmm1, xmm2/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed double-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG C2 /r ib",
          "Instruction": "VCMPPD xmm1, xmm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed double-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG C2 /r ib",
          "Instruction": "VCMPPD ymm1, ymm2, ymm3/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed double-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 C2 /r ib",
          "Instruction": "VCMPPD k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed double-precision floating-point values in xmm3/m128/m64bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 C2 /r ib",
          "Instruction": "VCMPPD k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed double-precision floating-point values in ymm3/m256/m64bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 C2 /r ib",
          "Instruction": "VCMPPD k1 {k2}, zmm2, zmm3/m512/m64bcst{sae}, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed double-precision floating-point values in zmm3/m512/m64bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "CMPPS",
      "Description": "Compare Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CMPPS.html",
      "Table": [
        {
          "Opcode": "NP 0F C2 /r ib",
          "Instruction": "CMPPS xmm1, xmm2/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare packed single-precision floating-point values in xmm2/m128 and xmm1 using bits 2:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG C2 /r ib",
          "Instruction": "VCMPPS xmm1, xmm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed single-precision floating-point values in xmm3/m128 and xmm2 using bits 4:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG C2 /r ib",
          "Instruction": "VCMPPS ymm1, ymm2, ymm3/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed single-precision floating-point values in ymm3/m256 and ymm2 using bits 4:0 of imm8 as a comparison predicate."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 C2 /r ib",
          "Instruction": "VCMPPS k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed single-precision floating-point values in xmm3/m128/m32bcst and xmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 C2 /r ib",
          "Instruction": "VCMPPS k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed single-precision floating-point values in ymm3/m256/m32bcst and ymm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 C2 /r ib",
          "Instruction": "VCMPPS k1 {k2}, zmm2, zmm3/m512/m32bcst{sae}, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed single-precision floating-point values in zmm3/m512/m32bcst and zmm2 using bits 4:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "CMPS",
      "Description": "Compare String Operands",
      "Url": "https://www.felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html",
      "Table": [
        {
          "Opcode": "A6",
          "Instruction": "CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        },
        {
          "Opcode": "A6",
          "Instruction": "CMPSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMPSB",
      "Description": "Compare String Operands",
      "Url": "https://www.felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html",
      "Table": [
        {
          "Opcode": "A6",
          "Instruction": "CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        },
        {
          "Opcode": "A6",
          "Instruction": "CMPSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMPSD",
      "Description": "Compare String Operands",
      "Url": "https://www.felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html",
      "Table": [
        {
          "Opcode": "A6",
          "Instruction": "CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        },
        {
          "Opcode": "A6",
          "Instruction": "CMPSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMPSD",
      "UniqueName": "cmpsd_fp",
      "Description": "Compare Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CMPSD.html",
      "Table": [
        {
          "Opcode": "F2 0F C2 /r ib",
          "Instruction": "CMPSD xmm1, xmm2/m64, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare low double-precision floating-point value in xmm2/m64 and xmm1 using bits 2:0 of imm8 as comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG C2 /r ib",
          "Instruction": "VCMPSD xmm1, xmm2, xmm3/m64, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 C2 /r ib",
          "Instruction": "VCMPSD k1 {k2}, xmm2, xmm3/m64{sae}, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low double-precision floating-point value in xmm3/m64 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "CMPSQ",
      "Description": "Compare String Operands",
      "Url": "https://www.felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html",
      "Table": [
        {
          "Opcode": "A6",
          "Instruction": "CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        },
        {
          "Opcode": "A6",
          "Instruction": "CMPSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMPSS",
      "Description": "Compare Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CMPSS.html",
      "Table": [
        {
          "Opcode": "F3 0F C2 /r ib",
          "Instruction": "CMPSS xmm1, xmm2/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare low single-precision floating-point value in xmm2/m32 and xmm1 using bits 2:0 of imm8 as comparison predicate."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG C2 /r ib",
          "Instruction": "VCMPSS xmm1, xmm2, xmm3/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 C2 /r ib",
          "Instruction": "VCMPSS k1 {k2}, xmm2, xmm3/m32{sae}, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low single-precision floating-point value in xmm3/m32 and xmm2 using bits 4:0 of imm8 as comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "CMPSW",
      "Description": "Compare String Operands",
      "Url": "https://www.felixcloutier.com/x86/CMPS:CMPSB:CMPSW:CMPSD:CMPSQ.html",
      "Table": [
        {
          "Opcode": "A6",
          "Instruction": "CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI to byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI at dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI at dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        },
        {
          "Opcode": "A6",
          "Instruction": "CMPSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare byte at address DS:(E)SI with byte at address ES:(E)DI; For 64-bit mode compare byte at address (R|E)SI with byte at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare word at address DS:(E)SI with word at address ES:(E)DI; For 64-bit mode compare word at address (R|E)SI with word at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "A7",
          "Instruction": "CMPSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, compare dword at address DS:(E)SI with dword at address ES:(E)DI; For 64-bit mode compare dword at address (R|E)SI with dword at address (R|E)DI. The status flags are set accordingly."
        },
        {
          "Opcode": "REX.W + A7",
          "Instruction": "CMPSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compares quadword at address (R|E)SI with quadword at address (R|E)DI and sets the status flags accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CMPXCHG",
      "Description": "Compare and Exchange",
      "Url": "https://www.felixcloutier.com/x86/CMPXCHG.html",
      "Table": [
        {
          "Opcode": "0F B0/r",
          "Instruction": "CMPXCHG r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid*",
          "Description": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
        },
        {
          "Opcode": "REX + 0F B0/r",
          "Instruction": "CMPXCHG r/m8**,r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Compare AL with r/m8. If equal, ZF is set and r8 is loaded into r/m8. Else, clear ZF and load r/m8 into AL."
        },
        {
          "Opcode": "0F B1/r",
          "Instruction": "CMPXCHG r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid*",
          "Description": "Compare AX with r/m16. If equal, ZF is set and r16 is loaded into r/m16. Else, clear ZF and load r/m16 into AX."
        },
        {
          "Opcode": "0F B1/r",
          "Instruction": "CMPXCHG r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid*",
          "Description": "Compare EAX with r/m32. If equal, ZF is set and r32 is loaded into r/m32. Else, clear ZF and load r/m32 into EAX."
        },
        {
          "Opcode": "REX.W + 0F B1/r",
          "Instruction": "CMPXCHG r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with r/m64. If equal, ZF is set and r64 is loaded into r/m64. Else, clear ZF and load r/m64 into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CMPXCHG16B",
      "Description": "Compare and Exchange Bytes",
      "Url": "https://www.felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html",
      "Table": [
        {
          "Opcode": "REX.W + 0F C7 /1 m128",
          "Instruction": "CMPXCHG16B m128",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Compare RDX:RAX with m128. If equal, set ZF and load RCX:RBX into m128. Else, clear ZF and load m128 into RDX:RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CMPXCHG8B",
      "Description": "Compare and Exchange Bytes",
      "Url": "https://www.felixcloutier.com/x86/CMPXCHG8B:CMPXCHG16B.html",
      "Table": [
        {
          "Opcode": "0F C7 /1 m64",
          "Instruction": "CMPXCHG8B m64",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid*",
          "Description": "Compare EDX:EAX with m64. If equal, set ZF and load ECX:EBX into m64. Else, clear ZF and load m64 into EDX:EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "COMISD",
      "Description": "Compare Scalar Ordered Double-Precision Floating-Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/COMISD.html",
      "Table": [
        {
          "Opcode": "66 0F 2F /r",
          "Instruction": "COMISD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "VEX.LIG.66.0F.WIG 2F /r",
          "Instruction": "VCOMISD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "EVEX.LIG.66.0F.W1 2F /r",
          "Instruction": "VCOMISD xmm1, xmm2/m64{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
        }
      ]
    },
    {
      "Mnemonic": "COMISS",
      "Description": "Compare Scalar Ordered Single-Precision Floating-Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/COMISS.html",
      "Table": [
        {
          "Opcode": "NP 0F 2F /r",
          "Instruction": "COMISS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "VEX.LIG.0F.WIG 2F /r",
          "Instruction": "VCOMISS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "EVEX.LIG.0F.W0 2F /r",
          "Instruction": "VCOMISS xmm1, xmm2/m32{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        }
      ]
    },
    {
      "Mnemonic": "CPUID",
      "Description": "CPU Identification",
      "Url": "https://www.felixcloutier.com/x86/CPUID.html",
      "Table": [
        {
          "Opcode": "0F A2",
          "Instruction": "CPUID",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Returns processor identification and feature information to the EAX, EBX, ECX, and EDX registers, as determined by input entered in EAX (in some cases, ECX as well)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CQO",
      "Description": "Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CWD:CDQ:CQO.html",
      "Table": [
        {
          "Opcode": "99",
          "Instruction": "CWD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "DX:AX ← sign-extend of AX."
        },
        {
          "Opcode": "99",
          "Instruction": "CDQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "EDX:EAX ← sign-extend of EAX."
        },
        {
          "Opcode": "REX.W + 99",
          "Instruction": "CQO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "RDX:RAX← sign-extend of RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CRC32",
      "Description": "Accumulate CRC32 Value",
      "Url": "https://www.felixcloutier.com/x86/CRC32.html",
      "Table": [
        {
          "Opcode": "F2 0F 38 F0 /r",
          "Instruction": "CRC32 r32, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Accumulate CRC32 on r/m8."
        },
        {
          "Opcode": "F2 REX 0F 38 F0 /r",
          "Instruction": "CRC32 r32, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Accumulate CRC32 on r/m8."
        },
        {
          "Opcode": "F2 0F 38 F1 /r",
          "Instruction": "CRC32 r32, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Accumulate CRC32 on r/m16."
        },
        {
          "Opcode": "F2 0F 38 F1 /r",
          "Instruction": "CRC32 r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Accumulate CRC32 on r/m32."
        },
        {
          "Opcode": "F2 REX.W 0F 38 F0 /r",
          "Instruction": "CRC32 r64, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Accumulate CRC32 on r/m8."
        },
        {
          "Opcode": "F2 REX.W 0F 38 F1 /r",
          "Instruction": "CRC32 r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Accumulate CRC32 on r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTDQ2PD",
      "Description": "Convert Packed Doubleword Integers to Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CVTDQ2PD.html",
      "Table": [
        {
          "Opcode": "F3 0F E6 /r",
          "Instruction": "CVTDQ2PD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG E6 /r",
          "Instruction": "VCVTDQ2PD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert two packed signed doubleword integers from xmm2/mem to two packed double-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG E6 /r",
          "Instruction": "VCVTDQ2PD ymm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed signed doubleword integers from xmm2/mem to four packed double-precision floating-point values in ymm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 E6 /r",
          "Instruction": "VCVTDQ2PD xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert 2 packed signed doubleword integers from xmm2/m128/m32bcst to eight packed double-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 E6 /r",
          "Instruction": "VCVTDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert 4 packed signed doubleword integers from xmm2/m128/m32bcst to 4 packed double-precision floating-point values in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 E6 /r",
          "Instruction": "VCVTDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert eight packed signed doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTDQ2PS",
      "Description": "Convert Packed Doubleword Integers to Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CVTDQ2PS.html"
    },
    {
      "Mnemonic": "CVTPD2DQ",
      "Description": "Convert Packed Double-Precision Floating-Point Values to Packed Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTPD2DQ.html"
    },
    {
      "Mnemonic": "CVTPD2PI",
      "Description": "Convert Packed Double-Precision FP Values to Packed Dword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTPD2PI.html",
      "Table": [
        {
          "Opcode": "66 0F 2D /r",
          "Instruction": "CVTPD2PI mm, xmm/m128",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two packed double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTPD2PS",
      "Description": "Convert Packed Double-Precision Floating-Point Values to Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CVTPD2PS.html",
      "Table": [
        {
          "Opcode": "66 0F 5A /r",
          "Instruction": "CVTPD2PS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 5A /r",
          "Instruction": "VCVTPD2PS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert two packed double-precision floating-point values in xmm2/mem to two single-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 5A /r",
          "Instruction": "VCVTPD2PS xmm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed double-precision floating-point values in ymm2/mem to four single-precision floating-point values in xmm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 5A /r",
          "Instruction": "VCVTPD2PS xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two single-precision floating-point values in xmm1with writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 5A /r",
          "Instruction": "VCVTPD2PS xmm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four single-precision floating-point values in xmm1with writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 5A /r",
          "Instruction": "VCVTPD2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight single-precision floating-point values in ymm1with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTPI2PD",
      "Description": "Convert Packed Dword Integers to Packed Double-Precision FP Values",
      "Url": "https://www.felixcloutier.com/x86/CVTPI2PD.html",
      "Table": [
        {
          "Opcode": "66 0F 2A /r",
          "Instruction": "CVTPI2PD xmm, mm/m64*",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two packed signed doubleword integers from mm/mem64 to two packed double-precision floating-point values in xmm."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTPI2PS",
      "Description": "Convert Packed Dword Integers to Packed Single-Precision FP Values",
      "Url": "https://www.felixcloutier.com/x86/CVTPI2PS.html",
      "Table": [
        {
          "Opcode": "NP 0F 2A /r",
          "Instruction": "CVTPI2PS xmm, mm/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two signed doubleword integers from mm/m64 to two single-precision floating-point values in xmm."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTPS2DQ",
      "Description": "Convert Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/CVTPS2DQ.html",
      "Table": [
        {
          "Opcode": "66 0F 5B /r",
          "Instruction": "CVTPS2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 5B /r",
          "Instruction": "VCVTPS2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 5B /r",
          "Instruction": "VCVTPS2DQ ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 5B /r",
          "Instruction": "VCVTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 5B /r",
          "Instruction": "VCVTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 5B /r",
          "Instruction": "VCVTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTPS2PD",
      "Description": "Convert Packed Single-Precision Floating-Point Values to Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/CVTPS2PD.html",
      "Table": [
        {
          "Opcode": "NP 0F 5A /r",
          "Instruction": "CVTPS2PD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.128.0F.WIG 5A /r",
          "Instruction": "VCVTPS2PD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert two packed single-precision floating-point values in xmm2/m64 to two packed double-precision floating-point values in xmm1."
        },
        {
          "Opcode": "VEX.256.0F.WIG 5A /r",
          "Instruction": "VCVTPS2PD ymm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed single-precision floating-point values in xmm2/m128 to four packed double-precision floating-point values in ymm1."
        },
        {
          "Opcode": "EVEX.128.0F.W0 5A /r",
          "Instruction": "VCVTPS2PD xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert two packed single-precision floating-point values in xmm2/m64/m32bcst to packed double-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 5A /r",
          "Instruction": "VCVTPS2PD ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL",
          "Description": "Convert four packed single-precision floating-point values in xmm2/m128/m32bcst to packed double-precision floating-point values in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 5A /r",
          "Instruction": "VCVTPS2PD zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert eight packed single-precision floating-point values in ymm2/m256/b32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTPS2PI",
      "Description": "Convert Packed Single-Precision FP Values to Packed Dword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTPS2PI.html",
      "Table": [
        {
          "Opcode": "NP 0F 2D /r",
          "Instruction": "CVTPS2PI mm, xmm/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two packed single-precision floating-point values from xmm/m64 to two packed signed doubleword integers in mm."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTSD2SI",
      "Description": "Convert Scalar Double-Precision Floating-Point Value to Doubleword Integer",
      "Url": "https://www.felixcloutier.com/x86/CVTSD2SI.html",
      "Table": [
        {
          "Opcode": "F2 0F 2D /r",
          "Instruction": "CVTSD2SI r32, xmm1/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
        },
        {
          "Opcode": "F2 REX.W 0F 2D /r",
          "Instruction": "CVTSD2SI r64, xmm1/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.W0 2D /r 1",
          "Instruction": "VCVTSD2SI r32, xmm1/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.W1 2D /r 1",
          "Instruction": "VCVTSD2SI r64, xmm1/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W0 2D /r",
          "Instruction": "VCVTSD2SI r32, xmm1/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer r32."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 2D /r",
          "Instruction": "VCVTSD2SI r64, xmm1/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer sign-extended into r64."
        }
      ]
    },
    {
      "Mnemonic": "CVTSD2SS",
      "Description": "Convert Scalar Double-Precision Floating-Point Value to Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CVTSD2SS.html",
      "Table": [
        {
          "Opcode": "F2 0F 5A /r",
          "Instruction": "CVTSD2SS xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one double-precision floating-point value in xmm2/m64 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 5A /r",
          "Instruction": "VCVTSD2SS xmm1,xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 5A /r",
          "Instruction": "VCVTSD2SS xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value in xmm3/m64 to one single-precision floating-point value and merge with high bits in xmm2 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTSI2SD",
      "Description": "Convert Doubleword Integer to Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CVTSI2SD.html",
      "Table": [
        {
          "Opcode": "F2 0F 2A /r",
          "Instruction": "CVTSI2SD xmm1, r32/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one signed doubleword integer from r32/m32 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "F2 REX.W 0F 2A /r",
          "Instruction": "CVTSI2SD xmm1, r/m64",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.W0 2A /r",
          "Instruction": "VCVTSI2SD xmm1, xmm2, r/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.W1 2A /r",
          "Instruction": "VCVTSI2SD xmm1, xmm2, r/m64",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W0 2A /r",
          "Instruction": "VCVTSI2SD xmm1, xmm2, r/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 2A /r",
          "Instruction": "VCVTSI2SD xmm1, xmm2, r/m64{er}",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed quadword integer from r/m64 to one double-precision floating-point value in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "CVTSI2SS",
      "Description": "Convert Doubleword Integer to Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CVTSI2SS.html",
      "Table": [
        {
          "Opcode": "F3 0F 2A /r",
          "Instruction": "CVTSI2SS xmm1, r/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "F3 REX.W 0F 2A /r",
          "Instruction": "CVTSI2SS xmm1, r/m64",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.W0 2A /r",
          "Instruction": "VCVTSI2SS xmm1, xmm2, r/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.W1 2A /r",
          "Instruction": "VCVTSI2SS xmm1, xmm2, r/m64",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 2A /r",
          "Instruction": "VCVTSI2SS xmm1, xmm2, r/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W1 2A /r",
          "Instruction": "VCVTSI2SS xmm1, xmm2, r/m64{er}",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "CVTSS2SD",
      "Description": "Convert Scalar Single-Precision Floating-Point Value to Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/CVTSS2SD.html",
      "Table": [
        {
          "Opcode": "F3 0F 5A /r",
          "Instruction": "CVTSS2SD xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one single-precision floating-point value in xmm2/m32 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 5A /r",
          "Instruction": "VCVTSS2SD xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 5A /r",
          "Instruction": "VCVTSS2SD xmm1 {k1}{z}, xmm2, xmm3/m32{sae}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value in xmm3/m32 to one double-precision floating-point value and merge with high bits of xmm2 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTSS2SI",
      "Description": "Convert Scalar Single-Precision Floating-Point Value to Doubleword Integer",
      "Url": "https://www.felixcloutier.com/x86/CVTSS2SI.html",
      "Table": [
        {
          "Opcode": "F3 0F 2D /r",
          "Instruction": "CVTSS2SI r32, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
        },
        {
          "Opcode": "F3 REX.W 0F 2D /r",
          "Instruction": "CVTSS2SI r64, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
        },
        {
          "Opcode": "VEX.LIG.F3.0F.W0 2D /r 1",
          "Instruction": "VCVTSS2SI r32, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
        },
        {
          "Opcode": "VEX.LIG.F3.0F.W1 2D /r 1",
          "Instruction": "VCVTSS2SI r64, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 2D /r",
          "Instruction": "VCVTSS2SI r32, xmm1/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W1 2D /r",
          "Instruction": "VCVTSS2SI r64, xmm1/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64."
        }
      ]
    },
    {
      "Mnemonic": "CVTTPD2DQ",
      "Description": "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTTPD2DQ.html",
      "Table": [
        {
          "Opcode": "66 0F E6 /r",
          "Instruction": "CVTTPD2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG E6 /r",
          "Instruction": "VCVTTPD2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert two packed double-precision floating-point values in xmm2/mem to two signed doubleword integers in xmm1 using truncation."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG E6 /r",
          "Instruction": "VCVTTPD2DQ xmm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed double-precision floating-point values in ymm2/mem to four signed doubleword integers in xmm1 using truncation."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 E6 /r",
          "Instruction": "VCVTTPD2DQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert two packed double-precision floating-point values in xmm2/m128/m64bcst to two signed doubleword integers in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 E6 /r",
          "Instruction": "VCVTTPD2DQ xmm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed double-precision floating-point values in ymm2/m256/m64bcst to four signed doubleword integers in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 E6 /r",
          "Instruction": "VCVTTPD2DQ ymm1 {k1}{z}, zmm2/m512/m64bcst{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert eight packed double-precision floating-point values in zmm2/m512/m64bcst to eight signed doubleword integers in ymm1 using truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTTPD2PI",
      "Description": "Convert with Truncation Packed Double-Precision FP Values to Packed Dword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTTPD2PI.html",
      "Table": [
        {
          "Opcode": "66 0F 2C /r",
          "Instruction": "CVTTPD2PI mm, xmm/m128",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two packer double-precision floating-point values from xmm/m128 to two packed signed doubleword integers in mm using truncation."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTTPS2DQ",
      "Description": "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Signed Doubleword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/CVTTPS2DQ.html",
      "Table": [
        {
          "Opcode": "F3 0F 5B /r",
          "Instruction": "CVTTPS2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 5B /r",
          "Instruction": "VCVTTPS2DQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert four packed single-precision floating-point values from xmm2/mem to four packed signed doubleword values in xmm1 using truncation."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 5B /r",
          "Instruction": "VCVTTPS2DQ ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert eight packed single-precision floating-point values from ymm2/mem to eight packed signed doubleword values in ymm1 using truncation."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 5B /r",
          "Instruction": "VCVTTPS2DQ xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed doubleword values in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 5B /r",
          "Instruction": "VCVTTPS2DQ ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed doubleword values in ymm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 5B /r",
          "Instruction": "VCVTTPS2DQ zmm1 {k1}{z}, zmm2/m512/m32bcst {sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed signed doubleword values in zmm1 using truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "CVTTPS2PI",
      "Description": "Convert with Truncation Packed Single-Precision FP Values to Packed Dword Integers",
      "Url": "https://www.felixcloutier.com/x86/CVTTPS2PI.html",
      "Table": [
        {
          "Opcode": "NP 0F 2C /r",
          "Instruction": "CVTTPS2PI mm, xmm/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Convert two single-precision floating-point values from xmm/m64 to two signed doubleword signed integers in mm using truncation."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "CVTTSD2SI",
      "Description": "Convert with Truncation Scalar Double-Precision Floating-Point Value to Signed Integer",
      "Url": "https://www.felixcloutier.com/x86/CVTTSD2SI.html",
      "Table": [
        {
          "Opcode": "F2 0F 2C /r",
          "Instruction": "CVTTSD2SI r32, xmm1/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "F2 REX.W 0F 2C /r",
          "Instruction": "CVTTSD2SI r64, xmm1/m64",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.W0 2C /r 1",
          "Instruction": "VCVTTSD2SI r32, xmm1/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.W1 2C /r 1",
          "Instruction": "VCVTTSD2SI r64, xmm1/m64",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W0 2C /r",
          "Instruction": "VCVTTSD2SI r32, xmm1/m64{sae}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 2C /r",
          "Instruction": "VCVTTSD2SI r64, xmm1/m64{sae}",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one signed quadword integer in r64 using truncation."
        }
      ]
    },
    {
      "Mnemonic": "CVTTSS2SI",
      "Description": "Convert with Truncation Scalar Single-Precision Floating-Point Value to Integer",
      "Url": "https://www.felixcloutier.com/x86/CVTTSS2SI.html",
      "Table": [
        {
          "Opcode": "F3 0F 2C /r",
          "Instruction": "CVTTSS2SI r32, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "F3 REX.W 0F 2C /r",
          "Instruction": "CVTTSS2SI r64, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
        },
        {
          "Opcode": "VEX.LIG.F3.0F.W0 2C /r 1",
          "Instruction": "VCVTTSS2SI r32, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "VEX.LIG.F3.0F.W1 2C /r 1",
          "Instruction": "VCVTTSS2SI r64, xmm1/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 2C /r",
          "Instruction": "VCVTTSS2SI r32, xmm1/m32{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W1 2C /r",
          "Instruction": "VCVTTSS2SI r64, xmm1/m32{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one signed quadword integer in r64 using truncation."
        }
      ]
    },
    {
      "Mnemonic": "CWD",
      "Description": "Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CWD:CDQ:CQO.html",
      "Table": [
        {
          "Opcode": "99",
          "Instruction": "CWD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "DX:AX ← sign-extend of AX."
        },
        {
          "Opcode": "99",
          "Instruction": "CDQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "EDX:EAX ← sign-extend of EAX."
        },
        {
          "Opcode": "REX.W + 99",
          "Instruction": "CQO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "RDX:RAX← sign-extend of RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "CWDE",
      "Description": "Convert Byte to Word/Convert Word to Doubleword/Convert Doubleword to Quadword",
      "Url": "https://www.felixcloutier.com/x86/CBW:CWDE:CDQE.html",
      "Table": [
        {
          "Opcode": "98",
          "Instruction": "CBW",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "AX ← sign-extend of AL."
        },
        {
          "Opcode": "98",
          "Instruction": "CWDE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "EAX ← sign-extend of AX."
        },
        {
          "Opcode": "REX.W + 98",
          "Instruction": "CDQE",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "N.E.",
          "Description": "RAX ← sign-extend of EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "DAA",
      "Description": "Decimal Adjust AL after Addition",
      "Url": "https://www.felixcloutier.com/x86/DAA.html",
      "Table": [
        {
          "Opcode": "27",
          "Instruction": "DAA",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Decimal adjust AL after addition."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "DAS",
      "Description": "Decimal Adjust AL after Subtraction",
      "Url": "https://www.felixcloutier.com/x86/DAS.html",
      "Table": [
        {
          "Opcode": "2F",
          "Instruction": "DAS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Decimal adjust AL after subtraction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "DEC",
      "Description": "Decrement by 1",
      "Url": "https://www.felixcloutier.com/x86/DEC.html",
      "Table": [
        {
          "Opcode": "FE /1",
          "Instruction": "DEC r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Decrement r/m8 by 1."
        },
        {
          "Opcode": "REX + FE /1",
          "Instruction": "DEC r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Decrement r/m8 by 1."
        },
        {
          "Opcode": "FF /1",
          "Instruction": "DEC r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Decrement r/m16 by 1."
        },
        {
          "Opcode": "FF /1",
          "Instruction": "DEC r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Decrement r/m32 by 1."
        },
        {
          "Opcode": "REX.W + FF /1",
          "Instruction": "DEC r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Decrement r/m64 by 1."
        },
        {
          "Opcode": "48+rw",
          "Instruction": "DEC r16",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Decrement r16 by 1."
        },
        {
          "Opcode": "48+rd",
          "Instruction": "DEC r32",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Decrement r32 by 1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        },
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "DIV",
      "Description": "Unsigned Divide",
      "Url": "https://www.felixcloutier.com/x86/DIV.html",
      "Table": [
        {
          "Opcode": "F6 /6",
          "Instruction": "DIV r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder."
        },
        {
          "Opcode": "REX + F6 /6",
          "Instruction": "DIV r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder."
        },
        {
          "Opcode": "F7 /6",
          "Instruction": "DIV r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder."
        },
        {
          "Opcode": "F7 /6",
          "Instruction": "DIV r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide EDX:EAX by r/m32, with result stored in EAX ← Quotient, EDX ← Remainder."
        },
        {
          "Opcode": "REX.W + F7 /6",
          "Instruction": "DIV r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide RDX:RAX by r/m64, with result stored in RAX ← Quotient, RDX ← Remainder."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "DIVPD",
      "Description": "Divide Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/DIVPD.html",
      "Table": [
        {
          "Opcode": "66 0F 5E /r",
          "Instruction": "DIVPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Divide packed double-precision floating-point values in xmm1 by packed double-precision floating-point values in xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 5E /r",
          "Instruction": "VDIVPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 5E /r",
          "Instruction": "VDIVPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 5E /r",
          "Instruction": "VDIVPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Divide packed double-precision floating-point values in xmm2 by packed double-precision floating-point values in xmm3/m128/m64bcst and write results to xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 5E /r",
          "Instruction": "VDIVPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Divide packed double-precision floating-point values in ymm2 by packed double-precision floating-point values in ymm3/m256/m64bcst and write results to ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 5E /r",
          "Instruction": "VDIVPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Divide packed double-precision floating-point values in zmm2 by packed double-precision FP values in zmm3/m512/m64bcst and write results to zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "DIVPS",
      "Description": "Divide Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/DIVPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 5E /r",
          "Instruction": "DIVPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Divide packed single-precision floating-point values in xmm1 by packed single-precision floating-point values in xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 5E /r",
          "Instruction": "VDIVPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 5E /r",
          "Instruction": "VDIVPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 5E /r",
          "Instruction": "VDIVPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Divide packed single-precision floating-point values in xmm2 by packed single-precision floating-point values in xmm3/m128/m32bcst and write results to xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 5E /r",
          "Instruction": "VDIVPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Divide packed single-precision floating-point values in ymm2 by packed single-precision floating-point values in ymm3/m256/m32bcst and write results to ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 5E /r",
          "Instruction": "VDIVPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Divide packed single-precision floating-point values in zmm2 by packed single-precision floating-point values in zmm3/m512/m32bcst and write results to zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "DIVSD",
      "Description": "Divide Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/DIVSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 5E /r",
          "Instruction": "DIVSD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Divide low double-precision floating-point value in xmm1 by low double-precision floating-point value in xmm2/m64."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 5E /r",
          "Instruction": "VDIVSD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 5E /r",
          "Instruction": "VDIVSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Divide low double-precision floating-point value in xmm2 by low double-precision floating-point value in xmm3/m64."
        }
      ]
    },
    {
      "Mnemonic": "DIVSS",
      "Description": "Divide Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/DIVSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 5E /r",
          "Instruction": "DIVSS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Divide low single-precision floating-point value in xmm1 by low single-precision floating-point value in xmm2/m32."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 5E /r",
          "Instruction": "VDIVSS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 5E /r",
          "Instruction": "VDIVSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Divide low single-precision floating-point value in xmm2 by low single-precision floating-point value in xmm3/m32."
        }
      ]
    },
    {
      "Mnemonic": "DPPD",
      "Description": "Dot Product of Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/DPPD.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 41 /r ib",
          "Instruction": "DPPD xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Selectively multiply packed DP floating-point values from xmm1 with packed DP floating-point values from xmm2, add and selectively store the packed DP floating-point values to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 41 /r ib",
          "Instruction": "VDPPD xmm1,xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Selectively multiply packed DP floating-point values from xmm2 with packed DP floating-point values from xmm3, add and selectively store the packed DP floating-point values to xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "DPPS",
      "Description": "Dot Product of Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/DPPS.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 40 /r ib",
          "Instruction": "DPPS xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Selectively multiply packed SP floating-point values from xmm1 with packed SP floating-point values from xmm2, add and selectively store the packed SP floating-point values or zero values to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 40 /r ib",
          "Instruction": "VDPPS xmm1,xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed SP floating point values from xmm1 with packed SP floating point values from xmm2/mem selectively add and store to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 40 /r ib",
          "Instruction": "VDPPS ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed single-precision floating-point values from ymm2 with packed SP floating point values from ymm3/mem, selectively add pairs of elements and store to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "EMMS",
      "Description": "Empty MMX Technology State",
      "Url": "https://www.felixcloutier.com/x86/EMMS.html",
      "Table": [
        {
          "Opcode": "NP 0F 77",
          "Instruction": "EMMS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set the x87 FPU tag word to empty."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "ENTER",
      "Description": "Make Stack Frame for Procedure Parameters",
      "Url": "https://www.felixcloutier.com/x86/ENTER.html",
      "Table": [
        {
          "Opcode": "C8 iw 00",
          "Instruction": "ENTER imm16, 0",
          "OperandEncoding": "II",
          "CompatLegMode": "Valid",
          "Description": "Create a stack frame for a procedure."
        },
        {
          "Opcode": "C8 iw 01",
          "Instruction": "ENTER imm16,1",
          "OperandEncoding": "II",
          "CompatLegMode": "Valid",
          "Description": "Create a stack frame with a nested pointer for a procedure."
        },
        {
          "Opcode": "C8 iw ib",
          "Instruction": "ENTER imm16, imm8",
          "OperandEncoding": "II",
          "CompatLegMode": "Valid",
          "Description": "Create a stack frame with nested pointers for a procedure."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "II",
          "Operands": [
            "iw",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "EXTRACTPS",
      "Description": "Extract Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/EXTRACTPS.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 17 /r ib",
          "Instruction": "EXTRACTPS reg/m32, xmm1, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "VV",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
        },
        {
          "Opcode": "VEX.128.66.0F3A.WIG 17 /r ib",
          "Instruction": "VEXTRACTPS reg/m32, xmm1, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.WIG 17 /r ib",
          "Instruction": "VEXTRACTPS reg/m32, xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract one single-precision floating-point value from xmm1 at the offset specified by imm8 and store the result in reg or m32. Zero extend the results in 64-bit register if applicable."
        }
      ]
    },
    {
      "Mnemonic": "F2XM1",
      "Description": "Compute 2x–1",
      "Url": "https://www.felixcloutier.com/x86/F2XM1.html",
      "Table": [
        {
          "Opcode": "D9 F0",
          "Instruction": "F2XM1",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with (2ST(0) – 1)."
        }
      ]
    },
    {
      "Mnemonic": "FABS",
      "Description": "Absolute Value",
      "Url": "https://www.felixcloutier.com/x86/FABS.html",
      "Table": [
        {
          "Opcode": "D9 E1",
          "Instruction": "FABS",
          "CompatLegMode": "Valid",
          "Description": "Replace ST with its absolute value."
        }
      ]
    },
    {
      "Mnemonic": "FADD",
      "Description": "Add",
      "Url": "https://www.felixcloutier.com/x86/FADD:FADDP:FIADD.html",
      "Table": [
        {
          "Opcode": "D8 /0",
          "Instruction": "FADD m32fp",
          "CompatLegMode": "Valid",
          "Description": "Add m32fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /0",
          "Instruction": "FADD m64fp",
          "CompatLegMode": "Valid",
          "Description": "Add m64fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 C0+i",
          "Instruction": "FADD ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C0+i",
          "Instruction": "FADD ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(i) to ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C0+i",
          "Instruction": "FADDP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C1",
          "Instruction": "FADDP",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /0",
          "Instruction": "FIADD m32int",
          "CompatLegMode": "Valid",
          "Description": "Add m32int to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /0",
          "Instruction": "FIADD m16int",
          "CompatLegMode": "Valid",
          "Description": "Add m16int to ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FADDP",
      "Description": "Add",
      "Url": "https://www.felixcloutier.com/x86/FADD:FADDP:FIADD.html",
      "Table": [
        {
          "Opcode": "D8 /0",
          "Instruction": "FADD m32fp",
          "CompatLegMode": "Valid",
          "Description": "Add m32fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /0",
          "Instruction": "FADD m64fp",
          "CompatLegMode": "Valid",
          "Description": "Add m64fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 C0+i",
          "Instruction": "FADD ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C0+i",
          "Instruction": "FADD ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(i) to ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C0+i",
          "Instruction": "FADDP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C1",
          "Instruction": "FADDP",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /0",
          "Instruction": "FIADD m32int",
          "CompatLegMode": "Valid",
          "Description": "Add m32int to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /0",
          "Instruction": "FIADD m16int",
          "CompatLegMode": "Valid",
          "Description": "Add m16int to ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FBLD",
      "Description": "Load Binary Coded Decimal",
      "Url": "https://www.felixcloutier.com/x86/FBLD.html",
      "Table": [
        {
          "Opcode": "DF /4",
          "Instruction": "FBLD m80bcd",
          "CompatLegMode": "Valid",
          "Description": "Convert BCD value to floating-point and push onto the FPU stack."
        }
      ]
    },
    {
      "Mnemonic": "FBSTP",
      "Description": "Store BCD Integer and Pop",
      "Url": "https://www.felixcloutier.com/x86/FBSTP.html",
      "Table": [
        {
          "Opcode": "DF /6",
          "Instruction": "FBSTP m80bcd",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m80bcd and pop ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FCHS",
      "Description": "Change Sign",
      "Url": "https://www.felixcloutier.com/x86/FCHS.html",
      "Table": [
        {
          "Opcode": "D9 E0",
          "Instruction": "FCHS",
          "CompatLegMode": "Valid",
          "Description": "Complements sign of ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FCLEX",
      "Description": "Clear Exceptions",
      "Url": "https://www.felixcloutier.com/x86/FCLEX:FNCLEX.html"
    },
    {
      "Mnemonic": "FCMOVcc",
      "Description": "Floating-Point Conditional Move",
      "Url": "https://www.felixcloutier.com/x86/FCMOVcc.html"
    },
    {
      "Mnemonic": "FCOM",
      "Description": "Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html",
      "Table": [
        {
          "Opcode": "D8 /2",
          "Instruction": "FCOM m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp."
        },
        {
          "Opcode": "DC /2",
          "Instruction": "FCOM m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp."
        },
        {
          "Opcode": "D8 D0+i",
          "Instruction": "FCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "D8 D1",
          "Instruction": "FCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "D8 /3",
          "Instruction": "FCOMP m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp and pop register stack."
        },
        {
          "Opcode": "DC /3",
          "Instruction": "FCOMP m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp and pop register stack."
        },
        {
          "Opcode": "D8 D8+i",
          "Instruction": "FCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "D8 D9",
          "Instruction": "FCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DE D9",
          "Instruction": "FCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FCOMI",
      "Description": "Compare Floating Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html",
      "Table": [
        {
          "Opcode": "DB F0+i",
          "Instruction": "FCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and set status flags accordingly."
        },
        {
          "Opcode": "DF F0+i",
          "Instruction": "FCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
        },
        {
          "Opcode": "DB E8+i",
          "Instruction": "FUCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
        },
        {
          "Opcode": "DF E8+i",
          "Instruction": "FUCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FCOMIP",
      "Description": "Compare Floating Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html",
      "Table": [
        {
          "Opcode": "DB F0+i",
          "Instruction": "FCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and set status flags accordingly."
        },
        {
          "Opcode": "DF F0+i",
          "Instruction": "FCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
        },
        {
          "Opcode": "DB E8+i",
          "Instruction": "FUCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
        },
        {
          "Opcode": "DF E8+i",
          "Instruction": "FUCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FCOMP",
      "Description": "Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html",
      "Table": [
        {
          "Opcode": "D8 /2",
          "Instruction": "FCOM m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp."
        },
        {
          "Opcode": "DC /2",
          "Instruction": "FCOM m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp."
        },
        {
          "Opcode": "D8 D0+i",
          "Instruction": "FCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "D8 D1",
          "Instruction": "FCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "D8 /3",
          "Instruction": "FCOMP m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp and pop register stack."
        },
        {
          "Opcode": "DC /3",
          "Instruction": "FCOMP m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp and pop register stack."
        },
        {
          "Opcode": "D8 D8+i",
          "Instruction": "FCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "D8 D9",
          "Instruction": "FCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DE D9",
          "Instruction": "FCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FCOMPP",
      "Description": "Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FCOM:FCOMP:FCOMPP.html",
      "Table": [
        {
          "Opcode": "D8 /2",
          "Instruction": "FCOM m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp."
        },
        {
          "Opcode": "DC /2",
          "Instruction": "FCOM m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp."
        },
        {
          "Opcode": "D8 D0+i",
          "Instruction": "FCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "D8 D1",
          "Instruction": "FCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "D8 /3",
          "Instruction": "FCOMP m32fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32fp and pop register stack."
        },
        {
          "Opcode": "DC /3",
          "Instruction": "FCOMP m64fp",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m64fp and pop register stack."
        },
        {
          "Opcode": "D8 D8+i",
          "Instruction": "FCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "D8 D9",
          "Instruction": "FCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DE D9",
          "Instruction": "FCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FCOS",
      "Description": "Cosine",
      "Url": "https://www.felixcloutier.com/x86/FCOS.html",
      "Table": [
        {
          "Opcode": "D9 FF",
          "Instruction": "FCOS",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with its approximate cosine."
        }
      ]
    },
    {
      "Mnemonic": "FDECSTP",
      "Description": "Decrement Stack-Top Pointer",
      "Url": "https://www.felixcloutier.com/x86/FDECSTP.html",
      "Table": [
        {
          "Opcode": "D9 F6",
          "Instruction": "FDECSTP",
          "CompatLegMode": "Valid",
          "Description": "Decrement TOP field in FPU status word."
        }
      ]
    },
    {
      "Mnemonic": "FDIV",
      "Description": "Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html",
      "Table": [
        {
          "Opcode": "D8 /6",
          "Instruction": "FDIV m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /6",
          "Instruction": "FDIV m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 F0+i",
          "Instruction": "FDIV ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC F8+i",
          "Instruction": "FDIV ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE F8+i",
          "Instruction": "FDIVP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F9",
          "Instruction": "FDIVP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /6",
          "Instruction": "FIDIV m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /6",
          "Instruction": "FIDIV m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FDIVP",
      "Description": "Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html",
      "Table": [
        {
          "Opcode": "D8 /6",
          "Instruction": "FDIV m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /6",
          "Instruction": "FDIV m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 F0+i",
          "Instruction": "FDIV ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC F8+i",
          "Instruction": "FDIV ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE F8+i",
          "Instruction": "FDIVP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F9",
          "Instruction": "FDIVP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /6",
          "Instruction": "FIDIV m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /6",
          "Instruction": "FIDIV m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FDIVR",
      "Description": "Reverse Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html",
      "Table": [
        {
          "Opcode": "D8 /7",
          "Instruction": "FDIVR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m32fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /7",
          "Instruction": "FDIVR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m64fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 F8+i",
          "Instruction": "FDIVR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC F0+i",
          "Instruction": "FDIVR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE F0+i",
          "Instruction": "FDIVRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F1",
          "Instruction": "FDIVRP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /7",
          "Instruction": "FIDIVR m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide m32int by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /7",
          "Instruction": "FIDIVR m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide m16int by ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FDIVRP",
      "Description": "Reverse Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html",
      "Table": [
        {
          "Opcode": "D8 /7",
          "Instruction": "FDIVR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m32fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /7",
          "Instruction": "FDIVR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m64fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 F8+i",
          "Instruction": "FDIVR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC F0+i",
          "Instruction": "FDIVR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE F0+i",
          "Instruction": "FDIVRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F1",
          "Instruction": "FDIVRP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /7",
          "Instruction": "FIDIVR m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide m32int by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /7",
          "Instruction": "FIDIVR m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide m16int by ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FFREE",
      "Description": "Free Floating-Point Register",
      "Url": "https://www.felixcloutier.com/x86/FFREE.html",
      "Table": [
        {
          "Opcode": "DD C0+i",
          "Instruction": "FFREE ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Sets tag for ST(i) to empty."
        }
      ]
    },
    {
      "Mnemonic": "FIADD",
      "Description": "Add",
      "Url": "https://www.felixcloutier.com/x86/FADD:FADDP:FIADD.html",
      "Table": [
        {
          "Opcode": "D8 /0",
          "Instruction": "FADD m32fp",
          "CompatLegMode": "Valid",
          "Description": "Add m32fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /0",
          "Instruction": "FADD m64fp",
          "CompatLegMode": "Valid",
          "Description": "Add m64fp to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 C0+i",
          "Instruction": "FADD ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C0+i",
          "Instruction": "FADD ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(i) to ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C0+i",
          "Instruction": "FADDP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C1",
          "Instruction": "FADDP",
          "CompatLegMode": "Valid",
          "Description": "Add ST(0) to ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /0",
          "Instruction": "FIADD m32int",
          "CompatLegMode": "Valid",
          "Description": "Add m32int to ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /0",
          "Instruction": "FIADD m16int",
          "CompatLegMode": "Valid",
          "Description": "Add m16int to ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FICOM",
      "Description": "Compare Integer",
      "Url": "https://www.felixcloutier.com/x86/FICOM:FICOMP.html",
      "Table": [
        {
          "Opcode": "DE /2",
          "Instruction": "FICOM m16int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m16int."
        },
        {
          "Opcode": "DA /2",
          "Instruction": "FICOM m32int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32int."
        },
        {
          "Opcode": "DE /3",
          "Instruction": "FICOMP m16int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m16int and pop stack register."
        },
        {
          "Opcode": "DA /3",
          "Instruction": "FICOMP m32int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32int and pop stack register."
        }
      ]
    },
    {
      "Mnemonic": "FICOMP",
      "Description": "Compare Integer",
      "Url": "https://www.felixcloutier.com/x86/FICOM:FICOMP.html",
      "Table": [
        {
          "Opcode": "DE /2",
          "Instruction": "FICOM m16int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m16int."
        },
        {
          "Opcode": "DA /2",
          "Instruction": "FICOM m32int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32int."
        },
        {
          "Opcode": "DE /3",
          "Instruction": "FICOMP m16int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m16int and pop stack register."
        },
        {
          "Opcode": "DA /3",
          "Instruction": "FICOMP m32int",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with m32int and pop stack register."
        }
      ]
    },
    {
      "Mnemonic": "FIDIV",
      "Description": "Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIV:FDIVP:FIDIV.html",
      "Table": [
        {
          "Opcode": "D8 /6",
          "Instruction": "FDIV m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /6",
          "Instruction": "FDIV m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 F0+i",
          "Instruction": "FDIV ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC F8+i",
          "Instruction": "FDIV ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE F8+i",
          "Instruction": "FDIVP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F9",
          "Instruction": "FDIVP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /6",
          "Instruction": "FIDIV m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /6",
          "Instruction": "FIDIV m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FIDIVR",
      "Description": "Reverse Divide",
      "Url": "https://www.felixcloutier.com/x86/FDIVR:FDIVRP:FIDIVR.html",
      "Table": [
        {
          "Opcode": "D8 /7",
          "Instruction": "FDIVR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m32fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /7",
          "Instruction": "FDIVR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Divide m64fp by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 F8+i",
          "Instruction": "FDIVR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(i) by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC F0+i",
          "Instruction": "FDIVR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE F0+i",
          "Instruction": "FDIVRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(i), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE F1",
          "Instruction": "FDIVRP",
          "CompatLegMode": "Valid",
          "Description": "Divide ST(0) by ST(1), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /7",
          "Instruction": "FIDIVR m32int",
          "CompatLegMode": "Valid",
          "Description": "Divide m32int by ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /7",
          "Instruction": "FIDIVR m16int",
          "CompatLegMode": "Valid",
          "Description": "Divide m16int by ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FILD",
      "Description": "Load Integer",
      "Url": "https://www.felixcloutier.com/x86/FILD.html",
      "Table": [
        {
          "Opcode": "DF /0",
          "Instruction": "FILD m16int",
          "CompatLegMode": "Valid",
          "Description": "Push m16int onto the FPU register stack."
        },
        {
          "Opcode": "DB /0",
          "Instruction": "FILD m32int",
          "CompatLegMode": "Valid",
          "Description": "Push m32int onto the FPU register stack."
        },
        {
          "Opcode": "DF /5",
          "Instruction": "FILD m64int",
          "CompatLegMode": "Valid",
          "Description": "Push m64int onto the FPU register stack."
        }
      ]
    },
    {
      "Mnemonic": "FIMUL",
      "Description": "Multiply",
      "Url": "https://www.felixcloutier.com/x86/FMUL:FMULP:FIMUL.html",
      "Table": [
        {
          "Opcode": "D8 /1",
          "Instruction": "FMUL m32fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /1",
          "Instruction": "FMUL m64fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 C8+i",
          "Instruction": "FMUL ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C8+i",
          "Instruction": "FMUL ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C8+i",
          "Instruction": "FMULP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C9",
          "Instruction": "FMULP",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /1",
          "Instruction": "FIMUL m32int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /1",
          "Instruction": "FIMUL m16int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FINCSTP",
      "Description": "Increment Stack-Top Pointer",
      "Url": "https://www.felixcloutier.com/x86/FINCSTP.html",
      "Table": [
        {
          "Opcode": "D9 F7",
          "Instruction": "FINCSTP",
          "CompatLegMode": "Valid",
          "Description": "Increment the TOP field in the FPU status register."
        }
      ]
    },
    {
      "Mnemonic": "FINIT",
      "Description": "Initialize Floating-Point Unit",
      "Url": "https://www.felixcloutier.com/x86/FINIT:FNINIT.html",
      "Table": [
        {
          "Opcode": "9B DB E3",
          "Instruction": "FINIT",
          "CompatLegMode": "Valid",
          "Description": "Initialize FPU after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DB E3",
          "Instruction": "FNINIT*",
          "CompatLegMode": "Valid",
          "Description": "Initialize FPU without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FIST",
      "Description": "Store Integer",
      "Url": "https://www.felixcloutier.com/x86/FIST:FISTP.html",
      "Table": [
        {
          "Opcode": "DF /2",
          "Instruction": "FIST m16int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m16int."
        },
        {
          "Opcode": "DB /2",
          "Instruction": "FIST m32int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m32int."
        },
        {
          "Opcode": "DF /3",
          "Instruction": "FISTP m16int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m16int and pop register stack."
        },
        {
          "Opcode": "DB /3",
          "Instruction": "FISTP m32int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m32int and pop register stack."
        },
        {
          "Opcode": "DF /7",
          "Instruction": "FISTP m64int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m64int and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FISTP",
      "Description": "Store Integer",
      "Url": "https://www.felixcloutier.com/x86/FIST:FISTP.html",
      "Table": [
        {
          "Opcode": "DF /2",
          "Instruction": "FIST m16int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m16int."
        },
        {
          "Opcode": "DB /2",
          "Instruction": "FIST m32int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m32int."
        },
        {
          "Opcode": "DF /3",
          "Instruction": "FISTP m16int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m16int and pop register stack."
        },
        {
          "Opcode": "DB /3",
          "Instruction": "FISTP m32int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m32int and pop register stack."
        },
        {
          "Opcode": "DF /7",
          "Instruction": "FISTP m64int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m64int and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FISTTP",
      "Description": "Store Integer with Truncation",
      "Url": "https://www.felixcloutier.com/x86/FISTTP.html",
      "Table": [
        {
          "Opcode": "DF /1",
          "Instruction": "FISTTP m16int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m16int with truncation."
        },
        {
          "Opcode": "DB /1",
          "Instruction": "FISTTP m32int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m32int with truncation."
        },
        {
          "Opcode": "DD /1",
          "Instruction": "FISTTP m64int",
          "CompatLegMode": "Valid",
          "Description": "Store ST(0) in m64int with truncation."
        }
      ]
    },
    {
      "Mnemonic": "FISUB",
      "Description": "Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUB:FSUBP:FISUB.html",
      "Table": [
        {
          "Opcode": "D8 /4",
          "Instruction": "FSUB m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /4",
          "Instruction": "FSUB m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m64fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 E0+i",
          "Instruction": "FSUB ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC E8+i",
          "Instruction": "FSUB ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE E8+i",
          "Instruction": "FSUBP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E9",
          "Instruction": "FSUBP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /4",
          "Instruction": "FISUB m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32int from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /4",
          "Instruction": "FISUB m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m16int from ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FISUBR",
      "Description": "Reverse Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html",
      "Table": [
        {
          "Opcode": "D8 /5",
          "Instruction": "FSUBR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /5",
          "Instruction": "FSUBR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 E8+i",
          "Instruction": "FSUBR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC E0+i",
          "Instruction": "FSUBR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE E0+i",
          "Instruction": "FSUBRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E1",
          "Instruction": "FSUBRP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /5",
          "Instruction": "FISUBR m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /5",
          "Instruction": "FISUBR m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FLD",
      "Description": "Load Floating Point Value",
      "Url": "https://www.felixcloutier.com/x86/FLD.html",
      "Table": [
        {
          "Opcode": "D9 /0",
          "Instruction": "FLD m32fp",
          "CompatLegMode": "Valid",
          "Description": "Push m32fp onto the FPU register stack."
        },
        {
          "Opcode": "DD /0",
          "Instruction": "FLD m64fp",
          "CompatLegMode": "Valid",
          "Description": "Push m64fp onto the FPU register stack."
        },
        {
          "Opcode": "DB /5",
          "Instruction": "FLD m80fp",
          "CompatLegMode": "Valid",
          "Description": "Push m80fp onto the FPU register stack."
        },
        {
          "Opcode": "D9 C0+i",
          "Instruction": "FLD ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Push ST(i) onto the FPU register stack."
        }
      ]
    },
    {
      "Mnemonic": "FLD1",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDCW",
      "Description": "Load x87 FPU Control Word",
      "Url": "https://www.felixcloutier.com/x86/FLDCW.html",
      "Table": [
        {
          "Opcode": "D9 /5",
          "Instruction": "FLDCW m2byte",
          "CompatLegMode": "Valid",
          "Description": "Load FPU control word from m2byte."
        }
      ]
    },
    {
      "Mnemonic": "FLDENV",
      "Description": "Load x87 FPU Environment",
      "Url": "https://www.felixcloutier.com/x86/FLDENV.html",
      "Table": [
        {
          "Opcode": "D9 /4",
          "Instruction": "FLDENV m14/28byte",
          "CompatLegMode": "Valid",
          "Description": "Load FPU environment from m14byte or m28byte."
        }
      ]
    },
    {
      "Mnemonic": "FLDL2E",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDL2T",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDLG2",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDLN2",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDPI",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FLDZ",
      "Description": "Load Constant",
      "Url": "https://www.felixcloutier.com/x86/FLD1:FLDL2T:FLDL2E:FLDPI:FLDLG2:FLDLN2:FLDZ.html"
    },
    {
      "Mnemonic": "FMUL",
      "Description": "Multiply",
      "Url": "https://www.felixcloutier.com/x86/FMUL:FMULP:FIMUL.html",
      "Table": [
        {
          "Opcode": "D8 /1",
          "Instruction": "FMUL m32fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /1",
          "Instruction": "FMUL m64fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 C8+i",
          "Instruction": "FMUL ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C8+i",
          "Instruction": "FMUL ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C8+i",
          "Instruction": "FMULP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C9",
          "Instruction": "FMULP",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /1",
          "Instruction": "FIMUL m32int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /1",
          "Instruction": "FIMUL m16int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FMULP",
      "Description": "Multiply",
      "Url": "https://www.felixcloutier.com/x86/FMUL:FMULP:FIMUL.html",
      "Table": [
        {
          "Opcode": "D8 /1",
          "Instruction": "FMUL m32fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /1",
          "Instruction": "FMUL m64fp",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 C8+i",
          "Instruction": "FMUL ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC C8+i",
          "Instruction": "FMUL ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE C8+i",
          "Instruction": "FMULP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(i) by ST(0), store result in ST(i), and pop the register stack."
        },
        {
          "Opcode": "DE C9",
          "Instruction": "FMULP",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(1) by ST(0), store result in ST(1), and pop the register stack."
        },
        {
          "Opcode": "DA /1",
          "Instruction": "FIMUL m32int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /1",
          "Instruction": "FIMUL m16int",
          "CompatLegMode": "Valid",
          "Description": "Multiply ST(0) by m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FNCLEX",
      "Description": "Clear Exceptions",
      "Url": "https://www.felixcloutier.com/x86/FCLEX:FNCLEX.html"
    },
    {
      "Mnemonic": "FNINIT",
      "Description": "Initialize Floating-Point Unit",
      "Url": "https://www.felixcloutier.com/x86/FINIT:FNINIT.html",
      "Table": [
        {
          "Opcode": "9B DB E3",
          "Instruction": "FINIT",
          "CompatLegMode": "Valid",
          "Description": "Initialize FPU after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DB E3",
          "Instruction": "FNINIT*",
          "CompatLegMode": "Valid",
          "Description": "Initialize FPU without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FNOP",
      "Description": "No Operation",
      "Url": "https://www.felixcloutier.com/x86/FNOP.html",
      "Table": [
        {
          "Opcode": "D9 D0",
          "Instruction": "FNOP",
          "CompatLegMode": "Valid",
          "Description": "No operation is performed."
        }
      ]
    },
    {
      "Mnemonic": "FNSAVE",
      "Description": "Store x87 FPU State",
      "Url": "https://www.felixcloutier.com/x86/FSAVE:FNSAVE.html",
      "Table": [
        {
          "Opcode": "9B DD /6",
          "Instruction": "FSAVE m94/108byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
        },
        {
          "Opcode": "DD /6",
          "Instruction": "FNSAVE* m94/108byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
        }
      ]
    },
    {
      "Mnemonic": "FNSTCW",
      "Description": "Store x87 FPU Control Word",
      "Url": "https://www.felixcloutier.com/x86/FSTCW:FNSTCW.html",
      "Table": [
        {
          "Opcode": "9B D9 /7",
          "Instruction": "FSTCW m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "D9 /7",
          "Instruction": "FNSTCW* m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FNSTENV",
      "Description": "Store x87 FPU Environment",
      "Url": "https://www.felixcloutier.com/x86/FSTENV:FNSTENV.html",
      "Table": [
        {
          "Opcode": "9B D9 /6",
          "Instruction": "FSTENV m14/28byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
        },
        {
          "Opcode": "D9 /6",
          "Instruction": "FNSTENV* m14/28byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FNSTSW",
      "Description": "Store x87 FPU Status Word",
      "Url": "https://www.felixcloutier.com/x86/FSTSW:FNSTSW.html",
      "Table": [
        {
          "Opcode": "9B DD /7",
          "Instruction": "FSTSW m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "9B DF E0",
          "Instruction": "FSTSW AX",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DD /7",
          "Instruction": "FNSTSW* m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DF E0",
          "Instruction": "FNSTSW* AX",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FPATAN",
      "Description": "Partial Arctangent",
      "Url": "https://www.felixcloutier.com/x86/FPATAN.html"
    },
    {
      "Mnemonic": "FPREM",
      "Description": "Partial Remainder",
      "Url": "https://www.felixcloutier.com/x86/FPREM.html",
      "Table": [
        {
          "Opcode": "D9 F8",
          "Instruction": "FPREM",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with the remainder obtained from dividing ST(0) by ST(1)."
        }
      ]
    },
    {
      "Mnemonic": "FPREM1",
      "Description": "Partial Remainder",
      "Url": "https://www.felixcloutier.com/x86/FPREM1.html",
      "Table": [
        {
          "Opcode": "D9 F5",
          "Instruction": "FPREM1",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with the IEEE remainder obtained from dividing ST(0) by ST(1)."
        }
      ]
    },
    {
      "Mnemonic": "FPTAN",
      "Description": "Partial Tangent",
      "Url": "https://www.felixcloutier.com/x86/FPTAN.html",
      "Table": [
        {
          "Opcode": "D9 F2",
          "Instruction": "FPTAN",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with its approximate tangent and push 1 onto the FPU stack."
        }
      ]
    },
    {
      "Mnemonic": "FRNDINT",
      "Description": "Round to Integer",
      "Url": "https://www.felixcloutier.com/x86/FRNDINT.html",
      "Table": [
        {
          "Opcode": "D9 FC",
          "Instruction": "FRNDINT",
          "CompatLegMode": "Valid",
          "Description": "Round ST(0) to an integer."
        }
      ]
    },
    {
      "Mnemonic": "FRSTOR",
      "Description": "Restore x87 FPU State",
      "Url": "https://www.felixcloutier.com/x86/FRSTOR.html",
      "Table": [
        {
          "Opcode": "DD /4",
          "Instruction": "FRSTOR m94/108byte",
          "CompatLegMode": "Valid",
          "Description": "Load FPU state from m94byte or m108byte."
        }
      ]
    },
    {
      "Mnemonic": "FSAVE",
      "Description": "Store x87 FPU State",
      "Url": "https://www.felixcloutier.com/x86/FSAVE:FNSAVE.html",
      "Table": [
        {
          "Opcode": "9B DD /6",
          "Instruction": "FSAVE m94/108byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU state to m94byte or m108byte after checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
        },
        {
          "Opcode": "DD /6",
          "Instruction": "FNSAVE* m94/108byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m94byte or m108byte without checking for pending unmasked floating-point exceptions. Then re-initialize the FPU."
        }
      ]
    },
    {
      "Mnemonic": "FSCALE",
      "Description": "Scale",
      "Url": "https://www.felixcloutier.com/x86/FSCALE.html",
      "Table": [
        {
          "Opcode": "D9 FD",
          "Instruction": "FSCALE",
          "CompatLegMode": "Valid",
          "Description": "Scale ST(0) by ST(1)."
        }
      ]
    },
    {
      "Mnemonic": "FSIN",
      "Description": "Sine",
      "Url": "https://www.felixcloutier.com/x86/FSIN.html",
      "Table": [
        {
          "Opcode": "D9 FE",
          "Instruction": "FSIN",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(0) with the approximate of its sine."
        }
      ]
    },
    {
      "Mnemonic": "FSINCOS",
      "Description": "Sine and Cosine",
      "Url": "https://www.felixcloutier.com/x86/FSINCOS.html",
      "Table": [
        {
          "Opcode": "D9 FB",
          "Instruction": "FSINCOS",
          "CompatLegMode": "Valid",
          "Description": "Compute the sine and cosine of ST(0); replace ST(0) with the approximate sine, and push the approximate cosine onto the register stack."
        }
      ]
    },
    {
      "Mnemonic": "FSQRT",
      "Description": "Square Root",
      "Url": "https://www.felixcloutier.com/x86/FSQRT.html",
      "Table": [
        {
          "Opcode": "D9 FA",
          "Instruction": "FSQRT",
          "CompatLegMode": "Valid",
          "Description": "Computes square root of ST(0) and stores the result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FST",
      "Description": "Store Floating Point Value",
      "Url": "https://www.felixcloutier.com/x86/FST:FSTP.html",
      "Table": [
        {
          "Opcode": "D9 /2",
          "Instruction": "FST m32fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m32fp."
        },
        {
          "Opcode": "DD /2",
          "Instruction": "FST m64fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m64fp."
        },
        {
          "Opcode": "DD D0+i",
          "Instruction": "FST ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to ST(i)."
        },
        {
          "Opcode": "D9 /3",
          "Instruction": "FSTP m32fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m32fp and pop register stack."
        },
        {
          "Opcode": "DD /3",
          "Instruction": "FSTP m64fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m64fp and pop register stack."
        },
        {
          "Opcode": "DB /7",
          "Instruction": "FSTP m80fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m80fp and pop register stack."
        },
        {
          "Opcode": "DD D8+i",
          "Instruction": "FSTP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to ST(i) and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FSTCW",
      "Description": "Store x87 FPU Control Word",
      "Url": "https://www.felixcloutier.com/x86/FSTCW:FNSTCW.html",
      "Table": [
        {
          "Opcode": "9B D9 /7",
          "Instruction": "FSTCW m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU control word to m2byte after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "D9 /7",
          "Instruction": "FNSTCW* m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU control word to m2byte without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FSTENV",
      "Description": "Store x87 FPU Environment",
      "Url": "https://www.felixcloutier.com/x86/FSTENV:FNSTENV.html",
      "Table": [
        {
          "Opcode": "9B D9 /6",
          "Instruction": "FSTENV m14/28byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m14byte or m28byte after checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
        },
        {
          "Opcode": "D9 /6",
          "Instruction": "FNSTENV* m14/28byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU environment to m14byte or m28byte without checking for pending unmasked floating-point exceptions. Then mask all floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FSTP",
      "Description": "Store Floating Point Value",
      "Url": "https://www.felixcloutier.com/x86/FST:FSTP.html",
      "Table": [
        {
          "Opcode": "D9 /2",
          "Instruction": "FST m32fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m32fp."
        },
        {
          "Opcode": "DD /2",
          "Instruction": "FST m64fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m64fp."
        },
        {
          "Opcode": "DD D0+i",
          "Instruction": "FST ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to ST(i)."
        },
        {
          "Opcode": "D9 /3",
          "Instruction": "FSTP m32fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m32fp and pop register stack."
        },
        {
          "Opcode": "DD /3",
          "Instruction": "FSTP m64fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m64fp and pop register stack."
        },
        {
          "Opcode": "DB /7",
          "Instruction": "FSTP m80fp",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to m80fp and pop register stack."
        },
        {
          "Opcode": "DD D8+i",
          "Instruction": "FSTP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Copy ST(0) to ST(i) and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FSTSW",
      "Description": "Store x87 FPU Status Word",
      "Url": "https://www.felixcloutier.com/x86/FSTSW:FNSTSW.html",
      "Table": [
        {
          "Opcode": "9B DD /7",
          "Instruction": "FSTSW m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word at m2byte after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "9B DF E0",
          "Instruction": "FSTSW AX",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word in AX register after checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DD /7",
          "Instruction": "FNSTSW* m2byte",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word at m2byte without checking for pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "DF E0",
          "Instruction": "FNSTSW* AX",
          "CompatLegMode": "Valid",
          "Description": "Store FPU status word in AX register without checking for pending unmasked floating-point exceptions."
        }
      ]
    },
    {
      "Mnemonic": "FSUB",
      "Description": "Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUB:FSUBP:FISUB.html",
      "Table": [
        {
          "Opcode": "D8 /4",
          "Instruction": "FSUB m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /4",
          "Instruction": "FSUB m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m64fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 E0+i",
          "Instruction": "FSUB ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC E8+i",
          "Instruction": "FSUB ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE E8+i",
          "Instruction": "FSUBP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E9",
          "Instruction": "FSUBP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /4",
          "Instruction": "FISUB m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32int from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /4",
          "Instruction": "FISUB m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m16int from ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FSUBP",
      "Description": "Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUB:FSUBP:FISUB.html",
      "Table": [
        {
          "Opcode": "D8 /4",
          "Instruction": "FSUB m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC /4",
          "Instruction": "FSUB m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract m64fp from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "D8 E0+i",
          "Instruction": "FSUB ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DC E8+i",
          "Instruction": "FSUB ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(i)."
        },
        {
          "Opcode": "DE E8+i",
          "Instruction": "FSUBP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E9",
          "Instruction": "FSUBP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(1), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /4",
          "Instruction": "FISUB m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m32int from ST(0) and store result in ST(0)."
        },
        {
          "Opcode": "DE /4",
          "Instruction": "FISUB m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract m16int from ST(0) and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FSUBR",
      "Description": "Reverse Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html",
      "Table": [
        {
          "Opcode": "D8 /5",
          "Instruction": "FSUBR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /5",
          "Instruction": "FSUBR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 E8+i",
          "Instruction": "FSUBR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC E0+i",
          "Instruction": "FSUBR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE E0+i",
          "Instruction": "FSUBRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E1",
          "Instruction": "FSUBRP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /5",
          "Instruction": "FISUBR m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /5",
          "Instruction": "FISUBR m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FSUBRP",
      "Description": "Reverse Subtract",
      "Url": "https://www.felixcloutier.com/x86/FSUBR:FSUBRP:FISUBR.html",
      "Table": [
        {
          "Opcode": "D8 /5",
          "Instruction": "FSUBR m32fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32fp and store result in ST(0)."
        },
        {
          "Opcode": "DC /5",
          "Instruction": "FSUBR m64fp",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m64fp and store result in ST(0)."
        },
        {
          "Opcode": "D8 E8+i",
          "Instruction": "FSUBR ST(0), ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from ST(i) and store result in ST(0)."
        },
        {
          "Opcode": "DC E0+i",
          "Instruction": "FSUBR ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0) and store result in ST(i)."
        },
        {
          "Opcode": "DE E0+i",
          "Instruction": "FSUBRP ST(i), ST(0)",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(i) from ST(0), store result in ST(i), and pop register stack."
        },
        {
          "Opcode": "DE E1",
          "Instruction": "FSUBRP",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(1) from ST(0), store result in ST(1), and pop register stack."
        },
        {
          "Opcode": "DA /5",
          "Instruction": "FISUBR m32int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m32int and store result in ST(0)."
        },
        {
          "Opcode": "DE /5",
          "Instruction": "FISUBR m16int",
          "CompatLegMode": "Valid",
          "Description": "Subtract ST(0) from m16int and store result in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FTST",
      "Description": "TEST",
      "Url": "https://www.felixcloutier.com/x86/FTST.html",
      "Table": [
        {
          "Opcode": "D9 E4",
          "Instruction": "FTST",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with 0.0."
        }
      ]
    },
    {
      "Mnemonic": "FUCOM",
      "Description": "Unordered Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html",
      "Table": [
        {
          "Opcode": "DD E0+i",
          "Instruction": "FUCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "DD E1",
          "Instruction": "FUCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "DD E8+i",
          "Instruction": "FUCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "DD E9",
          "Instruction": "FUCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DA E9",
          "Instruction": "FUCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FUCOMI",
      "Description": "Compare Floating Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html",
      "Table": [
        {
          "Opcode": "DB F0+i",
          "Instruction": "FCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and set status flags accordingly."
        },
        {
          "Opcode": "DF F0+i",
          "Instruction": "FCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
        },
        {
          "Opcode": "DB E8+i",
          "Instruction": "FUCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
        },
        {
          "Opcode": "DF E8+i",
          "Instruction": "FUCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FUCOMIP",
      "Description": "Compare Floating Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/FCOMI:FCOMIP:FUCOMI:FUCOMIP.html",
      "Table": [
        {
          "Opcode": "DB F0+i",
          "Instruction": "FCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and set status flags accordingly."
        },
        {
          "Opcode": "DF F0+i",
          "Instruction": "FCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), set status flags accordingly, and pop register stack."
        },
        {
          "Opcode": "DB E8+i",
          "Instruction": "FUCOMI ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, and set status flags accordingly."
        },
        {
          "Opcode": "DF E8+i",
          "Instruction": "FUCOMIP ST, ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i), check for ordered values, set status flags accordingly, and pop register stack."
        }
      ]
    },
    {
      "Mnemonic": "FUCOMP",
      "Description": "Unordered Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html",
      "Table": [
        {
          "Opcode": "DD E0+i",
          "Instruction": "FUCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "DD E1",
          "Instruction": "FUCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "DD E8+i",
          "Instruction": "FUCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "DD E9",
          "Instruction": "FUCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DA E9",
          "Instruction": "FUCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FUCOMPP",
      "Description": "Unordered Compare Floating Point Values",
      "Url": "https://www.felixcloutier.com/x86/FUCOM:FUCOMP:FUCOMPP.html",
      "Table": [
        {
          "Opcode": "DD E0+i",
          "Instruction": "FUCOM ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i)."
        },
        {
          "Opcode": "DD E1",
          "Instruction": "FUCOM",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1)."
        },
        {
          "Opcode": "DD E8+i",
          "Instruction": "FUCOMP ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(i) and pop register stack."
        },
        {
          "Opcode": "DD E9",
          "Instruction": "FUCOMP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack."
        },
        {
          "Opcode": "DA E9",
          "Instruction": "FUCOMPP",
          "CompatLegMode": "Valid",
          "Description": "Compare ST(0) with ST(1) and pop register stack twice."
        }
      ]
    },
    {
      "Mnemonic": "FWAIT",
      "Description": "Wait",
      "Url": "https://www.felixcloutier.com/x86/WAIT:FWAIT.html",
      "Table": [
        {
          "Opcode": "9B",
          "Instruction": "WAIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Check pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "9B",
          "Instruction": "FWAIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Check pending unmasked floating-point exceptions."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "FXAM",
      "Description": "Examine Floating-Point",
      "Url": "https://www.felixcloutier.com/x86/FXAM.html",
      "Table": [
        {
          "Opcode": "D9 E5",
          "Instruction": "FXAM",
          "CompatLegMode": "Valid",
          "Description": "Classify value or number in ST(0)."
        }
      ]
    },
    {
      "Mnemonic": "FXCH",
      "Description": "Exchange Register Contents",
      "Url": "https://www.felixcloutier.com/x86/FXCH.html",
      "Table": [
        {
          "Opcode": "D9 C8+i",
          "Instruction": "FXCH ST(i)",
          "CompatLegMode": "Valid",
          "Description": "Exchange the contents of ST(0) and ST(i)."
        },
        {
          "Opcode": "D9 C9",
          "Instruction": "FXCH",
          "CompatLegMode": "Valid",
          "Description": "Exchange the contents of ST(0) and ST(1)."
        }
      ]
    },
    {
      "Mnemonic": "FXRSTOR",
      "Description": "Restore x87 FPU, MMX, XMM, and MXCSR State",
      "Url": "https://www.felixcloutier.com/x86/FXRSTOR.html",
      "Table": [
        {
          "Opcode": "NP 0F AE /1",
          "Instruction": "FXRSTOR m512byte",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
        },
        {
          "Opcode": "NP REX.W + 0F AE /1",
          "Instruction": "FXRSTOR64 m512byte",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Restore the x87 FPU, MMX, XMM, and MXCSR register state from m512byte."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "FXSAVE",
      "Description": "Save x87 FPU, MMX Technology, and SSE State",
      "Url": "https://www.felixcloutier.com/x86/FXSAVE.html",
      "Table": [
        {
          "Opcode": "NP 0F AE /0",
          "Instruction": "FXSAVE m512byte",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
        },
        {
          "Opcode": "NP REX.W + 0F AE /0",
          "Instruction": "FXSAVE64 m512byte",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Save the x87 FPU, MMX, XMM, and MXCSR register state to m512byte."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "FXTRACT",
      "Description": "Extract Exponent and Significand",
      "Url": "https://www.felixcloutier.com/x86/FXTRACT.html",
      "Table": [
        {
          "Opcode": "D9 F4",
          "Instruction": "FXTRACT",
          "CompatLegMode": "Valid",
          "Description": "Separate value in ST(0) into exponent and significand, store exponent in ST(0), and push the significand onto the register stack."
        }
      ]
    },
    {
      "Mnemonic": "FYL2X",
      "Description": "Compute y ∗ log2x",
      "Url": "https://www.felixcloutier.com/x86/FYL2X.html",
      "Table": [
        {
          "Opcode": "D9 F1",
          "Instruction": "FYL2X",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the register stack."
        }
      ]
    },
    {
      "Mnemonic": "FYL2XP1",
      "Description": "Compute y ∗ log2(x +1)",
      "Url": "https://www.felixcloutier.com/x86/FYL2XP1.html",
      "Table": [
        {
          "Opcode": "D9 F9",
          "Instruction": "FYL2XP1",
          "CompatLegMode": "Valid",
          "Description": "Replace ST(1) with ST(1) ∗ log2(ST(0) + 1.0) and pop the register stack."
        }
      ]
    },
    {
      "Mnemonic": "HADDPD",
      "Description": "Packed Double-FP Horizontal Add",
      "Url": "https://www.felixcloutier.com/x86/HADDPD.html",
      "Table": [
        {
          "Opcode": "66 0F 7C /r",
          "Instruction": "HADDPD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Horizontal add packed double-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 7C /r",
          "Instruction": "VHADDPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal add packed double-precision floating-point values from xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 7C /r",
          "Instruction": "VHADDPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal add packed double-precision floating-point values from ymm2 and ymm3/mem."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "HADDPS",
      "Description": "Packed Single-FP Horizontal Add",
      "Url": "https://www.felixcloutier.com/x86/HADDPS.html",
      "Table": [
        {
          "Opcode": "F2 0F 7C /r",
          "Instruction": "HADDPS xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Horizontal add packed single-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.F2.0F.WIG 7C /r",
          "Instruction": "VHADDPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal add packed single-precision floating-point values from xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.F2.0F.WIG 7C /r",
          "Instruction": "VHADDPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal add packed single-precision floating-point values from ymm2 and ymm3/mem."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "HLT",
      "Description": "Halt",
      "Url": "https://www.felixcloutier.com/x86/HLT.html",
      "Table": [
        {
          "Opcode": "F4",
          "Instruction": "HLT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Halt"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "HSUBPD",
      "Description": "Packed Double-FP Horizontal Subtract",
      "Url": "https://www.felixcloutier.com/x86/HSUBPD.html",
      "Table": [
        {
          "Opcode": "66 0F 7D /r",
          "Instruction": "HSUBPD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Horizontal subtract packed double-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 7D /r",
          "Instruction": "VHSUBPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal subtract packed double-precision floating-point values from xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 7D /r",
          "Instruction": "VHSUBPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal subtract packed double-precision floating-point values from ymm2 and ymm3/mem."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "HSUBPS",
      "Description": "Packed Single-FP Horizontal Subtract",
      "Url": "https://www.felixcloutier.com/x86/HSUBPS.html",
      "Table": [
        {
          "Opcode": "F2 0F 7D /r",
          "Instruction": "HSUBPS xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Horizontal subtract packed single-precision floating-point values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.F2.0F.WIG 7D /r",
          "Instruction": "VHSUBPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal subtract packed single-precision floating-point values from xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.F2.0F.WIG 7D /r",
          "Instruction": "VHSUBPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Horizontal subtract packed single-precision floating-point values from ymm2 and ymm3/mem."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "IDIV",
      "Description": "Signed Divide",
      "Url": "https://www.felixcloutier.com/x86/IDIV.html",
      "Table": [
        {
          "Opcode": "F6 /7",
          "Instruction": "IDIV r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Signed divide AX by r/m8, with result stored in: AL ← Quotient, AH ← Remainder."
        },
        {
          "Opcode": "REX + F6 /7",
          "Instruction": "IDIV r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Signed divide AX by r/m8, with result stored in AL ← Quotient, AH ← Remainder."
        },
        {
          "Opcode": "F7 /7",
          "Instruction": "IDIV r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Signed divide DX:AX by r/m16, with result stored in AX ← Quotient, DX ← Remainder."
        },
        {
          "Opcode": "F7 /7",
          "Instruction": "IDIV r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Signed divide EDX:EAX by r/m32, with result stored in EAX ← Quotient, EDX ← Remainder."
        },
        {
          "Opcode": "REX.W + F7 /7",
          "Instruction": "IDIV r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Signed divide RDX:RAX by r/m64, with result stored in RAX ← Quotient, RDX ← Remainder."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "IMUL",
      "Description": "Signed Multiply",
      "Url": "https://www.felixcloutier.com/x86/IMUL.html",
      "Table": [
        {
          "Opcode": "F6 /5",
          "Instruction": "IMUL r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "AX← AL ∗ r/m byte."
        },
        {
          "Opcode": "F7 /5",
          "Instruction": "IMUL r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "DX:AX ← AX ∗ r/m word."
        },
        {
          "Opcode": "F7 /5",
          "Instruction": "IMUL r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "EDX:EAX ← EAX ∗ r/m32."
        },
        {
          "Opcode": "REX.W + F7 /5",
          "Instruction": "IMUL r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "RDX:RAX ← RAX ∗ r/m64."
        },
        {
          "Opcode": "0F AF /r",
          "Instruction": "IMUL r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "word register ← word register ∗ r/m16."
        },
        {
          "Opcode": "0F AF /r",
          "Instruction": "IMUL r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "doubleword register ← doubleword register ∗ r/m32."
        },
        {
          "Opcode": "REX.W + 0F AF /r",
          "Instruction": "IMUL r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Quadword register ← Quadword register ∗ r/m64."
        },
        {
          "Opcode": "6B /r ib",
          "Instruction": "IMUL r16, r/m16, imm8",
          "OperandEncoding": "RMI",
          "CompatLegMode": "Valid",
          "Description": "word register ← r/m16 ∗ sign-extended immediate byte."
        },
        {
          "Opcode": "6B /r ib",
          "Instruction": "IMUL r32, r/m32, imm8",
          "OperandEncoding": "RMI",
          "CompatLegMode": "Valid",
          "Description": "doubleword register ← r/m32 ∗ sign-extended immediate byte."
        },
        {
          "Opcode": "REX.W + 6B /r ib",
          "Instruction": "IMUL r64, r/m64, imm8",
          "OperandEncoding": "RMI",
          "CompatLegMode": "N.E.",
          "Description": "Quadword register ← r/m64 ∗ sign-extended immediate byte."
        },
        {
          "Opcode": "69 /r iw",
          "Instruction": "IMUL r16, r/m16, imm16",
          "OperandEncoding": "RMI",
          "CompatLegMode": "Valid",
          "Description": "word register ← r/m16 ∗ immediate word."
        },
        {
          "Opcode": "69 /r id",
          "Instruction": "IMUL r32, r/m32, imm32",
          "OperandEncoding": "RMI",
          "CompatLegMode": "Valid",
          "Description": "doubleword register ← r/m32 ∗ immediate doubleword."
        },
        {
          "Opcode": "REX.W + 69 /r id",
          "Instruction": "IMUL r64, r/m64, imm32",
          "OperandEncoding": "RMI",
          "CompatLegMode": "N.E.",
          "Description": "Quadword register ← r/m64 ∗ immediate doubleword."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8/16/32"
          ]
        }
      ]
    },
    {
      "Mnemonic": "IN",
      "UniqueName": "@in",
      "Description": "Input from Port",
      "Url": "https://www.felixcloutier.com/x86/IN.html",
      "Table": [
        {
          "Opcode": "E4 ib",
          "Instruction": "IN AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Input byte from imm8 I/O port address into AL."
        },
        {
          "Opcode": "E5 ib",
          "Instruction": "IN AX, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Input word from imm8 I/O port address into AX."
        },
        {
          "Opcode": "E5 ib",
          "Instruction": "IN EAX, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Input dword from imm8 I/O port address into EAX."
        },
        {
          "Opcode": "EC",
          "Instruction": "IN AL,DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port in DX into AL."
        },
        {
          "Opcode": "ED",
          "Instruction": "IN AX,DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port in DX into AX."
        },
        {
          "Opcode": "ED",
          "Instruction": "IN EAX,DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port in DX into EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        },
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INC",
      "Description": "Increment by 1",
      "Url": "https://www.felixcloutier.com/x86/INC.html",
      "Table": [
        {
          "Opcode": "FE /0",
          "Instruction": "INC r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Increment r/m byte by 1."
        },
        {
          "Opcode": "REX + FE /0",
          "Instruction": "INC r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Increment r/m byte by 1."
        },
        {
          "Opcode": "FF /0",
          "Instruction": "INC r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Increment r/m word by 1."
        },
        {
          "Opcode": "FF /0",
          "Instruction": "INC r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Increment r/m doubleword by 1."
        },
        {
          "Opcode": "REX.W + FF /0",
          "Instruction": "INC r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Increment r/m quadword by 1."
        },
        {
          "Opcode": "40+ rw**",
          "Instruction": "INC r16",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Increment word register by 1."
        },
        {
          "Opcode": "40+ rd",
          "Instruction": "INC r32",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Increment doubleword register by 1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        },
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INS",
      "Description": "Input from Port to String",
      "Url": "https://www.felixcloutier.com/x86/INS:INSB:INSW:INSD.html",
      "Table": [
        {
          "Opcode": "6C",
          "Instruction": "INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6C",
          "Instruction": "INSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INSB",
      "Description": "Input from Port to String",
      "Url": "https://www.felixcloutier.com/x86/INS:INSB:INSW:INSD.html",
      "Table": [
        {
          "Opcode": "6C",
          "Instruction": "INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6C",
          "Instruction": "INSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INSD",
      "Description": "Input from Port to String",
      "Url": "https://www.felixcloutier.com/x86/INS:INSB:INSW:INSD.html",
      "Table": [
        {
          "Opcode": "6C",
          "Instruction": "INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6C",
          "Instruction": "INSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INSERTPS",
      "Description": "Insert Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/INSERTPS.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 21 /r ib",
          "Instruction": "INSERTPS xmm1, xmm2/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Insert a single-precision floating-point value selected by imm8 from xmm2/m32 into xmm1 at the specified destination element specified by imm8 and zero out destination elements in xmm1 as indicated in imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 21 /r ib",
          "Instruction": "VINSERTPS xmm1, xmm2, xmm3/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 21 /r ib",
          "Instruction": "VINSERTPS xmm1, xmm2, xmm3/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Insert a single-precision floating-point value selected by imm8 from xmm3/m32 and merge with values in xmm2 at the specified destination element specified by imm8 and write out the result and zero out destination elements in xmm1 as indicated in imm8."
        }
      ]
    },
    {
      "Mnemonic": "INSW",
      "Description": "Input from Port to String",
      "Url": "https://www.felixcloutier.com/x86/INS:INSB:INSW:INSD.html",
      "Table": [
        {
          "Opcode": "6C",
          "Instruction": "INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.*"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6C",
          "Instruction": "INSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input byte from I/O port specified in DX into memory location specified with ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input word from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        },
        {
          "Opcode": "6D",
          "Instruction": "INSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input doubleword from I/O port specified in DX into memory location specified in ES:(E)DI or RDI.1"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INT_n",
      "Description": "Call to Interrupt Procedure",
      "Url": "https://www.felixcloutier.com/x86/INTn:INTO:INT3:INT1.html",
      "Table": [
        {
          "Opcode": "CC",
          "Instruction": "INT3",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate breakpoint trap."
        },
        {
          "Opcode": "CD ib",
          "Instruction": "INT imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Generate software interrupt with vector specified by immediate byte."
        },
        {
          "Opcode": "CE",
          "Instruction": "INTO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate overflow trap if overflow flag is 1."
        },
        {
          "Opcode": "F1",
          "Instruction": "INT1",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate debug trap."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INT1",
      "Description": "Call to Interrupt Procedure",
      "Url": "https://www.felixcloutier.com/x86/INTn:INTO:INT3:INT1.html",
      "Table": [
        {
          "Opcode": "CC",
          "Instruction": "INT3",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate breakpoint trap."
        },
        {
          "Opcode": "CD ib",
          "Instruction": "INT imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Generate software interrupt with vector specified by immediate byte."
        },
        {
          "Opcode": "CE",
          "Instruction": "INTO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate overflow trap if overflow flag is 1."
        },
        {
          "Opcode": "F1",
          "Instruction": "INT1",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate debug trap."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INT3",
      "Description": "Call to Interrupt Procedure",
      "Url": "https://www.felixcloutier.com/x86/INTn:INTO:INT3:INT1.html",
      "Table": [
        {
          "Opcode": "CC",
          "Instruction": "INT3",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate breakpoint trap."
        },
        {
          "Opcode": "CD ib",
          "Instruction": "INT imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Generate software interrupt with vector specified by immediate byte."
        },
        {
          "Opcode": "CE",
          "Instruction": "INTO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate overflow trap if overflow flag is 1."
        },
        {
          "Opcode": "F1",
          "Instruction": "INT1",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate debug trap."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INTO",
      "Description": "Call to Interrupt Procedure",
      "Url": "https://www.felixcloutier.com/x86/INTn:INTO:INT3:INT1.html",
      "Table": [
        {
          "Opcode": "CC",
          "Instruction": "INT3",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate breakpoint trap."
        },
        {
          "Opcode": "CD ib",
          "Instruction": "INT imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Generate software interrupt with vector specified by immediate byte."
        },
        {
          "Opcode": "CE",
          "Instruction": "INTO",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate overflow trap if overflow flag is 1."
        },
        {
          "Opcode": "F1",
          "Instruction": "INT1",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Generate debug trap."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INVD",
      "Description": "Invalidate Internal Caches",
      "Url": "https://www.felixcloutier.com/x86/INVD.html",
      "Table": [
        {
          "Opcode": "0F 08",
          "Instruction": "INVD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Flush internal caches; initiate flushing of external caches."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "INVLPG",
      "Description": "Invalidate TLB Entries",
      "Url": "https://www.felixcloutier.com/x86/INVLPG.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "INVPCID",
      "Description": "Invalidate Process-Context Identifier",
      "Url": "https://www.felixcloutier.com/x86/INVPCID.html",
      "Table": [
        {
          "Opcode": "66 0F 38 82 /r",
          "Instruction": "INVPCID r32, m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "INVPCID",
          "Description": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r32 and descriptor in m128."
        },
        {
          "Opcode": "66 0F 38 82 /r",
          "Instruction": "INVPCID r64, m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "INVPCID",
          "Description": "Invalidates entries in the TLBs and paging-structure caches based on invalidation type in r64 and descriptor in m128."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (R)",
            "ModRM:r/m (R)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "IRET",
      "Description": "Interrupt Return",
      "Url": "https://www.felixcloutier.com/x86/IRET:IRETD.html",
      "Table": [
        {
          "Opcode": "CF",
          "Instruction": "IRET",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Interrupt return (16-bit operand size)."
        },
        {
          "Opcode": "CF",
          "Instruction": "IRETD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Interrupt return (32-bit operand size)."
        },
        {
          "Opcode": "REX.W + CF",
          "Instruction": "IRETQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Interrupt return (64-bit operand size)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "IRETD",
      "Description": "Interrupt Return",
      "Url": "https://www.felixcloutier.com/x86/IRET:IRETD.html",
      "Table": [
        {
          "Opcode": "CF",
          "Instruction": "IRET",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Interrupt return (16-bit operand size)."
        },
        {
          "Opcode": "CF",
          "Instruction": "IRETD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Interrupt return (32-bit operand size)."
        },
        {
          "Opcode": "REX.W + CF",
          "Instruction": "IRETQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Interrupt return (64-bit operand size)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "JMP",
      "Description": "Jump",
      "Url": "https://www.felixcloutier.com/x86/JMP.html",
      "Table": [
        {
          "Opcode": "EB cb",
          "Instruction": "JMP rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short, RIP = RIP + 8-bit displacement sign extended to 64-bits"
        },
        {
          "Opcode": "E9 cw",
          "Instruction": "JMP rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near, relative, displacement relative to next instruction. Not supported in 64-bit mode."
        },
        {
          "Opcode": "E9 cd",
          "Instruction": "JMP rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near, relative, RIP = RIP + 32-bit displacement sign extended to 64-bits"
        },
        {
          "Opcode": "FF /4",
          "Instruction": "JMP r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Jump near, absolute indirect, address = zero-extended r/m16. Not supported in 64-bit mode."
        },
        {
          "Opcode": "FF /4",
          "Instruction": "JMP r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Jump near, absolute indirect, address given in r/m32. Not supported in 64-bit mode."
        },
        {
          "Opcode": "FF /4",
          "Instruction": "JMP r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Jump near, absolute indirect, RIP = 64-Bit offset from register or memory"
        },
        {
          "Opcode": "EA cd",
          "Instruction": "JMP ptr16:16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump far, absolute, address given in operand"
        },
        {
          "Opcode": "EA cp",
          "Instruction": "JMP ptr16:32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump far, absolute, address given in operand"
        },
        {
          "Opcode": "FF /5",
          "Instruction": "JMP m16:16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump far, absolute indirect, address given in m16:16"
        },
        {
          "Opcode": "FF /5",
          "Instruction": "JMP m16:32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump far, absolute indirect, address given in m16:32."
        },
        {
          "Opcode": "REX.W + FF /5",
          "Instruction": "JMP m16:64",
          "OperandEncoding": "D",
          "CompatLegMode": "N.E.",
          "Description": "Jump far, absolute indirect, address given in m16:64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "D",
          "Operands": [
            "Offset"
          ]
        },
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "Jcc",
      "Description": "Jump if Condition Is Met",
      "Url": "https://www.felixcloutier.com/x86/Jcc.html",
      "Table": [
        {
          "Opcode": "77 cb",
          "Instruction": "JA rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "73 cb",
          "Instruction": "JAE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if above or equal (CF=0)."
        },
        {
          "Opcode": "72 cb",
          "Instruction": "JB rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if below (CF=1)."
        },
        {
          "Opcode": "76 cb",
          "Instruction": "JBE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "72 cb",
          "Instruction": "JC rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if carry (CF=1)."
        },
        {
          "Opcode": "E3 cb",
          "Instruction": "JCXZ rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if CX register is 0."
        },
        {
          "Opcode": "E3 cb",
          "Instruction": "JECXZ rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if ECX register is 0."
        },
        {
          "Opcode": "E3 cb",
          "Instruction": "JRCXZ rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "N.E.",
          "Description": "Jump short if RCX register is 0."
        },
        {
          "Opcode": "74 cb",
          "Instruction": "JE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if equal (ZF=1)."
        },
        {
          "Opcode": "7F cb",
          "Instruction": "JG rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "7D cb",
          "Instruction": "JGE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if greater or equal (SF=OF)."
        },
        {
          "Opcode": "7C cb",
          "Instruction": "JL rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if less (SF≠ OF)."
        },
        {
          "Opcode": "7E cb",
          "Instruction": "JLE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "76 cb",
          "Instruction": "JNA rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "72 cb",
          "Instruction": "JNAE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not above or equal (CF=1)."
        },
        {
          "Opcode": "73 cb",
          "Instruction": "JNB rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not below (CF=0)."
        },
        {
          "Opcode": "77 cb",
          "Instruction": "JNBE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "73 cb",
          "Instruction": "JNC rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not carry (CF=0)."
        },
        {
          "Opcode": "75 cb",
          "Instruction": "JNE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not equal (ZF=0)."
        },
        {
          "Opcode": "7E cb",
          "Instruction": "JNG rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "7C cb",
          "Instruction": "JNGE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "7D cb",
          "Instruction": "JNL rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not less (SF=OF)."
        },
        {
          "Opcode": "7F cb",
          "Instruction": "JNLE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "71 cb",
          "Instruction": "JNO rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not overflow (OF=0)."
        },
        {
          "Opcode": "7B cb",
          "Instruction": "JNP rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not parity (PF=0)."
        },
        {
          "Opcode": "79 cb",
          "Instruction": "JNS rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not sign (SF=0)."
        },
        {
          "Opcode": "75 cb",
          "Instruction": "JNZ rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if not zero (ZF=0)."
        },
        {
          "Opcode": "70 cb",
          "Instruction": "JO rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if overflow (OF=1)."
        },
        {
          "Opcode": "7A cb",
          "Instruction": "JP rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if parity (PF=1)."
        },
        {
          "Opcode": "7A cb",
          "Instruction": "JPE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if parity even (PF=1)."
        },
        {
          "Opcode": "7B cb",
          "Instruction": "JPO rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if parity odd (PF=0)."
        },
        {
          "Opcode": "78 cb",
          "Instruction": "JS rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if sign (SF=1)."
        },
        {
          "Opcode": "74 cb",
          "Instruction": "JZ rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump short if zero (ZF = 1)."
        },
        {
          "Opcode": "0F 87 cw",
          "Instruction": "JA rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if above (CF=0 and ZF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 87 cd",
          "Instruction": "JA rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 83 cw",
          "Instruction": "JAE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if above or equal (CF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 83 cd",
          "Instruction": "JAE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if above or equal (CF=0)."
        },
        {
          "Opcode": "0F 82 cw",
          "Instruction": "JB rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if below (CF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 82 cd",
          "Instruction": "JB rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if below (CF=1)."
        },
        {
          "Opcode": "0F 86 cw",
          "Instruction": "JBE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if below or equal (CF=1 or ZF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 86 cd",
          "Instruction": "JBE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 82 cw",
          "Instruction": "JC rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if carry (CF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 82 cd",
          "Instruction": "JC rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if carry (CF=1)."
        },
        {
          "Opcode": "0F 84 cw",
          "Instruction": "JE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if equal (ZF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 84 cd",
          "Instruction": "JE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if equal (ZF=1)."
        },
        {
          "Opcode": "0F 84 cw",
          "Instruction": "JZ rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 84 cd",
          "Instruction": "JZ rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if 0 (ZF=1)."
        },
        {
          "Opcode": "0F 8F cw",
          "Instruction": "JG rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if greater (ZF=0 and SF=OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8F cd",
          "Instruction": "JG rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 8D cw",
          "Instruction": "JGE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if greater or equal (SF=OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8D cd",
          "Instruction": "JGE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if greater or equal (SF=OF)."
        },
        {
          "Opcode": "0F 8C cw",
          "Instruction": "JL rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if less (SF≠ OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8C cd",
          "Instruction": "JL rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if less (SF≠ OF)."
        },
        {
          "Opcode": "0F 8E cw",
          "Instruction": "JLE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if less or equal (ZF=1 or SF≠ OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8E cd",
          "Instruction": "JLE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 86 cw",
          "Instruction": "JNA rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not above (CF=1 or ZF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 86 cd",
          "Instruction": "JNA rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 82 cw",
          "Instruction": "JNAE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not above or equal (CF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 82 cd",
          "Instruction": "JNAE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not above or equal (CF=1)."
        },
        {
          "Opcode": "0F 83 cw",
          "Instruction": "JNB rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not below (CF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 83 cd",
          "Instruction": "JNB rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not below (CF=0)."
        },
        {
          "Opcode": "0F 87 cw",
          "Instruction": "JNBE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not below or equal (CF=0 and ZF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 87 cd",
          "Instruction": "JNBE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 83 cw",
          "Instruction": "JNC rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not carry (CF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 83 cd",
          "Instruction": "JNC rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not carry (CF=0)."
        },
        {
          "Opcode": "0F 85 cw",
          "Instruction": "JNE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not equal (ZF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 85 cd",
          "Instruction": "JNE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not equal (ZF=0)."
        },
        {
          "Opcode": "0F 8E cw",
          "Instruction": "JNG rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not greater (ZF=1 or SF≠ OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8E cd",
          "Instruction": "JNG rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 8C cw",
          "Instruction": "JNGE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not greater or equal (SF≠ OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8C cd",
          "Instruction": "JNGE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "0F 8D cw",
          "Instruction": "JNL rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not less (SF=OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8D cd",
          "Instruction": "JNL rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not less (SF=OF)."
        },
        {
          "Opcode": "0F 8F cw",
          "Instruction": "JNLE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not less or equal (ZF=0 and SF=OF). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8F cd",
          "Instruction": "JNLE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 81 cw",
          "Instruction": "JNO rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not overflow (OF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 81 cd",
          "Instruction": "JNO rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not overflow (OF=0)."
        },
        {
          "Opcode": "0F 8B cw",
          "Instruction": "JNP rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not parity (PF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8B cd",
          "Instruction": "JNP rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not parity (PF=0)."
        },
        {
          "Opcode": "0F 89 cw",
          "Instruction": "JNS rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not sign (SF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 89 cd",
          "Instruction": "JNS rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not sign (SF=0)."
        },
        {
          "Opcode": "0F 85 cw",
          "Instruction": "JNZ rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not zero (ZF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 85 cd",
          "Instruction": "JNZ rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if not zero (ZF=0)."
        },
        {
          "Opcode": "0F 80 cw",
          "Instruction": "JO rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if overflow (OF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 80 cd",
          "Instruction": "JO rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if overflow (OF=1)."
        },
        {
          "Opcode": "0F 8A cw",
          "Instruction": "JP rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity (PF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8A cd",
          "Instruction": "JP rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity (PF=1)."
        },
        {
          "Opcode": "0F 8A cw",
          "Instruction": "JPE rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity even (PF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8A cd",
          "Instruction": "JPE rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity even (PF=1)."
        },
        {
          "Opcode": "0F 8B cw",
          "Instruction": "JPO rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity odd (PF=0). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 8B cd",
          "Instruction": "JPO rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if parity odd (PF=0)."
        },
        {
          "Opcode": "0F 88 cw",
          "Instruction": "JS rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if sign (SF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 88 cd",
          "Instruction": "JS rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if sign (SF=1)."
        },
        {
          "Opcode": "0F 84 cw",
          "Instruction": "JZ rel16",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if 0 (ZF=1). Not supported in 64-bit mode."
        },
        {
          "Opcode": "0F 84 cd",
          "Instruction": "JZ rel32",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Jump near if 0 (ZF=1)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "D",
          "Operands": [
            "Offset"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KADDB",
      "Description": "ADD Two Masks",
      "Url": "https://www.felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 4A /r",
          "Instruction": "KADDB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Add 8 bits masks in k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KADDD",
      "Description": "ADD Two Masks",
      "Url": "https://www.felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 4A /r",
          "Instruction": "KADDD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add 32 bits masks in k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KADDQ",
      "Description": "ADD Two Masks",
      "Url": "https://www.felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 4A /r",
          "Instruction": "KADDQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add 64 bits masks in k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KADDW",
      "Description": "ADD Two Masks",
      "Url": "https://www.felixcloutier.com/x86/KADDW:KADDB:KADDQ:KADDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W0 4A /r",
          "Instruction": "KADDW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Add 16 bits masks in k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDB",
      "Description": "Bitwise Logical AND Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 41 /r",
          "Instruction": "KANDB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise AND 8 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDD",
      "Description": "Bitwise Logical AND Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 41 /r",
          "Instruction": "KANDD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND 32 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDNB",
      "Description": "Bitwise Logical AND NOT Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 42 /r",
          "Instruction": "KANDNB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise AND NOT 8 bits masks k1 and k2 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDND",
      "Description": "Bitwise Logical AND NOT Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 42 /r",
          "Instruction": "KANDND k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND NOT 32 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDNQ",
      "Description": "Bitwise Logical AND NOT Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 42 /r",
          "Instruction": "KANDNQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND NOT 64 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDNW",
      "Description": "Bitwise Logical AND NOT Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDNW:KANDNB:KANDNQ:KANDND.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 42 /r",
          "Instruction": "KANDNW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND NOT 16 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDQ",
      "Description": "Bitwise Logical AND Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 41 /r",
          "Instruction": "KANDQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND 64 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KANDW",
      "Description": "Bitwise Logical AND Masks",
      "Url": "https://www.felixcloutier.com/x86/KANDW:KANDB:KANDQ:KANDD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 41 /r",
          "Instruction": "KANDW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND 16 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KMOVB",
      "Description": "Move from and to Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W0 90 /r",
          "Instruction": "KMOVB k1, k2/m8",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Move 8 bits mask from k2/m8 and store the result in k1."
        },
        {
          "Opcode": "VEX.L0.66.0F.W0 91 /r",
          "Instruction": "KMOVB m8, k1",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Move 8 bits mask from k1 and store the result in m8."
        },
        {
          "Opcode": "VEX.L0.66.0F.W0 92 /r",
          "Instruction": "KMOVB k1, r32",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Move 8 bits mask from r32 to k1."
        },
        {
          "Opcode": "VEX.L0.66.0F.W0 93 /r",
          "Instruction": "KMOVB r32, k1",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Move 8 bits mask from k1 to r32."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w, ModRM:[7:6] must not be 11b)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KMOVD",
      "Description": "Move from and to Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W1 90 /r",
          "Instruction": "KMOVD k1, k2/m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 32 bits mask from k2/m32 and store the result in k1."
        },
        {
          "Opcode": "VEX.L0.66.0F.W1 91 /r",
          "Instruction": "KMOVD m32, k1",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 32 bits mask from k1 and store the result in m32."
        },
        {
          "Opcode": "VEX.L0.F2.0F.W0 92 /r",
          "Instruction": "KMOVD k1, r32",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 32 bits mask from r32 to k1."
        },
        {
          "Opcode": "VEX.L0.F2.0F.W0 93 /r",
          "Instruction": "KMOVD r32, k1",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 32 bits mask from k1 to r32."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w, ModRM:[7:6] must not be 11b)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KMOVQ",
      "Description": "Move from and to Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W1 90 /r",
          "Instruction": "KMOVQ k1, k2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 64 bits mask from k2/m64 and store the result in k1."
        },
        {
          "Opcode": "VEX.L0.0F.W1 91 /r",
          "Instruction": "KMOVQ m64, k1",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 64 bits mask from k1 and store the result in m64."
        },
        {
          "Opcode": "VEX.L0.F2.0F.W1 92 /r",
          "Instruction": "KMOVQ k1, r64",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/I",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 64 bits mask from r64 to k1."
        },
        {
          "Opcode": "VEX.L0.F2.0F.W1 93 /r",
          "Instruction": "KMOVQ r64, k1",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/I",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move 64 bits mask from k1 to r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w, ModRM:[7:6] must not be 11b)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KMOVW",
      "Description": "Move from and to Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KMOVW:KMOVB:KMOVQ:KMOVD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W0 90 /r",
          "Instruction": "KMOVW k1, k2/m16",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move 16 bits mask from k2/m16 and store the result in k1."
        },
        {
          "Opcode": "VEX.L0.0F.W0 91 /r",
          "Instruction": "KMOVW m16, k1",
          "OperandEncoding": "MR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move 16 bits mask from k1 and store the result in m16."
        },
        {
          "Opcode": "VEX.L0.0F.W0 92 /r",
          "Instruction": "KMOVW k1, r32",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move 16 bits mask from r32 to k1."
        },
        {
          "Opcode": "VEX.L0.0F.W0 93 /r",
          "Instruction": "KMOVW r32, k1",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move 16 bits mask from k1 to r32."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w, ModRM:[7:6] must not be 11b)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KNOTB",
      "Description": "NOT Mask Register",
      "Url": "https://www.felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W0 44 /r",
          "Instruction": "KNOTB k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise NOT of 8 bits mask k2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KNOTD",
      "Description": "NOT Mask Register",
      "Url": "https://www.felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W1 44 /r",
          "Instruction": "KNOTD k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise NOT of 32 bits mask k2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KNOTQ",
      "Description": "NOT Mask Register",
      "Url": "https://www.felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W1 44 /r",
          "Instruction": "KNOTQ k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise NOT of 64 bits mask k2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KNOTW",
      "Description": "NOT Mask Register",
      "Url": "https://www.felixcloutier.com/x86/KNOTW:KNOTB:KNOTQ:KNOTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W0 44 /r",
          "Instruction": "KNOTW k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise NOT of 16 bits mask k2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORB",
      "Description": "Bitwise Logical OR Masks",
      "Url": "https://www.felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 45 /r",
          "Instruction": "KORB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise OR 8 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORD",
      "Description": "Bitwise Logical OR Masks",
      "Url": "https://www.felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 45 /r",
          "Instruction": "KORD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise OR 32 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORQ",
      "Description": "Bitwise Logical OR Masks",
      "Url": "https://www.felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 45 /r",
          "Instruction": "KORQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise OR 64 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORTESTB",
      "Description": "OR Masks And Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W0 98 /r",
          "Instruction": "KORTESTB k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise OR 8 bits masks k1 and k2 and update ZF and CF accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORTESTD",
      "Description": "OR Masks And Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W1 98 /r",
          "Instruction": "KORTESTD k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise OR 32 bits masks k1 and k2 and update ZF and CF accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORTESTQ",
      "Description": "OR Masks And Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W1 98 /r",
          "Instruction": "KORTESTQ k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise OR 64 bits masks k1 and k2 and update ZF and CF accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORTESTW",
      "Description": "OR Masks And Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KORTESTW:KORTESTB:KORTESTQ:KORTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W0 98 /r",
          "Instruction": "KORTESTW k1, k2",
          "OperandEncoding": "RR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise OR 16 bits masks k1 and k2 and update ZF and CF accordingly."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KORW",
      "Description": "Bitwise Logical OR Masks",
      "Url": "https://www.felixcloutier.com/x86/KORW:KORB:KORQ:KORD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 45 /r",
          "Instruction": "KORW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise OR 16 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTLB",
      "Description": "Shift Left Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W0 32 /r",
          "Instruction": "KSHIFTLB k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Shift left 8 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTLD",
      "Description": "Shift Left Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W0 33 /r",
          "Instruction": "KSHIFTLD k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift left 32 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTLQ",
      "Description": "Shift Left Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W1 33 /r",
          "Instruction": "KSHIFTLQ k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift left 64 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTLW",
      "Description": "Shift Left Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTLW:KSHIFTLB:KSHIFTLQ:KSHIFTLD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W1 32 /r",
          "Instruction": "KSHIFTLW k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift left 16 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTRB",
      "Description": "Shift Right Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W0 30 /r",
          "Instruction": "KSHIFTRB k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Shift right 8 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTRD",
      "Description": "Shift Right Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W0 31 /r",
          "Instruction": "KSHIFTRD k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift right 32 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTRQ",
      "Description": "Shift Right Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W1 31 /r",
          "Instruction": "KSHIFTRQ k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift right 64 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KSHIFTRW",
      "Description": "Shift Right Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KSHIFTRW:KSHIFTRB:KSHIFTRQ:KSHIFTRD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F3A.W1 30 /r",
          "Instruction": "KSHIFTRW k1, k2, imm8",
          "OperandEncoding": "RRI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift right 16 bits in k2 by immediate and write result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RRI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KTESTB",
      "Description": "Packed Bit Test Masks and Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W0 99 /r",
          "Instruction": "KTESTB k1, k2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of 8 bits mask register sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KTESTD",
      "Description": "Packed Bit Test Masks and Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.66.0F.W1 99 /r",
          "Instruction": "KTESTD k1, k2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of 32 bits mask register sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KTESTQ",
      "Description": "Packed Bit Test Masks and Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W1 99 /r",
          "Instruction": "KTESTQ k1, k2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of 64 bits mask register sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KTESTW",
      "Description": "Packed Bit Test Masks and Set Flags",
      "Url": "https://www.felixcloutier.com/x86/KTESTW:KTESTB:KTESTQ:KTESTD.html",
      "Table": [
        {
          "Opcode": "VEX.L0.0F.W0 99 /r",
          "Instruction": "KTESTW k1, k2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of 16 bits mask register sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RR",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KUNPCKBW",
      "Description": "Unpack for Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.66.0F.W0 4B /r",
          "Instruction": "KUNPCKBW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Unpack and interleave 8 bits masks in k2 and k3 and write word result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KUNPCKDQ",
      "Description": "Unpack for Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W1 4B /r",
          "Instruction": "KUNPCKDQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Unpack and interleave 32 bits masks in k2 and k3 and write quadword result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KUNPCKWD",
      "Description": "Unpack for Mask Registers",
      "Url": "https://www.felixcloutier.com/x86/KUNPCKBW:KUNPCKWD:KUNPCKDQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 4B /r",
          "Instruction": "KUNPCKWD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Unpack and interleave 16 bits in k2 and k3 and write double-word result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXNORB",
      "Description": "Bitwise Logical XNOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 46 /r",
          "Instruction": "KXNORB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise XNOR 8 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXNORD",
      "Description": "Bitwise Logical XNOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 46 /r",
          "Instruction": "KXNORD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise XNOR 32 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXNORQ",
      "Description": "Bitwise Logical XNOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 46 /r",
          "Instruction": "KXNORQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise XNOR 64 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXNORW",
      "Description": "Bitwise Logical XNOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXNORW:KXNORB:KXNORQ:KXNORD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 46 /r",
          "Instruction": "KXNORW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise XNOR 16 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXORB",
      "Description": "Bitwise Logical XOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W0 47 /r",
          "Instruction": "KXORB k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Bitwise XOR 8 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXORD",
      "Description": "Bitwise Logical XOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.66.0F.W1 47 /r",
          "Instruction": "KXORD k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise XOR 32 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXORQ",
      "Description": "Bitwise Logical XOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html",
      "Table": [
        {
          "Opcode": "VEX.L1.0F.W1 47 /r",
          "Instruction": "KXORQ k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise XOR 64 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "KXORW",
      "Description": "Bitwise Logical XOR Masks",
      "Url": "https://www.felixcloutier.com/x86/KXORW:KXORB:KXORQ:KXORD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.L1.0F.W0 47 /r",
          "Instruction": "KXORW k1, k2, k3",
          "OperandEncoding": "RVR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise XOR 16 bits masks k2 and k3 and place result in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.1vvv (r)",
            "ModRM:r/m (r, ModRM:[7:6] must be 11b)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LAHF",
      "Description": "Load Status Flags into AH Register",
      "Url": "https://www.felixcloutier.com/x86/LAHF.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LAR",
      "Description": "Load Access Rights Byte",
      "Url": "https://www.felixcloutier.com/x86/LAR.html",
      "Table": [
        {
          "Opcode": "0F 02 /r",
          "Instruction": "LAR r16, r16/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r16 ← access rights referenced by r16/m16"
        },
        {
          "Opcode": "0F 02 /r",
          "Instruction": "LAR reg, r32/m161",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "reg ← access rights referenced by r32/m16"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LDDQU",
      "Description": "Load Unaligned Integer 128 Bits",
      "Url": "https://www.felixcloutier.com/x86/LDDQU.html",
      "Table": [
        {
          "Opcode": "F2 0F F0 /r",
          "Instruction": "LDDQU xmm1, mem",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Load unaligned data from mem and return double quadword in xmm1."
        },
        {
          "Opcode": "VEX.128.F2.0F.WIG F0 /r",
          "Instruction": "VLDDQU xmm1, m128",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Load unaligned packed integer values from mem to xmm1."
        },
        {
          "Opcode": "VEX.256.F2.0F.WIG F0 /r",
          "Instruction": "VLDDQU ymm1, m256",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Load unaligned packed integer values from mem to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LDMXCSR",
      "Description": "Load MXCSR Register",
      "Url": "https://www.felixcloutier.com/x86/LDMXCSR.html",
      "Table": [
        {
          "Opcode": "NP 0F AE /2",
          "Instruction": "LDMXCSR m32",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "SSE",
          "Description": "Load MXCSR register from m32."
        },
        {
          "Opcode": "VEX.LZ.0F.WIG AE /2",
          "Instruction": "VLDMXCSR m32",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "AVX",
          "Description": "Load MXCSR register from m32."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LDS",
      "Description": "Load Far Pointer",
      "Url": "https://www.felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html",
      "Table": [
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r16 with far pointer from memory."
        },
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B2 /r",
          "Instruction": "LSS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load SS:r64 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r16 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B4 /r",
          "Instruction": "LFS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load FS:r64 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B5 /r",
          "Instruction": "LGS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load GS:r64 with far pointer from memory."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LEA",
      "Description": "Load Effective Address",
      "Url": "https://www.felixcloutier.com/x86/LEA.html",
      "Table": [
        {
          "Opcode": "8D /r",
          "Instruction": "LEA r16,m",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Store effective address for m in register r16."
        },
        {
          "Opcode": "8D /r",
          "Instruction": "LEA r32,m",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Store effective address for m in register r32."
        },
        {
          "Opcode": "REX.W + 8D /r",
          "Instruction": "LEA r64,m",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Store effective address for m in register r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LEAVE",
      "Description": "High Level Procedure Exit",
      "Url": "https://www.felixcloutier.com/x86/LEAVE.html",
      "Table": [
        {
          "Opcode": "C9",
          "Instruction": "LEAVE",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set SP to BP, then pop BP."
        },
        {
          "Opcode": "C9",
          "Instruction": "LEAVE",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set ESP to EBP, then pop EBP."
        },
        {
          "Opcode": "C9",
          "Instruction": "LEAVE",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Set RSP to RBP, then pop RBP."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LES",
      "Description": "Load Far Pointer",
      "Url": "https://www.felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html",
      "Table": [
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r16 with far pointer from memory."
        },
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B2 /r",
          "Instruction": "LSS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load SS:r64 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r16 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B4 /r",
          "Instruction": "LFS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load FS:r64 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B5 /r",
          "Instruction": "LGS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load GS:r64 with far pointer from memory."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LFENCE",
      "Description": "Load Fence",
      "Url": "https://www.felixcloutier.com/x86/LFENCE.html",
      "Table": [
        {
          "Opcode": "NP 0F AE E8",
          "Instruction": "LFENCE",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Serializes load operations."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LFS",
      "Description": "Load Far Pointer",
      "Url": "https://www.felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html",
      "Table": [
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r16 with far pointer from memory."
        },
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B2 /r",
          "Instruction": "LSS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load SS:r64 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r16 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B4 /r",
          "Instruction": "LFS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load FS:r64 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B5 /r",
          "Instruction": "LGS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load GS:r64 with far pointer from memory."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LGDT",
      "Description": "Load Global/Interrupt Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/LGDT:LIDT.html",
      "Table": [
        {
          "Opcode": "0F 01 /2",
          "Instruction": "LGDT m16&amp;32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load m into GDTR."
        },
        {
          "Opcode": "0F 01 /3",
          "Instruction": "LIDT m16&amp;32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load m into IDTR."
        },
        {
          "Opcode": "0F 01 /2",
          "Instruction": "LGDT m16&amp;64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Load m into GDTR."
        },
        {
          "Opcode": "0F 01 /3",
          "Instruction": "LIDT m16&amp;64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Load m into IDTR."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LGS",
      "Description": "Load Far Pointer",
      "Url": "https://www.felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html",
      "Table": [
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r16 with far pointer from memory."
        },
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B2 /r",
          "Instruction": "LSS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load SS:r64 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r16 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B4 /r",
          "Instruction": "LFS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load FS:r64 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B5 /r",
          "Instruction": "LGS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load GS:r64 with far pointer from memory."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LIDT",
      "Description": "Load Global/Interrupt Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/LGDT:LIDT.html",
      "Table": [
        {
          "Opcode": "0F 01 /2",
          "Instruction": "LGDT m16&amp;32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load m into GDTR."
        },
        {
          "Opcode": "0F 01 /3",
          "Instruction": "LIDT m16&amp;32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load m into IDTR."
        },
        {
          "Opcode": "0F 01 /2",
          "Instruction": "LGDT m16&amp;64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Load m into GDTR."
        },
        {
          "Opcode": "0F 01 /3",
          "Instruction": "LIDT m16&amp;64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Load m into IDTR."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LLDT",
      "Description": "Load Local Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/LLDT.html",
      "Table": [
        {
          "Opcode": "0F 00 /2",
          "Instruction": "LLDT r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load segment selector r/m16 into LDTR."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LMSW",
      "Description": "Load Machine Status Word",
      "Url": "https://www.felixcloutier.com/x86/LMSW.html",
      "Table": [
        {
          "Opcode": "0F 01 /6",
          "Instruction": "LMSW r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Loads r/m16 in machine status word of CR0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LOCK",
      "UniqueName": "@lock",
      "Description": "Assert LOCK# Signal Prefix",
      "Url": "https://www.felixcloutier.com/x86/LOCK.html",
      "Table": [
        {
          "Opcode": "F0",
          "Instruction": "LOCK",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Asserts LOCK# signal for duration of the accompanying instruction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LODS",
      "Description": "Load String",
      "Url": "https://www.felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html",
      "Table": [
        {
          "Opcode": "AC",
          "Instruction": "LODS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        },
        {
          "Opcode": "AC",
          "Instruction": "LODSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LODSB",
      "Description": "Load String",
      "Url": "https://www.felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html",
      "Table": [
        {
          "Opcode": "AC",
          "Instruction": "LODS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        },
        {
          "Opcode": "AC",
          "Instruction": "LODSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LODSD",
      "Description": "Load String",
      "Url": "https://www.felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html",
      "Table": [
        {
          "Opcode": "AC",
          "Instruction": "LODS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        },
        {
          "Opcode": "AC",
          "Instruction": "LODSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LODSQ",
      "Description": "Load String",
      "Url": "https://www.felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html",
      "Table": [
        {
          "Opcode": "AC",
          "Instruction": "LODS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        },
        {
          "Opcode": "AC",
          "Instruction": "LODSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LODSW",
      "Description": "Load String",
      "Url": "https://www.felixcloutier.com/x86/LODS:LODSB:LODSW:LODSD:LODSQ.html",
      "Table": [
        {
          "Opcode": "AC",
          "Instruction": "LODS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        },
        {
          "Opcode": "AC",
          "Instruction": "LODSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load byte at address DS:(E)SI into AL. For 64-bit mode load byte at address (R)SI into AL."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load word at address DS:(E)SI into AX. For 64-bit mode load word at address (R)SI into AX."
        },
        {
          "Opcode": "AD",
          "Instruction": "LODSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Load dword at address DS:(E)SI into EAX. For 64-bit mode load dword at address (R)SI into EAX."
        },
        {
          "Opcode": "REX.W + AD",
          "Instruction": "LODSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load qword at address (R)SI into RAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "LOOP",
      "Description": "Loop According to ECX Counter",
      "Url": "https://www.felixcloutier.com/x86/LOOP:LOOPcc.html",
      "Table": [
        {
          "Opcode": "E2 cb",
          "Instruction": "LOOP rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0."
        },
        {
          "Opcode": "E1 cb",
          "Instruction": "LOOPE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0 and ZF = 1."
        },
        {
          "Opcode": "E0 cb",
          "Instruction": "LOOPNE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0 and ZF = 0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "D",
          "Operands": [
            "Offset"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LOOPcc",
      "Description": "Loop According to ECX Counter",
      "Url": "https://www.felixcloutier.com/x86/LOOP:LOOPcc.html",
      "Table": [
        {
          "Opcode": "E2 cb",
          "Instruction": "LOOP rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0."
        },
        {
          "Opcode": "E1 cb",
          "Instruction": "LOOPE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0 and ZF = 1."
        },
        {
          "Opcode": "E0 cb",
          "Instruction": "LOOPNE rel8",
          "OperandEncoding": "D",
          "CompatLegMode": "Valid",
          "Description": "Decrement count; jump short if count ≠ 0 and ZF = 0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "D",
          "Operands": [
            "Offset"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LSL",
      "Description": "Load Segment Limit",
      "Url": "https://www.felixcloutier.com/x86/LSL.html",
      "Table": [
        {
          "Opcode": "0F 03 /r",
          "Instruction": "LSL r16, r16/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load: r16 ← segment limit, selector r16/m16."
        },
        {
          "Opcode": "0F 03 /r",
          "Instruction": "LSL r32, r32/m16*",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load: r32 ← segment limit, selector r32/m16."
        },
        {
          "Opcode": "REX.W + 0F 03 /r",
          "Instruction": "LSL r64, r32/m16*",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load: r64 ← segment limit, selector r32/m16"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LSS",
      "Description": "Load Far Pointer",
      "Url": "https://www.felixcloutier.com/x86/LDS:LES:LFS:LGS:LSS.html",
      "Table": [
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r16 with far pointer from memory."
        },
        {
          "Opcode": "C5 /r",
          "Instruction": "LDS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load DS:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B2 /r",
          "Instruction": "LSS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load SS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B2 /r",
          "Instruction": "LSS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load SS:r64 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r16 with far pointer from memory."
        },
        {
          "Opcode": "C4 /r",
          "Instruction": "LES r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load ES:r32 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B4 /r",
          "Instruction": "LFS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load FS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B4 /r",
          "Instruction": "LFS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load FS:r64 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r16,m16:16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r16 with far pointer from memory."
        },
        {
          "Opcode": "0F B5 /r",
          "Instruction": "LGS r32,m16:32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Load GS:r32 with far pointer from memory."
        },
        {
          "Opcode": "REX + 0F B5 /r",
          "Instruction": "LGS r64,m16:64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Load GS:r64 with far pointer from memory."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LTR",
      "Description": "Load Task Register",
      "Url": "https://www.felixcloutier.com/x86/LTR.html",
      "Table": [
        {
          "Opcode": "0F 00 /3",
          "Instruction": "LTR r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Load r/m16 into task register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "LZCNT",
      "Description": "Count the Number of Leading Zero Bits",
      "Url": "https://www.felixcloutier.com/x86/LZCNT.html",
      "Table": [],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MASKMOVDQU",
      "Description": "Store Selected Bytes of Double Quadword",
      "Url": "https://www.felixcloutier.com/x86/MASKMOVDQU.html",
      "Table": [
        {
          "Opcode": "66 0F F7 /r",
          "Instruction": "MASKMOVDQU xmm1, xmm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG F7 /r",
          "Instruction": "VMASKMOVDQU xmm1, xmm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Selectively write bytes from xmm1 to memory location using the byte mask in xmm2. The default memory location is specified by DS:DI/EDI/RDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MASKMOVQ",
      "Description": "Store Selected Bytes of Quadword",
      "Url": "https://www.felixcloutier.com/x86/MASKMOVQ.html",
      "Table": [
        {
          "Opcode": "NP 0F F7 /r",
          "Instruction": "MASKMOVQ mm1, mm2",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Selectively write bytes from mm1 to memory location using the byte mask in mm2. The default memory location is specified by DS:DI/EDI/RDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MAXPD",
      "Description": "Maximum of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MAXPD.html",
      "Table": [
        {
          "Opcode": "66 0F 5F /r",
          "Instruction": "MAXPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the maximum double-precision floating-point values between xmm1 and xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 5F /r",
          "Instruction": "VMAXPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum double-precision floating-point values between xmm2 and xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 5F /r",
          "Instruction": "VMAXPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 5F /r",
          "Instruction": "VMAXPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the maximum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 5F /r",
          "Instruction": "VMAXPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the maximum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 5F /r",
          "Instruction": "VMAXPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the maximum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MAXPS",
      "Description": "Maximum of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MAXPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 5F /r",
          "Instruction": "MAXPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the maximum single-precision floating-point values between xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 5F /r",
          "Instruction": "VMAXPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum single-precision floating-point values between xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 5F /r",
          "Instruction": "VMAXPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum single-precision floating-point values between ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 5F /r",
          "Instruction": "VMAXPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the maximum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 5F /r",
          "Instruction": "VMAXPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the maximum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 5F /r",
          "Instruction": "VMAXPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the maximum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MAXSD",
      "Description": "Return Maximum Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MAXSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 5F /r",
          "Instruction": "MAXSD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the maximum scalar double-precision floating-point value between xmm2/m64 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 5F /r",
          "Instruction": "VMAXSD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 5F /r",
          "Instruction": "VMAXSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the maximum scalar double-precision floating-point value between xmm3/m64 and xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MAXSS",
      "Description": "Return Maximum Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MAXSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 5F /r",
          "Instruction": "MAXSS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the maximum scalar single-precision floating-point value between xmm2/m32 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 5F /r",
          "Instruction": "VMAXSS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 5F /r",
          "Instruction": "VMAXSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the maximum scalar single-precision floating-point value between xmm3/m32 and xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MFENCE",
      "Description": "Memory Fence",
      "Url": "https://www.felixcloutier.com/x86/MFENCE.html"
    },
    {
      "Mnemonic": "MINPD",
      "Description": "Minimum of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MINPD.html",
      "Table": [
        {
          "Opcode": "66 0F 5D /r",
          "Instruction": "MINPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the minimum double-precision floating-point values between xmm1 and xmm2/mem"
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 5D /r",
          "Instruction": "VMINPD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum double-precision floating-point values between xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 5D /r",
          "Instruction": "VMINPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 5D /r",
          "Instruction": "VMINPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the minimum packed double-precision floating-point values between xmm2 and xmm3/m128/m64bcst and store result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 5D /r",
          "Instruction": "VMINPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the minimum packed double-precision floating-point values between ymm2 and ymm3/m256/m64bcst and store result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 5D /r",
          "Instruction": "VMINPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the minimum packed double-precision floating-point values between zmm2 and zmm3/m512/m64bcst and store result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MINPS",
      "Description": "Minimum of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MINPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 5D /r",
          "Instruction": "MINPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the minimum single-precision floating-point values between xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 5D /r",
          "Instruction": "VMINPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum single-precision floating-point values between xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 5D /r",
          "Instruction": "VMINPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum single double-precision floating-point values between ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 5D /r",
          "Instruction": "VMINPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the minimum packed single-precision floating-point values between xmm2 and xmm3/m128/m32bcst and store result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 5D /r",
          "Instruction": "VMINPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Return the minimum packed single-precision floating-point values between ymm2 and ymm3/m256/m32bcst and store result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 5D /r",
          "Instruction": "VMINPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the minimum packed single-precision floating-point values between zmm2 and zmm3/m512/m32bcst and store result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MINSD",
      "Description": "Return Minimum Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MINSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 5D /r",
          "Instruction": "MINSD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the minimum scalar double-precision floating-point value between xmm2/m64 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 5D /r",
          "Instruction": "VMINSD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 5D /r",
          "Instruction": "VMINSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the minimum scalar double-precision floating-point value between xmm3/m64 and xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MINSS",
      "Description": "Return Minimum Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MINSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 5D /r",
          "Instruction": "MINSS xmm1,xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the minimum scalar single-precision floating-point value between xmm2/m32 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 5D /r",
          "Instruction": "VMINSS xmm1,xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 5D /r",
          "Instruction": "VMINSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Return the minimum scalar single-precision floating-point value between xmm3/m32 and xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MONITOR",
      "Description": "Set Up Monitor Address",
      "Url": "https://www.felixcloutier.com/x86/MONITOR.html"
    },
    {
      "Mnemonic": "MOV",
      "Description": "Move",
      "Url": "https://www.felixcloutier.com/x86/MOV.html",
      "Table": [
        {
          "Opcode": "88 /r",
          "Instruction": "MOV r/m8,r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move r8 to r/m8."
        },
        {
          "Opcode": "REX + 88 /r",
          "Instruction": "MOV r/m8***,r8***",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move r8 to r/m8."
        },
        {
          "Opcode": "89 /r",
          "Instruction": "MOV r/m16,r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move r16 to r/m16."
        },
        {
          "Opcode": "89 /r",
          "Instruction": "MOV r/m32,r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move r32 to r/m32."
        },
        {
          "Opcode": "REX.W + 89 /r",
          "Instruction": "MOV r/m64,r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move r64 to r/m64."
        },
        {
          "Opcode": "8A /r",
          "Instruction": "MOV r8,r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r/m8 to r8."
        },
        {
          "Opcode": "REX + 8A /r",
          "Instruction": "MOV r8***,r/m8***",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move r/m8 to r8."
        },
        {
          "Opcode": "8B /r",
          "Instruction": "MOV r16,r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r/m16 to r16."
        },
        {
          "Opcode": "8B /r",
          "Instruction": "MOV r32,r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r/m32 to r32."
        },
        {
          "Opcode": "REX.W + 8B /r",
          "Instruction": "MOV r64,r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move r/m64 to r64."
        },
        {
          "Opcode": "8C /r",
          "Instruction": "MOV r/m16,Sreg**",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move segment register to r/m16."
        },
        {
          "Opcode": "REX.W + 8C /r",
          "Instruction": "MOV r16/r32/m16, Sreg**",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move zero extended 16-bit segment register to r16/r32/r64/m16."
        },
        {
          "Opcode": "REX.W + 8C /r",
          "Instruction": "MOV r64/m16, Sreg**",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move zero extended 16-bit segment register to r64/m16."
        },
        {
          "Opcode": "8E /r",
          "Instruction": "MOV Sreg,r/m16**",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r/m16 to segment register."
        },
        {
          "Opcode": "REX.W + 8E /r",
          "Instruction": "MOV Sreg,r/m64**",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move lower 16 bits of r/m64 to segment register."
        },
        {
          "Opcode": "A0",
          "Instruction": "MOV AL,moffs8*",
          "OperandEncoding": "FD",
          "CompatLegMode": "Valid",
          "Description": "Move byte at (seg:offset) to AL."
        },
        {
          "Opcode": "REX.W + A0",
          "Instruction": "MOV AL,moffs8*",
          "OperandEncoding": "FD",
          "CompatLegMode": "N.E.",
          "Description": "Move byte at (offset) to AL."
        },
        {
          "Opcode": "A1",
          "Instruction": "MOV AX,moffs16*",
          "OperandEncoding": "FD",
          "CompatLegMode": "Valid",
          "Description": "Move word at (seg:offset) to AX."
        },
        {
          "Opcode": "A1",
          "Instruction": "MOV EAX,moffs32*",
          "OperandEncoding": "FD",
          "CompatLegMode": "Valid",
          "Description": "Move doubleword at (seg:offset) to EAX."
        },
        {
          "Opcode": "REX.W + A1",
          "Instruction": "MOV RAX,moffs64*",
          "OperandEncoding": "FD",
          "CompatLegMode": "N.E.",
          "Description": "Move quadword at (offset) to RAX."
        },
        {
          "Opcode": "A2",
          "Instruction": "MOV moffs8,AL",
          "OperandEncoding": "TD",
          "CompatLegMode": "Valid",
          "Description": "Move AL to (seg:offset)."
        },
        {
          "Opcode": "REX.W + A2",
          "Instruction": "MOV moffs8***,AL",
          "OperandEncoding": "TD",
          "CompatLegMode": "N.E.",
          "Description": "Move AL to (offset)."
        },
        {
          "Opcode": "A3",
          "Instruction": "MOV moffs16*,AX",
          "OperandEncoding": "TD",
          "CompatLegMode": "Valid",
          "Description": "Move AX to (seg:offset)."
        },
        {
          "Opcode": "A3",
          "Instruction": "MOV moffs32*,EAX",
          "OperandEncoding": "TD",
          "CompatLegMode": "Valid",
          "Description": "Move EAX to (seg:offset)."
        },
        {
          "Opcode": "REX.W + A3",
          "Instruction": "MOV moffs64*,RAX",
          "OperandEncoding": "TD",
          "CompatLegMode": "N.E.",
          "Description": "Move RAX to (offset)."
        },
        {
          "Opcode": "B0+ rb ib",
          "Instruction": "MOV r8, imm8",
          "OperandEncoding": "OI",
          "CompatLegMode": "Valid",
          "Description": "Move imm8 to r8."
        },
        {
          "Opcode": "REX + B0+ rb ib",
          "Instruction": "MOV r8***, imm8",
          "OperandEncoding": "OI",
          "CompatLegMode": "N.E.",
          "Description": "Move imm8 to r8."
        },
        {
          "Opcode": "B8+ rw iw",
          "Instruction": "MOV r16, imm16",
          "OperandEncoding": "OI",
          "CompatLegMode": "Valid",
          "Description": "Move imm16 to r16."
        },
        {
          "Opcode": "B8+ rd id",
          "Instruction": "MOV r32, imm32",
          "OperandEncoding": "OI",
          "CompatLegMode": "Valid",
          "Description": "Move imm32 to r32."
        },
        {
          "Opcode": "REX.W + B8+ rd io",
          "Instruction": "MOV r64, imm64",
          "OperandEncoding": "OI",
          "CompatLegMode": "N.E.",
          "Description": "Move imm64 to r64."
        },
        {
          "Opcode": "C6 /0 ib",
          "Instruction": "MOV r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Move imm8 to r/m8."
        },
        {
          "Opcode": "REX + C6 /0 ib",
          "Instruction": "MOV r/m8***, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Move imm8 to r/m8."
        },
        {
          "Opcode": "C7 /0 iw",
          "Instruction": "MOV r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Move imm16 to r/m16."
        },
        {
          "Opcode": "C7 /0 id",
          "Instruction": "MOV r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Move imm32 to r/m32."
        },
        {
          "Opcode": "REX.W + C7 /0 id",
          "Instruction": "MOV r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Move imm32 sign extended to 64-bits to r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "FD",
          "Operands": [
            "AL/AX/EAX/RAX",
            "Moffs"
          ]
        },
        {
          "OperandEncoding": "TD",
          "Operands": [
            "Moffs (w)",
            "AL/AX/EAX/RAX"
          ]
        },
        {
          "OperandEncoding": "OI",
          "Operands": [
            "opcode + rd (w)",
            "imm8/16/32/64"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8/16/32/64"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOV",
      "UniqueName": "mov_cr",
      "Description": "Move to/from Control Registers",
      "Url": "https://www.felixcloutier.com/x86/MOV-1.html",
      "Table": [
        {
          "Opcode": "0F 20/r",
          "Instruction": "MOV r32, CR0–CR7",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move control register to r32."
        },
        {
          "Opcode": "0F 20/r",
          "Instruction": "MOV r64, CR0–CR7",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move extended control register to r64."
        },
        {
          "Opcode": "REX.R + 0F 20 /0",
          "Instruction": "MOV r64, CR8",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move extended CR8 to r64.1"
        },
        {
          "Opcode": "0F 22 /r",
          "Instruction": "MOV CR0–CR7, r32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r32 to control register."
        },
        {
          "Opcode": "0F 22 /r",
          "Instruction": "MOV CR0–CR7, r64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move r64 to extended control register."
        },
        {
          "Opcode": "REX.R + 0F 22 /0",
          "Instruction": "MOV CR8, r64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move r64 to extended CR8.1"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOV",
      "UniqueName": "mov_dr",
      "Description": "Move to/from Debug Registers",
      "Url": "https://www.felixcloutier.com/x86/MOV-2.html",
      "Table": [
        {
          "Opcode": "0F 21/r",
          "Instruction": "MOV r32, DR0–DR7",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move debug register to r32."
        },
        {
          "Opcode": "0F 21/r",
          "Instruction": "MOV r64, DR0–DR7",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move extended debug register to r64."
        },
        {
          "Opcode": "0F 23 /r",
          "Instruction": "MOV DR0–DR7, r32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move r32 to debug register."
        },
        {
          "Opcode": "0F 23 /r",
          "Instruction": "MOV DR0–DR7, r64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move r64 to extended debug register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVAPD",
      "Description": "Move Aligned Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVAPD.html",
      "Table": [
        {
          "Opcode": "66 0F 28 /r",
          "Instruction": "MOVAPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "66 0F 29 /r",
          "Instruction": "MOVAPD xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 28 /r",
          "Instruction": "VMOVAPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed double-precision floating-point values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 29 /r",
          "Instruction": "VMOVAPD xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 28 /r",
          "Instruction": "VMOVAPD ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed double-precision floating-point values from ymm2/mem to ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 29 /r",
          "Instruction": "VMOVAPD ymm2/m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed double-precision floating-point values from ymm1 to ymm2/mem."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 28 /r",
          "Instruction": "VMOVAPD xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 28 /r",
          "Instruction": "VMOVAPD ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 28 /r",
          "Instruction": "VMOVAPD zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 29 /r",
          "Instruction": "VMOVAPD xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 29 /r",
          "Instruction": "VMOVAPD ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 29 /r",
          "Instruction": "VMOVAPD zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVAPS",
      "Description": "Move Aligned Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVAPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 28 /r",
          "Instruction": "MOVAPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "NP 0F 29 /r",
          "Instruction": "MOVAPS xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.128.0F.WIG 28 /r",
          "Instruction": "VMOVAPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed single-precision floating-point values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "VEX.128.0F.WIG 29 /r",
          "Instruction": "VMOVAPS xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.256.0F.WIG 28 /r",
          "Instruction": "VMOVAPS ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed single-precision floating-point values from ymm2/mem to ymm1."
        },
        {
          "Opcode": "VEX.256.0F.WIG 29 /r",
          "Instruction": "VMOVAPS ymm2/m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed single-precision floating-point values from ymm1 to ymm2/mem."
        },
        {
          "Opcode": "EVEX.128.0F.W0 28 /r",
          "Instruction": "VMOVAPS xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 28 /r",
          "Instruction": "VMOVAPS ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 28 /r",
          "Instruction": "VMOVAPS zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.0F.W0 29 /r",
          "Instruction": "VMOVAPS xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 29 /r",
          "Instruction": "VMOVAPS ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 29 /r",
          "Instruction": "VMOVAPS zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVBE",
      "Description": "Move Data After Swapping Bytes",
      "Url": "https://www.felixcloutier.com/x86/MOVBE.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVD",
      "Description": "Move Doubleword/Move Quadword",
      "Url": "https://www.felixcloutier.com/x86/MOVD:MOVQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 6E /r",
          "Instruction": "MOVD mm, r/m32",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move doubleword from r/m32 to mm."
        },
        {
          "Opcode": "NP 0F 7E /r",
          "Instruction": "MOVD r/m32, mm",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move doubleword from mm to r/m32."
        },
        {
          "Opcode": "66 0F 6E /r",
          "Instruction": "MOVD xmm, r/m32",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move doubleword from r/m32 to xmm."
        },
        {
          "Opcode": "66 0F 7E /r",
          "Instruction": "MOVD r/m32, xmm",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move doubleword from xmm register to r/m32."
        },
        {
          "Opcode": "VEX.128.66.0F.W0 6E /",
          "Instruction": "VMOVD xmm1, r32/m32",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move doubleword from r/m32 to xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.W0 7E /r",
          "Instruction": "VMOVD r32/m32, xmm1",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move doubleword from xmm1 register to r/m32."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 6E /r",
          "Instruction": "VMOVD xmm1, r32/m32",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move doubleword from r/m32 to xmm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 7E /r",
          "Instruction": "VMOVD r32/m32, xmm1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move doubleword from xmm1 register to r/m32."
        }
      ]
    },
    {
      "Mnemonic": "MOVDDUP",
      "Description": "Replicate Double FP Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDDUP.html",
      "Table": [
        {
          "Opcode": "F2 0F 12 /r",
          "Instruction": "MOVDDUP xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
        },
        {
          "Opcode": "VEX.128.F2.0F.WIG 12 /r",
          "Instruction": "VMOVDDUP xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move double-precision floating-point value from xmm2/m64 and duplicate into xmm1."
        },
        {
          "Opcode": "VEX.256.F2.0F.WIG 12 /r",
          "Instruction": "VMOVDDUP ymm1, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move even index double-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W1 12 /r",
          "Instruction": "VMOVDDUP xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move double-precision floating-point value from xmm2/m64 and duplicate each element into xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 12 /r",
          "Instruction": "VMOVDDUP ymm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move even index double-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 12 /r",
          "Instruction": "VMOVDDUP zmm1 {k1}{z}, zmm2/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move even index double-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVDQ2Q",
      "Description": "Move Quadword from XMM to MMX Technology Register",
      "Url": "https://www.felixcloutier.com/x86/MOVDQ2Q.html"
    },
    {
      "Mnemonic": "MOVDQA",
      "Description": "Move Aligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html",
      "Table": [
        {
          "Opcode": "66 0F 6F /r",
          "Instruction": "MOVDQA xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move aligned packed integer values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "66 0F 7F /r",
          "Instruction": "MOVDQA xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move aligned packed integer values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 6F /r",
          "Instruction": "VMOVDQA xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed integer values from xmm2/mem to xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 7F /r",
          "Instruction": "VMOVDQA xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed integer values from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 6F /r",
          "Instruction": "VMOVDQA ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed integer values from ymm2/mem to ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 7F /r",
          "Instruction": "VMOVDQA ymm2/m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move aligned packed integer values from ymm1 to ymm2/mem."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned quadword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned quadword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVDQU",
      "Description": "Move Unaligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html",
      "Table": [
        {
          "Opcode": "F3 0F 6F /r",
          "Instruction": "MOVDQU xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move unaligned packed integer values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "F3 0F 7F /r",
          "Instruction": "MOVDQU xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move unaligned packed integer values from xmm1 to xmm2/m128."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 6F /r",
          "Instruction": "VMOVDQU xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed integer values from xmm2/m128 to xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 7F /r",
          "Instruction": "VMOVDQU xmm2/m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed integer values from xmm1 to xmm2/m128."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 6F /r",
          "Instruction": "VMOVDQU ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed integer values from ymm2/m256 to ymm1."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 7F /r",
          "Instruction": "VMOVDQU ymm2/m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed integer values from ymm1 to ymm2/m256."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 xmm1 {k1}{z}, xmm2/mm128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVHLPS",
      "Description": "Move Packed Single-Precision Floating-Point Values High to Low",
      "Url": "https://www.felixcloutier.com/x86/MOVHLPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 12 /r",
          "Instruction": "MOVHLPS xmm1, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from high quadword of xmm2 to low quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 12 /r",
          "Instruction": "VMOVHLPS xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 12 /r",
          "Instruction": "VMOVHLPS xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge two packed single-precision floating-point values from high quadword of xmm3 and low quadword of xmm2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVHPD",
      "Description": "Move High Packed Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MOVHPD.html",
      "Table": [
        {
          "Opcode": "66 0F 16 /r",
          "Instruction": "MOVHPD xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move double-precision floating-point value from m64 to high quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 16 /r",
          "Instruction": "VMOVHPD xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 16 /r",
          "Instruction": "VMOVHPD xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge double-precision floating-point value from m64 and the low quadword of xmm1."
        },
        {
          "Opcode": "66 0F 17 /r",
          "Instruction": "MOVHPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move double-precision floating-point value from high quadword of xmm1 to m64."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 17 /r",
          "Instruction": "VMOVHPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move double-precision floating-point value from high quadword of xmm1 to m64."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 17 /r",
          "Instruction": "VMOVHPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move double-precision floating-point value from high quadword of xmm1 to m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVHPS",
      "Description": "Move High Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVHPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 16 /r",
          "Instruction": "MOVHPS xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from m64 to high quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 16 /r",
          "Instruction": "VMOVHPS xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 16 /r",
          "Instruction": "VMOVHPS xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge two packed single-precision floating-point values from m64 and the low quadword of xmm1."
        },
        {
          "Opcode": "NP 0F 17 /r",
          "Instruction": "MOVHPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
        },
        {
          "Opcode": "VEX.128.0F.WIG 17 /r",
          "Instruction": "VMOVHPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
        },
        {
          "Opcode": "EVEX.128.0F.W0 17 /r",
          "Instruction": "VMOVHPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move two packed single-precision floating-point values from high quadword of xmm1 to m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVLHPS",
      "Description": "Move Packed Single-Precision Floating-Point Values Low to High",
      "Url": "https://www.felixcloutier.com/x86/MOVLHPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 16 /r",
          "Instruction": "MOVLHPS xmm1, xmm2",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from low quadword of xmm2 to high quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 16 /r",
          "Instruction": "VMOVLHPS xmm1, xmm2, xmm3",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 16 /r",
          "Instruction": "VMOVLHPS xmm1, xmm2, xmm3",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge two packed single-precision floating-point values from low quadword of xmm3 and low quadword of xmm2."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVLPD",
      "Description": "Move Low Packed Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MOVLPD.html",
      "Table": [
        {
          "Opcode": "66 0F 12 /r",
          "Instruction": "MOVLPD xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move double-precision floating-point value from m64 to low quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 12 /r",
          "Instruction": "VMOVLPD xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 12 /r",
          "Instruction": "VMOVLPD xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge double-precision floating-point value from m64 and the high quadword of xmm1."
        },
        {
          "Opcode": "66 0F 13/r",
          "Instruction": "MOVLPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move double-precision floating-point value from low quadword of xmm1 to m64."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 13/r",
          "Instruction": "VMOVLPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move double-precision floating-point value from low quadword of xmm1 to m64."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 13/r",
          "Instruction": "VMOVLPD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move double-precision floating-point value from low quadword of xmm1 to m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVLPS",
      "Description": "Move Low Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVLPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 12 /r",
          "Instruction": "MOVLPS xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from m64 to low quadword of xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 12 /r",
          "Instruction": "VMOVLPS xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 12 /r",
          "Instruction": "VMOVLPS xmm2, xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge two packed single-precision floating-point values from m64 and the high quadword of xmm1."
        },
        {
          "Opcode": "0F 13/r",
          "Instruction": "MOVLPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
        },
        {
          "Opcode": "VEX.128.0F.WIG 13/r",
          "Instruction": "VMOVLPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
        },
        {
          "Opcode": "EVEX.128.0F.W0 13/r",
          "Instruction": "VMOVLPS m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move two packed single-precision floating-point values from low quadword of xmm1 to m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVMSKPD",
      "Description": "Extract Packed Double-Precision Floating-Point Sign Mask",
      "Url": "https://www.felixcloutier.com/x86/MOVMSKPD.html",
      "Table": [
        {
          "Opcode": "66 0F 50 /r",
          "Instruction": "MOVMSKPD reg, xmm",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Extract 2-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 50 /r",
          "Instruction": "VMOVMSKPD reg, xmm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract 2-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 50 /r",
          "Instruction": "VMOVMSKPD reg, ymm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract 4-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVMSKPS",
      "Description": "Extract Packed Single-Precision Floating-Point Sign Mask",
      "Url": "https://www.felixcloutier.com/x86/MOVMSKPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 50 /r",
          "Instruction": "MOVMSKPS reg, xmm",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "SSE",
          "Description": "Extract 4-bit sign mask from xmm and store in reg. The upper bits of r32 or r64 are filled with zeros."
        },
        {
          "Opcode": "VEX.128.0F.WIG 50 /r",
          "Instruction": "VMOVMSKPS reg, xmm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract 4-bit sign mask from xmm2 and store in reg. The upper bits of r32 or r64 are zeroed."
        },
        {
          "Opcode": "VEX.256.0F.WIG 50 /r",
          "Instruction": "VMOVMSKPS reg, ymm2",
          "OperandEncoding": "RM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract 8-bit sign mask from ymm2 and store in reg. The upper bits of r32 or r64 are zeroed."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVNTDQ",
      "Description": "Store Packed Integers Using Non-Temporal Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTDQ.html",
      "Table": [
        {
          "Opcode": "66 0F E7 /r",
          "Instruction": "MOVNTDQ m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG E7 /r",
          "Instruction": "VMOVNTDQ m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG E7 /r",
          "Instruction": "VMOVNTDQ m256, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed integer values in ymm1 to m256 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 E7 /r",
          "Instruction": "VMOVNTDQ m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed integer values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 E7 /r",
          "Instruction": "VMOVNTDQ m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed integer values in zmm1 to m256 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 E7 /r",
          "Instruction": "VMOVNTDQ m512, zmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move packed integer values in zmm1 to m512 using non-temporal hint."
        }
      ]
    },
    {
      "Mnemonic": "MOVNTDQA",
      "Description": "Load Double Quadword Non-Temporal Aligned Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTDQA.html",
      "Table": [
        {
          "Opcode": "66 0F 38 2A /r",
          "Instruction": "MOVNTDQA xmm1, m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Move double quadword from m128 to xmm1 using non-temporal hint if WC memory type."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 2A /r",
          "Instruction": "VMOVNTDQA xmm1, m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move double quadword from m128 to xmm using non-temporal hint if WC memory type."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 2A /r",
          "Instruction": "VMOVNTDQA ymm1, m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 2A /r",
          "Instruction": "VMOVNTDQA xmm1, m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move 128-bit data from m128 to xmm using non-temporal hint if WC memory type."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 2A /r",
          "Instruction": "VMOVNTDQA ymm1, m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move 256-bit data from m256 to ymm using non-temporal hint if WC memory type."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 2A /r",
          "Instruction": "VMOVNTDQA zmm1, m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move 512-bit data from m512 to zmm using non-temporal hint if WC memory type."
        }
      ]
    },
    {
      "Mnemonic": "MOVNTI",
      "Description": "Store Doubleword Using Non-Temporal Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTI.html",
      "Table": [
        {
          "Opcode": "NP 0F C3 /r",
          "Instruction": "MOVNTI m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move doubleword from r32 to m32 using non-temporal hint."
        },
        {
          "Opcode": "NP REX.W + 0F C3 /r",
          "Instruction": "MOVNTI m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Move quadword from r64 to m64 using non-temporal hint."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVNTPD",
      "Description": "Store Packed Double-Precision Floating-Point Values Using Non-Temporal Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTPD.html",
      "Table": [
        {
          "Opcode": "66 0F 2B /r",
          "Instruction": "MOVNTPD m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 2B /r",
          "Instruction": "VMOVNTPD m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 2B /r",
          "Instruction": "VMOVNTPD m256, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 2B /r",
          "Instruction": "VMOVNTPD m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed double-precision values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 2B /r",
          "Instruction": "VMOVNTPD m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed double-precision values in ymm1 to m256 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 2B /r",
          "Instruction": "VMOVNTPD m512, zmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move packed double-precision values in zmm1 to m512 using non-temporal hint."
        }
      ]
    },
    {
      "Mnemonic": "MOVNTPS",
      "Description": "Store Packed Single-Precision Floating-Point Values Using Non-Temporal Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 2B /r",
          "Instruction": "MOVNTPS m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move packed single-precision values xmm1 to mem using non-temporal hint."
        },
        {
          "Opcode": "VEX.128.0F.WIG 2B /r",
          "Instruction": "VMOVNTPS m128, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed single-precision values xmm1 to mem using non-temporal hint."
        },
        {
          "Opcode": "VEX.256.0F.WIG 2B /r",
          "Instruction": "VMOVNTPS m256, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move packed single-precision values ymm1 to mem using non-temporal hint."
        },
        {
          "Opcode": "EVEX.128.0F.W0 2B /r",
          "Instruction": "VMOVNTPS m128, xmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed single-precision values in xmm1 to m128 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.256.0F.W0 2B /r",
          "Instruction": "VMOVNTPS m256, ymm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move packed single-precision values in ymm1 to m256 using non-temporal hint."
        },
        {
          "Opcode": "EVEX.512.0F.W0 2B /r",
          "Instruction": "VMOVNTPS m512, zmm1",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move packed single-precision values in zmm1 to m512 using non-temporal hint."
        }
      ]
    },
    {
      "Mnemonic": "MOVNTQ",
      "Description": "Store of Quadword Using Non-Temporal Hint",
      "Url": "https://www.felixcloutier.com/x86/MOVNTQ.html",
      "Table": [
        {
          "Opcode": "NP 0F E7 /r",
          "Instruction": "MOVNTQ m64, mm",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Move quadword from mm to m64 using non-temporal hint."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVQ",
      "UniqueName": "movq_1",
      "Description": "Move Doubleword/Move Quadword",
      "Url": "https://www.felixcloutier.com/x86/MOVD:MOVQ.html",
      "Table": [
        {
          "Opcode": "NP REX.W + 0F 6E /r",
          "Instruction": "MOVQ mm, r/m64",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move quadword from r/m64 to mm."
        },
        {
          "Opcode": "NP REX.W + 0F 7E /r",
          "Instruction": "MOVQ r/m64, mm",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move quadword from mm to r/m64."
        },
        {
          "Opcode": "66 REX.W 0F 6E /r",
          "Instruction": "MOVQ xmm, r/m64",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move quadword from r/m64 to xmm."
        },
        {
          "Opcode": "66 REX.W 0F 7E /r",
          "Instruction": "MOVQ r/m64, xmm",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move quadword from xmm register to r/m64."
        },
        {
          "Opcode": "VEX.128.66.0F.W1 6E /r",
          "Instruction": "VMOVQ xmm1, r64/m64",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move quadword from r/m64 to xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.W1 7E /r",
          "Instruction": "VMOVQ r64/m64, xmm1",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move quadword from xmm1 register to r/m64."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 6E /r",
          "Instruction": "VMOVQ xmm1, r64/m64",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move quadword from r/m64 to xmm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 7E /r",
          "Instruction": "VMOVQ r64/m64, xmm1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move quadword from xmm1 register to r/m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVQ",
      "UniqueName": "movq_2",
      "Description": "Move Quadword",
      "Url": "https://www.felixcloutier.com/x86/MOVQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 6F /r",
          "Instruction": "MOVQ mm, mm/m64",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move quadword from mm/m64 to mm."
        },
        {
          "Opcode": "NP 0F 7F /r",
          "Instruction": "MOVQ mm/m64, mm",
          "CpuidFeatureFlag": "MMX",
          "Description": "Move quadword from mm to mm/m64."
        },
        {
          "Opcode": "F3 0F 7E /r",
          "Instruction": "MOVQ xmm1, xmm2/m64",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move quadword from xmm2/mem64 to xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 7E /r",
          "Instruction": "VMOVQ xmm1, xmm2/m64",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move quadword from xmm2 to xmm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W1 7E /r",
          "Instruction": "VMOVQ xmm1, xmm2/m64",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move quadword from xmm2/m64 to xmm1."
        },
        {
          "Opcode": "66 0F D6 /r",
          "Instruction": "MOVQ xmm2/m64, xmm1",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move quadword from xmm1 to xmm2/mem64."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG D6 /r",
          "Instruction": "VMOVQ xmm1/m64, xmm2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move quadword from xmm2 register to xmm1/m64."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 D6 /r",
          "Instruction": "VMOVQ xmm1/m64, xmm2",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move quadword from xmm2 register to xmm1/m64."
        }
      ]
    },
    {
      "Mnemonic": "MOVQ2DQ",
      "Description": "Move Quadword from MMX Technology to XMM Register",
      "Url": "https://www.felixcloutier.com/x86/MOVQ2DQ.html",
      "Table": [
        {
          "Opcode": "F3 0F D6 /r",
          "Instruction": "MOVQ2DQ xmm, mm",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move quadword from mmx to low quadword of xmm."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVS",
      "Description": "Move Data from String to String",
      "Url": "https://www.felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html",
      "Table": [
        {
          "Opcode": "A4",
          "Instruction": "MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A4",
          "Instruction": "MOVSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "MOVSB",
      "Description": "Move Data from String to String",
      "Url": "https://www.felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html",
      "Table": [
        {
          "Opcode": "A4",
          "Instruction": "MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A4",
          "Instruction": "MOVSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "MOVSD",
      "Description": "Move Data from String to String",
      "Url": "https://www.felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html",
      "Table": [
        {
          "Opcode": "A4",
          "Instruction": "MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A4",
          "Instruction": "MOVSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "MOVSD",
      "UniqueName": "movsd_fp",
      "Description": "Move or Merge Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MOVSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 10 /r",
          "Instruction": "MOVSD xmm1, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move scalar double-precision floating-point value from xmm2 to xmm1 register."
        },
        {
          "Opcode": "F2 0F 10 /r",
          "Instruction": "MOVSD xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Load scalar double-precision floating-point value from m64 to xmm1 register."
        },
        {
          "Opcode": "F2 0F 11 /r",
          "Instruction": "MOVSD xmm1/m64, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move scalar double-precision floating-point value from xmm2 register to xmm1/m64."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 10 /r",
          "Instruction": "VMOVSD xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge scalar double-precision floating-point value from xmm2 and xmm3 to xmm1 register."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.WIG 10 /r",
          "Instruction": "VMOVSD xmm1, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Load scalar double-precision floating-point value from m64 to xmm1 register."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 11 /r",
          "Instruction": "VMOVSD xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1."
        },
        {
          "Opcode": "VEX.LIG.F2.0F.WIG 11 /r",
          "Instruction": "VMOVSD m64, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Store scalar double-precision floating-point value from xmm1 register to m64."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 10 /r",
          "Instruction": "VMOVSD xmm1 {k1}{z}, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 10 /r",
          "Instruction": "VMOVSD xmm1 {k1}{z}, m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Load scalar double-precision floating-point value from m64 to xmm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 11 /r",
          "Instruction": "VMOVSD xmm1 {k1}{z}, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Merge scalar double-precision floating-point value from xmm2 and xmm3 registers to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 11 /r",
          "Instruction": "VMOVSD m64 {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Store scalar double-precision floating-point value from xmm1 register to m64 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVSHDUP",
      "Description": "Replicate Single FP Values",
      "Url": "https://www.felixcloutier.com/x86/MOVSHDUP.html",
      "Table": [
        {
          "Opcode": "F3 0F 16 /r",
          "Instruction": "MOVSHDUP xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 16 /r",
          "Instruction": "VMOVSHDUP xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move odd index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 16 /r",
          "Instruction": "VMOVSHDUP ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move odd index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 16 /r",
          "Instruction": "VMOVSHDUP xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move odd index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 16 /r",
          "Instruction": "VMOVSHDUP ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move odd index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 16 /r",
          "Instruction": "VMOVSHDUP zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move odd index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
        }
      ]
    },
    {
      "Mnemonic": "MOVSLDUP",
      "Description": "Replicate Single FP Values",
      "Url": "https://www.felixcloutier.com/x86/MOVSLDUP.html",
      "Table": [
        {
          "Opcode": "F3 0F 12 /r",
          "Instruction": "MOVSLDUP xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE3",
          "Description": "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 12 /r",
          "Instruction": "VMOVSLDUP xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move even index single-precision floating-point values from xmm2/mem and duplicate each element into xmm1."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 12 /r",
          "Instruction": "VMOVSLDUP ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move even index single-precision floating-point values from ymm2/mem and duplicate each element into ymm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 12 /r",
          "Instruction": "VMOVSLDUP xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move even index single-precision floating-point values from xmm2/m128 and duplicate each element into xmm1 under writemask."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 12 /r",
          "Instruction": "VMOVSLDUP ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move even index single-precision floating-point values from ymm2/m256 and duplicate each element into ymm1 under writemask."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 12 /r",
          "Instruction": "VMOVSLDUP zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move even index single-precision floating-point values from zmm2/m512 and duplicate each element into zmm1 under writemask."
        }
      ]
    },
    {
      "Mnemonic": "MOVSQ",
      "Description": "Move Data from String to String",
      "Url": "https://www.felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html",
      "Table": [
        {
          "Opcode": "A4",
          "Instruction": "MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A4",
          "Instruction": "MOVSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "MOVSS",
      "Description": "Move or Merge Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MOVSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 10 /r",
          "Instruction": "MOVSS xmm1, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Merge scalar single-precision floating-point value from xmm2 to xmm1 register."
        },
        {
          "Opcode": "F3 0F 10 /r",
          "Instruction": "MOVSS xmm1, m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Load scalar single-precision floating-point value from m32 to xmm1 register."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 10 /r",
          "Instruction": "VMOVSS xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register"
        },
        {
          "Opcode": "VEX.LIG.F3.0F.WIG 10 /r",
          "Instruction": "VMOVSS xmm1, m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Load scalar single-precision floating-point value from m32 to xmm1 register."
        },
        {
          "Opcode": "F3 0F 11 /r",
          "Instruction": "MOVSS xmm2/m32, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move scalar single-precision floating-point value from xmm1 register to xmm2/m32."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 11 /r",
          "Instruction": "VMOVSS xmm1, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register."
        },
        {
          "Opcode": "VEX.LIG.F3.0F.WIG 11 /r",
          "Instruction": "VMOVSS m32, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move scalar single-precision floating-point value from xmm1 register to m32."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 10 /r",
          "Instruction": "VMOVSS xmm1 {k1}{z}, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 10 /r",
          "Instruction": "VMOVSS xmm1 {k1}{z}, m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move scalar single-precision floating-point values from m32 to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 11 /r",
          "Instruction": "VMOVSS xmm1 {k1}{z}, xmm2, xmm3",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move scalar single-precision floating-point value from xmm2 and xmm3 to xmm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 11 /r",
          "Instruction": "VMOVSS m32 {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move scalar single-precision floating-point values from xmm1 to m32 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVSW",
      "Description": "Move Data from String to String",
      "Url": "https://www.felixcloutier.com/x86/MOVS:MOVSB:MOVSW:MOVSD:MOVSQ.html",
      "Table": [
        {
          "Opcode": "A4",
          "Instruction": "MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A4",
          "Instruction": "MOVSB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, Move byte from address DS:(E)SI to ES:(E)DI. For 64-bit mode move byte from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move word from address DS:(E)SI to ES:(E)DI. For 64-bit mode move word at address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "A5",
          "Instruction": "MOVSD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, move dword from address DS:(E)SI to ES:(E)DI. For 64-bit mode move dword from address (R|E)SI to (R|E)DI."
        },
        {
          "Opcode": "REX.W + A5",
          "Instruction": "MOVSQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move qword from address (R|E)SI to (R|E)DI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "MOVSX",
      "Description": "Move with Sign-Extension",
      "Url": "https://www.felixcloutier.com/x86/MOVSX:MOVSXD.html",
      "Table": [
        {
          "Opcode": "0F BE /r",
          "Instruction": "MOVSX r16, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to word with sign-extension."
        },
        {
          "Opcode": "0F BE /r",
          "Instruction": "MOVSX r32, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to doubleword with sign-extension."
        },
        {
          "Opcode": "REX.W + 0F BE /r",
          "Instruction": "MOVSX r64, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move byte to quadword with sign-extension."
        },
        {
          "Opcode": "0F BF /r",
          "Instruction": "MOVSX r32, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move word to doubleword, with sign-extension."
        },
        {
          "Opcode": "REX.W + 0F BF /r",
          "Instruction": "MOVSX r64, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move word to quadword with sign-extension."
        },
        {
          "Opcode": "63 /r*",
          "Instruction": "MOVSXD r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move word to word with sign-extension."
        },
        {
          "Opcode": "63 /r*",
          "Instruction": "MOVSXD r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move doubleword to doubleword with sign-extension."
        },
        {
          "Opcode": "REX.W + 63 /r",
          "Instruction": "MOVSXD r64, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move doubleword to quadword with sign-extension."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVSXD",
      "Description": "Move with Sign-Extension",
      "Url": "https://www.felixcloutier.com/x86/MOVSX:MOVSXD.html",
      "Table": [
        {
          "Opcode": "0F BE /r",
          "Instruction": "MOVSX r16, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to word with sign-extension."
        },
        {
          "Opcode": "0F BE /r",
          "Instruction": "MOVSX r32, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to doubleword with sign-extension."
        },
        {
          "Opcode": "REX.W + 0F BE /r",
          "Instruction": "MOVSX r64, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move byte to quadword with sign-extension."
        },
        {
          "Opcode": "0F BF /r",
          "Instruction": "MOVSX r32, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move word to doubleword, with sign-extension."
        },
        {
          "Opcode": "REX.W + 0F BF /r",
          "Instruction": "MOVSX r64, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move word to quadword with sign-extension."
        },
        {
          "Opcode": "63 /r*",
          "Instruction": "MOVSXD r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move word to word with sign-extension."
        },
        {
          "Opcode": "63 /r*",
          "Instruction": "MOVSXD r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move doubleword to doubleword with sign-extension."
        },
        {
          "Opcode": "REX.W + 63 /r",
          "Instruction": "MOVSXD r64, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move doubleword to quadword with sign-extension."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MOVUPD",
      "Description": "Move Unaligned Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVUPD.html",
      "Table": [
        {
          "Opcode": "66 0F 10 /r",
          "Instruction": "MOVUPD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
        },
        {
          "Opcode": "66 0F 11 /r",
          "Instruction": "MOVUPD xmm2/m128, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 10 /r",
          "Instruction": "VMOVUPD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed double-precision floating-point from xmm2/mem to xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 11 /r",
          "Instruction": "VMOVUPD xmm2/m128, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 10 /r",
          "Instruction": "VMOVUPD ymm1, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed double-precision floating-point from ymm2/mem to ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 11 /r",
          "Instruction": "VMOVUPD ymm2/m256, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed double-precision floating-point from ymm1 to ymm2/mem."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 10 /r",
          "Instruction": "VMOVUPD xmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed double-precision floating-point from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 11 /r",
          "Instruction": "VMOVUPD xmm2/m128 {k1}{z}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed double-precision floating-point from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 10 /r",
          "Instruction": "VMOVUPD ymm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed double-precision floating-point from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 11 /r",
          "Instruction": "VMOVUPD ymm2/m256 {k1}{z}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed double-precision floating-point from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 10 /r",
          "Instruction": "VMOVUPD zmm1 {k1}{z}, zmm2/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 11 /r",
          "Instruction": "VMOVUPD zmm2/m512 {k1}{z}, zmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed double-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVUPS",
      "Description": "Move Unaligned Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MOVUPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 10 /r",
          "Instruction": "MOVUPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
        },
        {
          "Opcode": "NP 0F 11 /r",
          "Instruction": "MOVUPS xmm2/m128, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.128.0F.WIG 10 /r",
          "Instruction": "VMOVUPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed single-precision floating-point from xmm2/mem to xmm1."
        },
        {
          "Opcode": "VEX.128.0F.WIG 11 /r",
          "Instruction": "VMOVUPS xmm2/m128, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed single-precision floating-point from xmm1 to xmm2/mem."
        },
        {
          "Opcode": "VEX.256.0F.WIG 10 /r",
          "Instruction": "VMOVUPS ymm1, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed single-precision floating-point from ymm2/mem to ymm1."
        },
        {
          "Opcode": "VEX.256.0F.WIG 11 /r",
          "Instruction": "VMOVUPS ymm2/m256, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move unaligned packed single-precision floating-point from ymm1 to ymm2/mem."
        },
        {
          "Opcode": "EVEX.128.0F.W0 10 /r",
          "Instruction": "VMOVUPS xmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 10 /r",
          "Instruction": "VMOVUPS ymm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 10 /r",
          "Instruction": "VMOVUPS zmm1 {k1}{z}, zmm2/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.0F.W0 11 /r",
          "Instruction": "VMOVUPS xmm2/m128 {k1}{z}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 11 /r",
          "Instruction": "VMOVUPS ymm2/m256 {k1}{z}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 11 /r",
          "Instruction": "VMOVUPS zmm2/m512 {k1}{z}, zmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed single-precision floating-point values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "MOVZX",
      "Description": "Move with Zero-Extend",
      "Url": "https://www.felixcloutier.com/x86/MOVZX.html",
      "Table": [
        {
          "Opcode": "0F B6 /r",
          "Instruction": "MOVZX r16, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to word with zero-extension."
        },
        {
          "Opcode": "0F B6 /r",
          "Instruction": "MOVZX r32, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move byte to doubleword, zero-extension."
        },
        {
          "Opcode": "REX.W + 0F B6 /r",
          "Instruction": "MOVZX r64, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move byte to quadword, zero-extension."
        },
        {
          "Opcode": "0F B7 /r",
          "Instruction": "MOVZX r32, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Move word to doubleword, zero-extension."
        },
        {
          "Opcode": "REX.W + 0F B7 /r",
          "Instruction": "MOVZX r64, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Move word to quadword, zero-extension."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MPSADBW",
      "Description": "Compute Multiple Packed Sums of Absolute Difference",
      "Url": "https://www.felixcloutier.com/x86/MPSADBW.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 42 /r ib",
          "Instruction": "MPSADBW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm1 and xmm2/m128 and writes the results in xmm1. Starting offsets within xmm1 and xmm2/m128 are determined by imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 42 /r ib",
          "Instruction": "VMPSADBW xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and xmm3/m128 and writes the results in xmm1. Starting offsets within xmm2 and xmm3/m128 are determined by imm8."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 42 /r ib",
          "Instruction": "VMPSADBW ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sums absolute 8-bit integer difference of adjacent groups of 4 byte integers in xmm2 and ymm3/m128 and writes the results in ymm1. Starting offsets within ymm2 and xmm3/m128 are determined by imm8."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MUL",
      "Description": "Unsigned Multiply",
      "Url": "https://www.felixcloutier.com/x86/MUL.html",
      "Table": [
        {
          "Opcode": "F6 /4",
          "Instruction": "MUL r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned multiply (AX ← AL ∗ r/m8)."
        },
        {
          "Opcode": "REX + F6 /4",
          "Instruction": "MUL r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned multiply (AX ← AL ∗ r/m8)."
        },
        {
          "Opcode": "F7 /4",
          "Instruction": "MUL r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned multiply (DX:AX ← AX ∗ r/m16)."
        },
        {
          "Opcode": "F7 /4",
          "Instruction": "MUL r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Unsigned multiply (EDX:EAX ← EAX ∗ r/m32)."
        },
        {
          "Opcode": "REX.W + F7 /4",
          "Instruction": "MUL r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned multiply (RDX:RAX ← RAX ∗ r/m64)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MULPD",
      "Description": "Multiply Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MULPD.html",
      "Table": [
        {
          "Opcode": "66 0F 59 /r",
          "Instruction": "MULPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply packed double-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 59 /r",
          "Instruction": "VMULPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed double-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 59 /r",
          "Instruction": "VMULPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed double-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 59 /r",
          "Instruction": "VMULPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 59 /r",
          "Instruction": "VMULPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 59 /r",
          "Instruction": "VMULPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values in zmm3/m512/m64bcst with zmm2 and store result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "MULPS",
      "Description": "Multiply Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MULPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 59 /r",
          "Instruction": "MULPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Multiply packed single-precision floating-point values in xmm2/m128 with xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 59 /r",
          "Instruction": "VMULPS xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed single-precision floating-point values in xmm3/m128 with xmm2 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 59 /r",
          "Instruction": "VMULPS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed single-precision floating-point values in ymm3/m256 with ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 59 /r",
          "Instruction": "VMULPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and store result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 59 /r",
          "Instruction": "VMULPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 59 /r",
          "Instruction": "VMULPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst {er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values in zmm3/m512/m32bcst with zmm2 and store result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "MULSD",
      "Description": "Multiply Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/MULSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 59 /r",
          "Instruction": "MULSD xmm1,xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply the low double-precision floating-point value in xmm2/m64 by low double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 59 /r",
          "Instruction": "VMULSD xmm1,xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 59 /r",
          "Instruction": "VMULSD xmm1 {k1}{z}, xmm2, xmm3/m64 {er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply the low double-precision floating-point value in xmm3/m64 by low double-precision floating-point value in xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MULSS",
      "Description": "Multiply Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/MULSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 59 /r",
          "Instruction": "MULSS xmm1,xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Multiply the low single-precision floating-point value in xmm2/m32 by the low single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 59 /r",
          "Instruction": "VMULSS xmm1,xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 59 /r",
          "Instruction": "VMULSS xmm1 {k1}{z}, xmm2, xmm3/m32 {er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply the low single-precision floating-point value in xmm3/m32 by the low single-precision floating-point value in xmm2."
        }
      ]
    },
    {
      "Mnemonic": "MULX",
      "Description": "Unsigned Multiply Without Affecting Flags",
      "Url": "https://www.felixcloutier.com/x86/MULX.html",
      "Table": [
        {
          "Opcode": "VEX.NDD.LZ.F2.0F38.W0 F6 /r",
          "Instruction": "MULX r32a, r32b, r/m32",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Unsigned multiply of r/m32 with EDX without affecting arithmetic flags."
        },
        {
          "Opcode": "VEX.NDD.LZ.F2.0F38.W1 F6 /r",
          "Instruction": "MULX r64a, r64b, r/m64",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Unsigned multiply of r/m64 with RDX without affecting arithmetic flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (w)",
            "ModRM:r/m (r)",
            "RDX/EDX is implied 64/32 bits source"
          ]
        }
      ]
    },
    {
      "Mnemonic": "MWAIT",
      "Description": "Monitor Wait",
      "Url": "https://www.felixcloutier.com/x86/MWAIT.html",
      "Table": [
        {
          "Opcode": "0F 01 C9",
          "Instruction": "MWAIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "A hint that allows the processor to stop instruction execution and enter an implementation-dependent optimized state until occurrence of a class of events."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "NEG",
      "Description": "Two's Complement Negation",
      "Url": "https://www.felixcloutier.com/x86/NEG.html",
      "Table": [
        {
          "Opcode": "F6 /3",
          "Instruction": "NEG r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Two's complement negate r/m8."
        },
        {
          "Opcode": "REX + F6 /3",
          "Instruction": "NEG r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Two's complement negate r/m8."
        },
        {
          "Opcode": "F7 /3",
          "Instruction": "NEG r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Two's complement negate r/m16."
        },
        {
          "Opcode": "F7 /3",
          "Instruction": "NEG r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Two's complement negate r/m32."
        },
        {
          "Opcode": "REX.W + F7 /3",
          "Instruction": "NEG r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Two's complement negate r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "NOP",
      "Description": "No Operation",
      "Url": "https://www.felixcloutier.com/x86/NOP.html",
      "Table": [
        {
          "Opcode": "NP 90",
          "Instruction": "NOP",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "One byte no-operation instruction."
        },
        {
          "Opcode": "NP 0F 1F /0",
          "Instruction": "NOP r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Multi-byte no-operation instruction."
        },
        {
          "Opcode": "NP 0F 1F /0",
          "Instruction": "NOP r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Multi-byte no-operation instruction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "NOT",
      "Description": "One's Complement Negation",
      "Url": "https://www.felixcloutier.com/x86/NOT.html",
      "Table": [
        {
          "Opcode": "F6 /2",
          "Instruction": "NOT r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Reverse each bit of r/m8."
        },
        {
          "Opcode": "REX + F6 /2",
          "Instruction": "NOT r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Reverse each bit of r/m8."
        },
        {
          "Opcode": "F7 /2",
          "Instruction": "NOT r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Reverse each bit of r/m16."
        },
        {
          "Opcode": "F7 /2",
          "Instruction": "NOT r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Reverse each bit of r/m32."
        },
        {
          "Opcode": "REX.W + F7 /2",
          "Instruction": "NOT r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Reverse each bit of r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "OR",
      "Description": "Logical Inclusive OR",
      "Url": "https://www.felixcloutier.com/x86/OR.html",
      "Table": [
        {
          "Opcode": "0C ib",
          "Instruction": "OR AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AL OR imm8."
        },
        {
          "Opcode": "0D iw",
          "Instruction": "OR AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AX OR imm16."
        },
        {
          "Opcode": "0D id",
          "Instruction": "OR EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "EAX OR imm32."
        },
        {
          "Opcode": "REX.W + 0D id",
          "Instruction": "OR RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "RAX OR imm32 (sign-extended)."
        },
        {
          "Opcode": "80 /1 ib",
          "Instruction": "OR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m8 OR imm8."
        },
        {
          "Opcode": "REX + 80 /1 ib",
          "Instruction": "OR r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m8 OR imm8."
        },
        {
          "Opcode": "81 /1 iw",
          "Instruction": "OR r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m16 OR imm16."
        },
        {
          "Opcode": "81 /1 id",
          "Instruction": "OR r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m32 OR imm32."
        },
        {
          "Opcode": "REX.W + 81 /1 id",
          "Instruction": "OR r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 OR imm32 (sign-extended)."
        },
        {
          "Opcode": "83 /1 ib",
          "Instruction": "OR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m16 OR imm8 (sign-extended)."
        },
        {
          "Opcode": "83 /1 ib",
          "Instruction": "OR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m32 OR imm8 (sign-extended)."
        },
        {
          "Opcode": "REX.W + 83 /1 ib",
          "Instruction": "OR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 OR imm8 (sign-extended)."
        },
        {
          "Opcode": "08 /r",
          "Instruction": "OR r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m8 OR r8."
        },
        {
          "Opcode": "REX + 08 /r",
          "Instruction": "OR r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "r/m8 OR r8."
        },
        {
          "Opcode": "09 /r",
          "Instruction": "OR r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m16 OR r16."
        },
        {
          "Opcode": "09 /r",
          "Instruction": "OR r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m32 OR r32."
        },
        {
          "Opcode": "REX.W + 09 /r",
          "Instruction": "OR r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 OR r64."
        },
        {
          "Opcode": "0A /r",
          "Instruction": "OR r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r8 OR r/m8."
        },
        {
          "Opcode": "REX + 0A /r",
          "Instruction": "OR r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "r8 OR r/m8."
        },
        {
          "Opcode": "0B /r",
          "Instruction": "OR r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r16 OR r/m16."
        },
        {
          "Opcode": "0B /r",
          "Instruction": "OR r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r32 OR r/m32."
        },
        {
          "Opcode": "REX.W + 0B /r",
          "Instruction": "OR r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "r64 OR r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ORPD",
      "Description": "Bitwise Logical OR of Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ORPD.html",
      "Table": [
        {
          "Opcode": "66 0F 56/r",
          "Instruction": "ORPD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F 56 /r",
          "Instruction": "VORPD xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F 56 /r",
          "Instruction": "VORPD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 56 /r",
          "Instruction": "VORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 56 /r",
          "Instruction": "VORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 56 /r",
          "Instruction": "VORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical OR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "ORPS",
      "Description": "Bitwise Logical OR of Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ORPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 56 /r",
          "Instruction": "ORPS xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F 56 /r",
          "Instruction": "VORPS xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F 56 /r",
          "Instruction": "VORPS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 56 /r",
          "Instruction": "VORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 56 /r",
          "Instruction": "VORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 56 /r",
          "Instruction": "VORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical OR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "OUT",
      "UniqueName": "@out",
      "Description": "Output to Port",
      "Url": "https://www.felixcloutier.com/x86/OUT.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8"
          ]
        },
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "OUTS",
      "Description": "Output String to Port",
      "Url": "https://www.felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "OUTSB",
      "Description": "Output String to Port",
      "Url": "https://www.felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "OUTSD",
      "Description": "Output String to Port",
      "Url": "https://www.felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "OUTSW",
      "Description": "Output String to Port",
      "Url": "https://www.felixcloutier.com/x86/OUTS:OUTSB:OUTSW:OUTSD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PABSB",
      "Description": "Packed Absolute Value",
      "Url": "https://www.felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 1C /r1",
          "Instruction": "PABSB mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of bytes in mm2/m64 and store UNSIGNED result in mm1."
        },
        {
          "Opcode": "66 0F 38 1C /r",
          "Instruction": "PABSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 1C /r",
          "Instruction": "VPABSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 1C /r",
          "Instruction": "VPABSB ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 1C /r",
          "Instruction": "VPABSB xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compute the absolute value of bytes in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 1C /r",
          "Instruction": "VPABSB ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compute the absolute value of bytes in ymm2/m256 and store UNSIGNED result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 1C /r",
          "Instruction": "VPABSB zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compute the absolute value of bytes in zmm2/m512 and store UNSIGNED result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PABSD",
      "Description": "Packed Absolute Value",
      "Url": "https://www.felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 1E /r1",
          "Instruction": "PABSD mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of 32-bit integers in mm2/m64 and store UNSIGNED result in mm1."
        },
        {
          "Opcode": "66 0F 38 1E /r",
          "Instruction": "PABSD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of 32-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 1E /r",
          "Instruction": "VPABSD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compute the absolute value of 32- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 1E /r",
          "Instruction": "VPABSD ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compute the absolute value of 32-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
        }
      ]
    },
    {
      "Mnemonic": "PABSQ",
      "Description": "Packed Absolute Value",
      "Url": "https://www.felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html",
      "Table": []
    },
    {
      "Mnemonic": "PABSW",
      "Description": "Packed Absolute Value",
      "Url": "https://www.felixcloutier.com/x86/PABSB:PABSW:PABSD:PABSQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 1D /r1",
          "Instruction": "PABSW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of 16-bit integers in mm2/m64 and store UNSIGNED result in mm1."
        },
        {
          "Opcode": "66 0F 38 1D /r",
          "Instruction": "PABSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 1D /r",
          "Instruction": "VPABSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compute the absolute value of 16- bit integers in xmm2/m128 and store UNSIGNED result in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 1D /r",
          "Instruction": "VPABSW ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compute the absolute value of 16-bit integers in ymm2/m256 and store UNSIGNED result in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 1D /r",
          "Instruction": "VPABSW xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compute the absolute value of 16-bit integers in xmm2/m128 and store UNSIGNED result in xmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PACKSSDW",
      "Description": "Pack with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PACKSSWB:PACKSSDW.html",
      "Table": [
        {
          "Opcode": "NP 0F 6B /r1",
          "Instruction": "PACKSSDW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Converts 2 packed signed doubleword integers from mm1 and from mm2/m64 into 4 packed signed word integers in mm1 using signed saturation."
        },
        {
          "Opcode": "66 0F 6B /r",
          "Instruction": "PACKSSDW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Converts 4 packed signed doubleword integers from xmm1 and from xxm2/m128 into 8 packed signed word integers in xxm1 using signed saturation."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 6B /r",
          "Instruction": "VPACKSSDW xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Converts 4 packed signed doubleword integers from xmm2 and from xmm3/m128 into 8 packed signed word integers in xmm1 using signed saturation."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 6B /r",
          "Instruction": "VPACKSSDW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Converts 8 packed signed doubleword integers from ymm2 and from ymm3/m256 into 16 packed signed word integers in ymm1using signed saturation."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 6B /r",
          "Instruction": "VPACKSSDW xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts packed signed doubleword integers from xmm2 and from xmm3/m128/m32bcst into packed signed word integers in xmm1 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PACKSSWB",
      "Description": "Pack with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PACKSSWB:PACKSSDW.html",
      "Table": [
        {
          "Opcode": "NP 0F 63 /r1",
          "Instruction": "PACKSSWB mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Converts 4 packed signed word integers from mm1 and from mm2/m64 into 8 packed signed byte integers in mm1 using signed saturation."
        },
        {
          "Opcode": "66 0F 63 /r",
          "Instruction": "PACKSSWB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Converts 8 packed signed word integers from xmm1 and from xxm2/m128 into 16 packed signed byte integers in xxm1 using signed saturation."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 63 /r",
          "Instruction": "VPACKSSWB xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Converts 8 packed signed word integers from xmm2 and from xmm3/m128 into 16 packed signed byte integers in xmm1 using signed saturation."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 63 /r",
          "Instruction": "VPACKSSWB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Converts 16 packed signed word integers from ymm2 and from ymm3/m256 into 32 packed signed byte integers in ymm1 using signed saturation."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 63 /r",
          "Instruction": "VPACKSSWB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts packed signed word integers from xmm2 and from xmm3/m128 into packed signed byte integers in xmm1 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG 63 /r",
          "Instruction": "VPACKSSWB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts packed signed word integers from ymm2 and from ymm3/m256 into packed signed byte integers in ymm1 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG 63 /r",
          "Instruction": "VPACKSSWB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Converts packed signed word integers from zmm2 and from zmm3/m512 into packed signed byte integers in zmm1 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PACKUSDW",
      "Description": "Pack with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PACKUSDW.html",
      "Table": [
        {
          "Opcode": "66 0F 38 2B /r",
          "Instruction": "PACKUSDW xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Convert 4 packed signed doubleword integers from xmm1 and 4 packed signed doubleword integers from xmm2/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38 2B /r",
          "Instruction": "VPACKUSDW xmm1,xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Convert 4 packed signed doubleword integers from xmm2 and 4 packed signed doubleword integers from xmm3/m128 into 8 packed unsigned word integers in xmm1 using unsigned saturation."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38 2B /r",
          "Instruction": "VPACKUSDW ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Convert 8 packed signed doubleword integers from ymm2 and 8 packed signed doubleword integers from ymm3/m256 into 16 packed unsigned word integers in ymm1 using unsigned saturation."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 2B /r",
          "Instruction": "VPACKUSDW xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Convert packed signed doubleword integers from xmm2 and packed signed doubleword integers from xmm3/m128/m32bcst into packed unsigned word integers in xmm1 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 2B /r",
          "Instruction": "VPACKUSDW ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Convert packed signed doubleword integers from ymm2 and packed signed doubleword integers from ymm3/m256/m32bcst into packed unsigned word integers in ymm1 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 2B /r",
          "Instruction": "VPACKUSDW zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Convert packed signed doubleword integers from zmm2 and packed signed doubleword integers from zmm3/m512/m32bcst into packed unsigned word integers in zmm1 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PACKUSWB",
      "Description": "Pack with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PACKUSWB.html",
      "Table": [
        {
          "Opcode": "NP 0F 67 /r1",
          "Instruction": "PACKUSWB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Converts 4 signed word integers from mm and 4 signed word integers from mm/m64 into 8 unsigned byte integers in mm using unsigned saturation."
        },
        {
          "Opcode": "66 0F 67 /r",
          "Instruction": "PACKUSWB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Converts 8 signed word integers from xmm1 and 8 signed word integers from xmm2/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 67 /r",
          "Instruction": "VPACKUSWB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Converts 8 signed word integers from xmm2 and 8 signed word integers from xmm3/m128 into 16 unsigned byte integers in xmm1 using unsigned saturation."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 67 /r",
          "Instruction": "VPACKUSWB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Converts 16 signed word integers from ymm2 and 16signed word integers from ymm3/m256 into 32 unsigned byte integers in ymm1 using unsigned saturation."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 67 /r",
          "Instruction": "VPACKUSWB xmm1{k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts signed word integers from xmm2 and signed word integers from xmm3/m128 into unsigned byte integers in xmm1 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG 67 /r",
          "Instruction": "VPACKUSWB ymm1{k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts signed word integers from ymm2 and signed word integers from ymm3/m256 into unsigned byte integers in ymm1 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG 67 /r",
          "Instruction": "VPACKUSWB zmm1{k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Converts signed word integers from zmm2 and signed word integers from zmm3/m512 into unsigned byte integers in zmm1 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDB",
      "Description": "Add Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F FC /r1",
          "Instruction": "PADDB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed byte integers from mm/m64 and mm."
        },
        {
          "Opcode": "66 0F FC /r",
          "Instruction": "PADDB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed byte integers from xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG FC /r",
          "Instruction": "VPADDB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG FC /r",
          "Instruction": "VPADDB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG FC /r",
          "Instruction": "VPADDB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed byte integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG FC /r",
          "Instruction": "VPADDB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed byte integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG FC /r",
          "Instruction": "VPADDB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add packed byte integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDD",
      "Description": "Add Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F FE /r1",
          "Instruction": "PADDD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed doubleword integers from mm/m64 and mm."
        },
        {
          "Opcode": "66 0F FE /r",
          "Instruction": "PADDD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed doubleword integers from xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG FE /r",
          "Instruction": "VPADDD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed doubleword integers from xmm2, xmm3/m128 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG FE /r",
          "Instruction": "VPADDD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed doubleword integers from ymm2, ymm3/m256 and store in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 FE /r",
          "Instruction": "VPADDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed doubleword integers from xmm2, and xmm3/m128/m32bcst and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 FE /r",
          "Instruction": "VPADDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed doubleword integers from ymm2, ymm3/m256/m32bcst and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 FE /r",
          "Instruction": "VPADDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add packed doubleword integers from zmm2, zmm3/m512/m32bcst and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDQ",
      "Description": "Add Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F D4 /r1",
          "Instruction": "PADDQ mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed quadword integers from mm/m64 and mm."
        },
        {
          "Opcode": "66 0F D4 /r",
          "Instruction": "PADDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed quadword integers from xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D4 /r",
          "Instruction": "VPADDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed quadword integers from xmm2, xmm3/m128 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D4 /r",
          "Instruction": "VPADDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed quadword integers from ymm2, ymm3/m256 and store in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 D4 /r",
          "Instruction": "VPADDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed quadword integers from xmm2, and xmm3/m128/m64bcst and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 D4 /r",
          "Instruction": "VPADDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Add packed quadword integers from ymm2, ymm3/m256/m64bcst and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 D4 /r",
          "Instruction": "VPADDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Add packed quadword integers from zmm2, zmm3/m512/m64bcst and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDSB",
      "Description": "Add Packed Signed Integers with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PADDSB:PADDSW.html",
      "Table": [
        {
          "Opcode": "NP 0F EC /r1",
          "Instruction": "PADDSB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed signed byte integers from mm/m64 and mm and saturate the results."
        },
        {
          "Opcode": "66 0F EC /r",
          "Instruction": "PADDSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed signed byte integers from xmm2/m128 and xmm1 saturate the results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG EC /r",
          "Instruction": "VPADDSB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed signed byte integers from xmm3/m128 and xmm2 saturate the results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG EC /r",
          "Instruction": "VPADDSB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG EC /r",
          "Instruction": "VPADDSB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed signed byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG EC /r",
          "Instruction": "VPADDSB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed signed byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG EC /r",
          "Instruction": "VPADDSB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add packed signed byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDSW",
      "Description": "Add Packed Signed Integers with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PADDSB:PADDSW.html",
      "Table": [
        {
          "Opcode": "NP 0F ED /r1",
          "Instruction": "PADDSW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed signed word integers from mm/m64 and mm and saturate the results."
        },
        {
          "Opcode": "66 0F ED /r",
          "Instruction": "PADDSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed signed word integers from xmm2/m128 and xmm1 and saturate the results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG ED /r",
          "Instruction": "VPADDSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed signed word integers from xmm3/m128 and xmm2 and saturate the results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG ED /r",
          "Instruction": "VPADDSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG ED /r",
          "Instruction": "VPADDSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed signed word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG ED /r",
          "Instruction": "VPADDSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed signed word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG ED /r",
          "Instruction": "VPADDSW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add packed signed word integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDUSB",
      "Description": "Add Packed Unsigned Integers with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PADDUSB:PADDUSW.html",
      "Table": [
        {
          "Opcode": "NP 0F DC /r1",
          "Instruction": "PADDUSB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed unsigned byte integers from mm/m64 and mm and saturate the results."
        },
        {
          "Opcode": "66 0F DC /r",
          "Instruction": "PADDUSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed unsigned byte integers from xmm2/m128 and xmm1 saturate the results."
        },
        {
          "Opcode": "VEX.NDS.128.660F.WIG DC /r",
          "Instruction": "VPADDUSB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed unsigned byte integers from xmm3/m128 to xmm2 and saturate the results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG DC /r",
          "Instruction": "VPADDUSB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG DC /r",
          "Instruction": "VPADDUSB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed unsigned byte integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG DC /r",
          "Instruction": "VPADDUSB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed unsigned byte integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG DC /r",
          "Instruction": "VPADDUSB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add packed unsigned byte integers from zmm2, and zmm3/m512 and store the saturated results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDUSW",
      "Description": "Add Packed Unsigned Integers with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PADDUSB:PADDUSW.html",
      "Table": [
        {
          "Opcode": "NP 0F DD /r1",
          "Instruction": "PADDUSW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed unsigned word integers from mm/m64 and mm and saturate the results."
        },
        {
          "Opcode": "66 0F DD /r",
          "Instruction": "PADDUSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed unsigned word integers from xmm2/m128 to xmm1 and saturate the results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG DD /r",
          "Instruction": "VPADDUSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed unsigned word integers from xmm3/m128 to xmm2 and saturate the results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG DD /r",
          "Instruction": "VPADDUSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG DD /r",
          "Instruction": "VPADDUSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed unsigned word integers from xmm2, and xmm3/m128 and store the saturated results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG DD /r",
          "Instruction": "VPADDUSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed unsigned word integers from ymm2, and ymm3/m256 and store the saturated results in ymm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PADDW",
      "Description": "Add Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PADDB:PADDW:PADDD:PADDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F FD /r1",
          "Instruction": "PADDW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Add packed word integers from mm/m64 and mm."
        },
        {
          "Opcode": "66 0F FD /r",
          "Instruction": "PADDW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Add packed word integers from xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG FD /r",
          "Instruction": "VPADDW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add packed word integers from xmm2, xmm3/m128 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG FD /r",
          "Instruction": "VPADDW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add packed word integers from ymm2, ymm3/m256 and store in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG FD /r",
          "Instruction": "VPADDW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed word integers from xmm2, and xmm3/m128 and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG FD /r",
          "Instruction": "VPADDW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Add packed word integers from ymm2, and ymm3/m256 and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG FD /r",
          "Instruction": "VPADDW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Add packed word integers from zmm2, and zmm3/m512 and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PALIGNR",
      "Description": "Packed Align Right",
      "Url": "https://www.felixcloutier.com/x86/PALIGNR.html",
      "Table": [
        {
          "Opcode": "NP 0F 3A 0F /r ib1",
          "Instruction": "PALIGNR mm1, mm2/m64, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into mm1."
        },
        {
          "Opcode": "66 0F 3A 0F /r ib",
          "Instruction": "PALIGNR xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Concatenate destination and source operands, extract byte-aligned result shifted to the right by constant value in imm8 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 0F /r ib",
          "Instruction": "VPALIGNR xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Concatenate xmm2 and xmm3/m128, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 0F /r ib",
          "Instruction": "VPALIGNR ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.WIG 0F /r ib",
          "Instruction": "VPALIGNR xmm1 {k1}{z}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Concatenate xmm2 and xmm3/m128 into a 32-byte intermediate result, extract byte aligned result shifted to the right by constant value in imm8 and result is stored in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.WIG 0F /r ib",
          "Instruction": "VPALIGNR ymm1 {k1}{z}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Concatenate pairs of 16 bytes in ymm2 and ymm3/m256 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and two 16-byte results are stored in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.WIG 0F /r ib",
          "Instruction": "VPALIGNR zmm1 {k1}{z}, zmm2, zmm3/m512, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Concatenate pairs of 16 bytes in zmm2 and zmm3/m512 into 32-byte intermediate result, extract byte-aligned, 16-byte result shifted to the right by constant values in imm8 from each intermediate result, and four 16-byte results are stored in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "PAND",
      "Description": "Logical AND",
      "Url": "https://www.felixcloutier.com/x86/PAND.html",
      "Table": [
        {
          "Opcode": "NP 0F DB /r1",
          "Instruction": "PAND mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Bitwise AND mm/m64 and mm."
        },
        {
          "Opcode": "66 0F DB /r",
          "Instruction": "PAND xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Bitwise AND of xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG DB /r",
          "Instruction": "VPAND xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Bitwise AND of xmm3/m128 and xmm."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG DB /r",
          "Instruction": "VPAND ymm1, ymm2, ymm3/.m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Bitwise AND of ymm2, and ymm3/m256 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 DB /r",
          "Instruction": "VPANDD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 DB /r",
          "Instruction": "VPANDD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 DB /r",
          "Instruction": "VPANDD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 DB /r",
          "Instruction": "VPANDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 DB /r",
          "Instruction": "VPANDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 DB /r",
          "Instruction": "VPANDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PANDN",
      "Description": "Logical AND NOT",
      "Url": "https://www.felixcloutier.com/x86/PANDN.html",
      "Table": [
        {
          "Opcode": "NP 0F DF /r1",
          "Instruction": "PANDN mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Bitwise AND NOT of mm/m64 and mm."
        },
        {
          "Opcode": "66 0F DF /r",
          "Instruction": "PANDN xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Bitwise AND NOT of xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG DF /r",
          "Instruction": "VPANDN xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Bitwise AND NOT of xmm3/m128 and xmm2."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG DF /r",
          "Instruction": "VPANDN ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Bitwise AND NOT of ymm2, and ymm3/m256 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 DF /r",
          "Instruction": "VPANDND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND NOT of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and store result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 DF /r",
          "Instruction": "VPANDND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND NOT of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and store result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 DF /r",
          "Instruction": "VPANDND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND NOT of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and store result in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 DF /r",
          "Instruction": "VPANDNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND NOT of packed quadword integers in xmm2 and xmm3/m128/m64bcst and store result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 DF /r",
          "Instruction": "VPANDNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND NOT of packed quadword integers in ymm2 and ymm3/m256/m64bcst and store result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 DF /r",
          "Instruction": "VPANDNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND NOT of packed quadword integers in zmm2 and zmm3/m512/m64bcst and store result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PAUSE",
      "Description": "Spin Loop Hint",
      "Url": "https://www.felixcloutier.com/x86/PAUSE.html",
      "Table": [
        {
          "Opcode": "F3 90",
          "Instruction": "PAUSE",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Gives hint to processor that improves performance of spin-wait loops."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PAVGB",
      "Description": "Average Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PAVGB:PAVGW.html",
      "Table": [
        {
          "Opcode": "NP 0F E0 /r1",
          "Instruction": "PAVGB mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Average packed unsigned byte integers from mm2/m64 and mm1 with rounding."
        },
        {
          "Opcode": "66 0F E0, /r",
          "Instruction": "PAVGB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Average packed unsigned byte integers from xmm2/m128 and xmm1 with rounding."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E0 /r",
          "Instruction": "VPAVGB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Average packed unsigned byte integers from xmm3/m128 and xmm2 with rounding."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E0 /r",
          "Instruction": "VPAVGB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E0 /r",
          "Instruction": "VPAVGB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Average packed unsigned byte integers from xmm2, and xmm3/m128 with rounding and store to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E0 /r",
          "Instruction": "VPAVGB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Average packed unsigned byte integers from ymm2, and ymm3/m256 with rounding and store to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E0 /r",
          "Instruction": "VPAVGB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Average packed unsigned byte integers from zmm2, and zmm3/m512 with rounding and store to zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PAVGW",
      "Description": "Average Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PAVGB:PAVGW.html",
      "Table": [
        {
          "Opcode": "NP 0F E3 /r1",
          "Instruction": "PAVGW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Average packed unsigned word integers from mm2/m64 and mm1 with rounding."
        },
        {
          "Opcode": "66 0F E3 /r",
          "Instruction": "PAVGW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Average packed unsigned word integers from xmm2/m128 and xmm1 with rounding."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E3 /r",
          "Instruction": "VPAVGW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Average packed unsigned word integers from xmm3/m128 and xmm2 with rounding."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E3 /r",
          "Instruction": "VPAVGW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E3 /r",
          "Instruction": "VPAVGW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Average packed unsigned word integers from xmm2, xmm3/m128 with rounding to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E3 /r",
          "Instruction": "VPAVGW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Average packed unsigned word integers from ymm2, ymm3/m256 with rounding to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E3 /r",
          "Instruction": "VPAVGW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Average packed unsigned word integers from zmm2, zmm3/m512 with rounding to zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PBLENDVB",
      "Description": "Variable Blend Packed Bytes",
      "Url": "https://www.felixcloutier.com/x86/PBLENDVB.html",
      "Table": [
        {
          "Opcode": "66 0F 38 10 /r",
          "Instruction": "PBLENDVB xmm1, xmm2/m128, &lt;XMM0&gt;",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select byte values from xmm1 and xmm2/m128 from mask specified in the high bit of each byte in XMM0 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 4C /r /is4",
          "Instruction": "VPBLENDVB xmm1, xmm2, xmm3/m128, xmm4",
          "OperandEncoding": "RVMR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select byte values from xmm2 and xmm3/m128 using mask bits in the specified mask register, xmm4, and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 4C /r /is4",
          "Instruction": "VPBLENDVB ymm1, ymm2, ymm3/m256, ymm4",
          "OperandEncoding": "RVMR",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Select byte values from ymm2 and ymm3/m256 from mask specified in the high bit of each byte in ymm4 and store the values into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "&lt;XMM0&gt;"
          ]
        },
        {
          "OperandEncoding": "RVMR",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8[7:4]"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PBLENDW",
      "Description": "Blend Packed Words",
      "Url": "https://www.felixcloutier.com/x86/PBLENDW.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 0E /r ib",
          "Instruction": "PBLENDW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Select words from xmm1 and xmm2/m128 from mask specified in imm8 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 0E /r ib",
          "Instruction": "VPBLENDW xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select words from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.WIG 0E /r ib",
          "Instruction": "VPBLENDW ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Select words from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PCLMULQDQ",
      "Description": "Carry-Less Multiplication Quadword",
      "Url": "https://www.felixcloutier.com/x86/PCLMULQDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 44 /r ib",
          "Instruction": "PCLMULQDQ xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "PCLMULQDQ",
          "Description": "Carry-less multiplication of one quadword of xmm1 by one quadword of xmm2/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm1 and xmm2/m128 should be used."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.WIG 44 /r ib",
          "Instruction": "VPCLMULQDQ xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "Both PCLMULQDQ and AVX flags",
          "Description": "Carry-less multiplication of one quadword of xmm2 by one quadword of xmm3/m128, stores the 128-bit result in xmm1. The immediate is used to determine which quadwords of xmm2 and xmm3/m128 should be used."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PCMPEQB",
      "Description": "Compare Packed Data for Equal",
      "Url": "https://www.felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html",
      "Table": [
        {
          "Opcode": "NP 0F 74 /r1",
          "Instruction": "PCMPEQB mm, mm/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed bytes in mm/m64 and mm for equality."
        },
        {
          "Opcode": "66 0F 74 /r",
          "Instruction": "PCMPEQB xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed bytes in xmm2/m128 and xmm1 for equality."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 74 /r",
          "Instruction": "VPCMPEQB xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed bytes in xmm3/m128 and xmm2 for equality."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 74 /r",
          "Instruction": "VPCMPEQB ymm1, ymm2, ymm3 /m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed bytes in ymm3/m256 and ymm2 for equality."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 74 /r",
          "Instruction": "VPCMPEQB k1 {k2}, xmm2, xmm3 /m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed bytes in xmm3/m128 and xmm2 for equality and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "PCMPEQD",
      "Description": "Compare Packed Data for Equal",
      "Url": "https://www.felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html",
      "Table": [
        {
          "Opcode": "NP 0F 76 /r1",
          "Instruction": "PCMPEQD mm, mm/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed doublewords in mm/m64 and mm for equality."
        },
        {
          "Opcode": "66 0F 76 /r",
          "Instruction": "PCMPEQD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed doublewords in xmm2/m128 and xmm1 for equality."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 76 /r",
          "Instruction": "VPCMPEQD xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed doublewords in xmm3/m128 and xmm2 for equality."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 76 /r",
          "Instruction": "VPCMPEQD ymm1, ymm2, ymm3 /m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed doublewords in ymm3/m256 and ymm2 for equality."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 76 /r",
          "Instruction": "VPCMPEQD k1 {k2}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Equal between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 76 /r",
          "Instruction": "VPCMPEQD k1 {k2}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Equal between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 76 /r",
          "Instruction": "VPCMPEQD k1 {k2}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare Equal between int32 vectors in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask k2."
        }
      ]
    },
    {
      "Mnemonic": "PCMPEQQ",
      "Description": "Compare Packed Qword Data for Equal",
      "Url": "https://www.felixcloutier.com/x86/PCMPEQQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 29 /r",
          "Instruction": "PCMPEQQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed qwords in xmm2/m128 and xmm1 for equality."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 29 /r",
          "Instruction": "VPCMPEQQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed quadwords in xmm3/m128 and xmm2 for equality."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 29 /r",
          "Instruction": "VPCMPEQQ ymm1, ymm2, ymm3 /m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed quadwords in ymm3/m256 and ymm2 for equality."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 29 /r",
          "Instruction": "VPCMPEQQ k1 {k2}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Equal between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 29 /r",
          "Instruction": "VPCMPEQQ k1 {k2}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Equal between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 29 /r",
          "Instruction": "VPCMPEQQ k1 {k2}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare Equal between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "PCMPEQW",
      "Description": "Compare Packed Data for Equal",
      "Url": "https://www.felixcloutier.com/x86/PCMPEQB:PCMPEQW:PCMPEQD.html",
      "Table": [
        {
          "Opcode": "NP 0F 75 /r1",
          "Instruction": "PCMPEQW mm, mm/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed words in mm/m64 and mm for equality."
        },
        {
          "Opcode": "66 0F 75 /r",
          "Instruction": "PCMPEQW xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed words in xmm2/m128 and xmm1 for equality."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 75 /r",
          "Instruction": "VPCMPEQW xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed words in xmm3/m128 and xmm2 for equality."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 75 /r",
          "Instruction": "VPCMPEQW ymm1, ymm2, ymm3 /m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed words in ymm3/m256 and ymm2 for equality."
        }
      ]
    },
    {
      "Mnemonic": "PCMPESTRI",
      "Description": "Packed Compare Explicit Length Strings, Return Index",
      "Url": "https://www.felixcloutier.com/x86/PCMPESTRI.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 61 /r imm8",
          "Instruction": "PCMPESTRI xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_2",
          "Description": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
        },
        {
          "Opcode": "VEX.128.66.0F3A 61 /r ib",
          "Instruction": "VPCMPESTRI xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Perform a packed comparison of string data with explicit lengths, generating an index, and storing the result in ECX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PCMPESTRM",
      "Description": "Packed Compare Explicit Length Strings, Return Mask",
      "Url": "https://www.felixcloutier.com/x86/PCMPESTRM.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 60 /r imm8",
          "Instruction": "PCMPESTRM xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_2",
          "Description": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
        },
        {
          "Opcode": "VEX.128.66.0F3A 60 /r ib",
          "Instruction": "VPCMPESTRM xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Perform a packed comparison of string data with explicit lengths, generating a mask, and storing the result in XMM0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PCMPGTB",
      "Description": "Compare Packed Signed Integers for Greater Than",
      "Url": "https://www.felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html",
      "Table": [
        {
          "Opcode": "NP 0F 64 /r1",
          "Instruction": "PCMPGTB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed signed byte integers in mm and mm/m64 for greater than."
        },
        {
          "Opcode": "66 0F 64 /r",
          "Instruction": "PCMPGTB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 64 /r",
          "Instruction": "VPCMPGTB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 64 /r",
          "Instruction": "VPCMPGTB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 64 /r",
          "Instruction": "VPCMPGTB k1 {k2}, xmm2, xmm3/m128",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG 64 /r",
          "Instruction": "VPCMPGTB k1 {k2}, ymm2, ymm3/m256",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 for greater than, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "PCMPGTD",
      "Description": "Compare Packed Signed Integers for Greater Than",
      "Url": "https://www.felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html",
      "Table": [
        {
          "Opcode": "NP 0F 66 /r1",
          "Instruction": "PCMPGTD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed signed doubleword integers in mm and mm/m64 for greater than."
        },
        {
          "Opcode": "66 0F 66 /r",
          "Instruction": "PCMPGTD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed signed doubleword integers in xmm1 and xmm2/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 66 /r",
          "Instruction": "VPCMPGTD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed doubleword integers in xmm2 and xmm3/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 66 /r",
          "Instruction": "VPCMPGTD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed doubleword integers in ymm2 and ymm3/m256 for greater than."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 66 /r",
          "Instruction": "VPCMPGTD k1 {k2}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Greater between int32 vector xmm2 and int32 vector xmm3/m128/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 66 /r",
          "Instruction": "VPCMPGTD k1 {k2}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Greater between int32 vector ymm2 and int32 vector ymm3/m256/m32bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 66 /r",
          "Instruction": "VPCMPGTD k1 {k2}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare Greater between int32 elements in zmm2 and zmm3/m512/m32bcst, and set destination k1 according to the comparison results under writemask. k2."
        }
      ]
    },
    {
      "Mnemonic": "PCMPGTQ",
      "Description": "Compare Packed Data for Greater Than",
      "Url": "https://www.felixcloutier.com/x86/PCMPGTQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 37 /r",
          "Instruction": "PCMPGTQ xmm1,xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_2",
          "Description": "Compare packed signed qwords in xmm2/m128 and xmm1 for greater than."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 37 /r",
          "Instruction": "VPCMPGTQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed qwords in xmm2 and xmm3/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 37 /r",
          "Instruction": "VPCMPGTQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed qwords in ymm2 and ymm3/m256 for greater than."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 37 /r",
          "Instruction": "VPCMPGTQ k1 {k2}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Greater between int64 vector xmm2 and int64 vector xmm3/m128/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 37 /r",
          "Instruction": "VPCMPGTQ k1 {k2}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare Greater between int64 vector ymm2 and int64 vector ymm3/m256/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 37 /r",
          "Instruction": "VPCMPGTQ k1 {k2}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare Greater between int64 vector zmm2 and int64 vector zmm3/m512/m64bcst, and set vector mask k1 to reflect the zero/nonzero status of each element of the result, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "PCMPGTW",
      "Description": "Compare Packed Signed Integers for Greater Than",
      "Url": "https://www.felixcloutier.com/x86/PCMPGTB:PCMPGTW:PCMPGTD.html",
      "Table": [
        {
          "Opcode": "NP 0F 65 /r1",
          "Instruction": "PCMPGTW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Compare packed signed word integers in mm and mm/m64 for greater than."
        },
        {
          "Opcode": "66 0F 65 /r",
          "Instruction": "PCMPGTW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed signed word integers in xmm1 and xmm2/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 65 /r",
          "Instruction": "VPCMPGTW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 for greater than."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 65 /r",
          "Instruction": "VPCMPGTW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 for greater than."
        }
      ]
    },
    {
      "Mnemonic": "PCMPISTRI",
      "Description": "Packed Compare Implicit Length Strings, Return Index",
      "Url": "https://www.felixcloutier.com/x86/PCMPISTRI.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 63 /r imm8",
          "Instruction": "PCMPISTRI xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_2",
          "Description": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
        },
        {
          "Opcode": "VEX.128.66.0F3A.WIG 63 /r ib",
          "Instruction": "VPCMPISTRI xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Perform a packed comparison of string data with implicit lengths, generating an index, and storing the result in ECX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PCMPISTRM",
      "Description": "Packed Compare Implicit Length Strings, Return Mask",
      "Url": "https://www.felixcloutier.com/x86/PCMPISTRM.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 62 /r imm8",
          "Instruction": "PCMPISTRM xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_2",
          "Description": "Perform a packed comparison of string data with implicit lengths, generating a mask, and storing the result in XMM0."
        },
        {
          "Opcode": "VEX.128.66.0F3A.WIG 62 /r ib",
          "Instruction": "VPCMPISTRM xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Perform a packed comparison of string data with implicit lengths, generating a Mask, and storing the result in XMM0."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PDEP",
      "Description": "Parallel Bits Deposit",
      "Url": "https://www.felixcloutier.com/x86/PDEP.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.F2.0F38.W0 F5 /r",
          "Instruction": "PDEP r32a, r32b, r/m32",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Parallel deposit of bits from r32b using mask in r/m32, result is written to r32a."
        },
        {
          "Opcode": "VEX.NDS.LZ.F2.0F38.W1 F5 /r",
          "Instruction": "PDEP r64a, r64b, r/m64",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Parallel deposit of bits from r64b using mask in r/m64, result is written to r64a."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PEXT",
      "Description": "Parallel Bits Extract",
      "Url": "https://www.felixcloutier.com/x86/PEXT.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.F3.0F38.W0 F5 /r",
          "Instruction": "PEXT r32a, r32b, r/m32",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Parallel extract of bits from r32b using mask in r/m32, result is written to r32a."
        },
        {
          "Opcode": "VEX.NDS.LZ.F3.0F38.W1 F5 /r",
          "Instruction": "PEXT r64a, r64b, r/m64",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Parallel extract of bits from r64b using mask in r/m64, result is written to r64a."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PEXTRB",
      "Description": "Extract Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 14 /r ib",
          "Instruction": "PEXTRB reg/m8, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r32 or r64 are zeroed."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W0 14 /r ib",
          "Instruction": "VPEXTRB reg/m8, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V1/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.WIG 14 /r ib",
          "Instruction": "VPEXTRB reg/m8, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Extract a byte integer value from xmm2 at the source byte offset specified by imm8 into reg or m8. The upper bits of r64/r32 is filled with zeros."
        }
      ]
    },
    {
      "Mnemonic": "PEXTRD",
      "Description": "Extract Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 16 /r ib",
          "Instruction": "PEXTRD r/m32, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r/m32."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W0 16 /r ib",
          "Instruction": "VPEXTRD r32/m32, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.W0 16 /r ib",
          "Instruction": "VPEXTRD r32/m32, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Extract a dword integer value from xmm2 at the source dword offset specified by imm8 into r32/m32."
        }
      ]
    },
    {
      "Mnemonic": "PEXTRQ",
      "Description": "Extract Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PEXTRB:PEXTRD:PEXTRQ.html",
      "Table": [
        {
          "Opcode": "66 REX.W 0F 3A 16 /r ib",
          "Instruction": "PEXTRQ r/m64, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/N.E.",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Extract a qword integer value from xmm2 at the source qword offset specified by imm8 into r/m64."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W1 16 /r ib",
          "Instruction": "VPEXTRQ r64/m64, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/I2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.W1 16 /r ib",
          "Instruction": "VPEXTRQ r64/m64, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Extract a qword integer value from xmm2 at the source dword offset specified by imm8 into r64/m64."
        }
      ]
    },
    {
      "Mnemonic": "PEXTRW",
      "Description": "Extract Word",
      "Url": "https://www.felixcloutier.com/x86/PEXTRW.html",
      "Table": [
        {
          "Opcode": "NP 0F C5 /r ib1",
          "Instruction": "PEXTRW reg, mm, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Extract the word specified by imm8 from mm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
        },
        {
          "Opcode": "66 0F C5 /r ib",
          "Instruction": "PEXTRW reg, xmm, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Extract the word specified by imm8 from xmm and move it to reg, bits 15-0. The upper bits of r32 or r64 is zeroed."
        },
        {
          "Opcode": "66 0F 3A 15 /r ib",
          "Instruction": "PEXTRW reg/m16, xmm, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Extract the word specified by imm8 from xmm and copy it to lowest 16 bits of reg or m16. Zero-extend the result in the destination, r32 or r64."
        },
        {
          "Opcode": "VEX.128.66.0F.W0 C5 /r ib",
          "Instruction": "VPEXTRW reg, xmm1, imm8",
          "Bit64Bit32ModeSupport": "V2/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W0 15 /r ib",
          "Instruction": "VPEXTRW reg/m16, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
        },
        {
          "Opcode": "EVEX.128.66.0F.WIG C5 /r ib",
          "Instruction": "VPEXTRW reg, xmm1, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512B W",
          "Description": "Extract the word specified by imm8 from xmm1 and move it to reg, bits 15:0. Zero-extend the result. The upper bits of r64/r32 is filled with zeros."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.WIG 15 /r ib",
          "Instruction": "VPEXTRW reg/m16, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512B W",
          "Description": "Extract a word integer value from xmm2 at the source word offset specified by imm8 into reg or m16. The upper bits of r64/r32 is filled with zeros."
        }
      ]
    },
    {
      "Mnemonic": "PHADDD",
      "Description": "Packed Horizontal Add",
      "Url": "https://www.felixcloutier.com/x86/PHADDW:PHADDD.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 02 /r",
          "Instruction": "PHADDD mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 32-bit integers horizontally, pack to mm1."
        },
        {
          "Opcode": "66 0F 38 02 /r",
          "Instruction": "PHADDD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 32-bit integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 02 /r",
          "Instruction": "VPHADDD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add 32-bit integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 02 /r",
          "Instruction": "VPHADDD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add 32-bit signed integers horizontally, pack to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHADDSW",
      "Description": "Packed Horizontal Add and Saturate",
      "Url": "https://www.felixcloutier.com/x86/PHADDSW.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 03 /r1",
          "Instruction": "PHADDSW mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 16-bit signed integers horizontally, pack saturated integers to mm1."
        },
        {
          "Opcode": "66 0F 38 03 /r",
          "Instruction": "PHADDSW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 03 /r",
          "Instruction": "VPHADDSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add 16-bit signed integers horizontally, pack saturated integers to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 03 /r",
          "Instruction": "VPHADDSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add 16-bit signed integers horizontally, pack saturated integers to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHADDW",
      "Description": "Packed Horizontal Add",
      "Url": "https://www.felixcloutier.com/x86/PHADDW:PHADDD.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 01 /r1",
          "Instruction": "PHADDW mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 16-bit integers horizontally, pack to mm1."
        },
        {
          "Opcode": "66 0F 38 01 /r",
          "Instruction": "PHADDW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Add 16-bit integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 01 /r",
          "Instruction": "VPHADDW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Add 16-bit integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 01 /r",
          "Instruction": "VPHADDW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Add 16-bit signed integers horizontally, pack to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHMINPOSUW",
      "Description": "Packed Horizontal Word Minimum",
      "Url": "https://www.felixcloutier.com/x86/PHMINPOSUW.html",
      "Table": [
        {
          "Opcode": "66 0F 38 41 /r",
          "Instruction": "PHMINPOSUW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 41 /r",
          "Instruction": "VPHMINPOSUW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Find the minimum unsigned word in xmm2/m128 and place its value in the low word of xmm1 and its index in the second-lowest word of xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHSUBD",
      "Description": "Packed Horizontal Subtract",
      "Url": "https://www.felixcloutier.com/x86/PHSUBW:PHSUBD.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 06 /r",
          "Instruction": "PHSUBD mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 32-bit signed integers horizontally, pack to mm1."
        },
        {
          "Opcode": "66 0F 38 06 /r",
          "Instruction": "PHSUBD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 32-bit signed integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 06 /r",
          "Instruction": "VPHSUBD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract 32-bit signed integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 06 /r",
          "Instruction": "VPHSUBD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract 32-bit signed integers horizontally, pack to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (r, w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHSUBSW",
      "Description": "Packed Horizontal Subtract and Saturate",
      "Url": "https://www.felixcloutier.com/x86/PHSUBSW.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 07 /r1",
          "Instruction": "PHSUBSW mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to mm1."
        },
        {
          "Opcode": "66 0F 38 07 /r",
          "Instruction": "PHSUBSW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 07 /r",
          "Instruction": "VPHSUBSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 07 /r",
          "Instruction": "VPHSUBSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract 16-bit signed integer horizontally, pack saturated integers to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (r, w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PHSUBW",
      "Description": "Packed Horizontal Subtract",
      "Url": "https://www.felixcloutier.com/x86/PHSUBW:PHSUBD.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 05 /r1",
          "Instruction": "PHSUBW mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 16-bit signed integers horizontally, pack to mm1."
        },
        {
          "Opcode": "66 0F 38 05 /r",
          "Instruction": "PHSUBW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Subtract 16-bit signed integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 05 /r",
          "Instruction": "VPHSUBW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract 16-bit signed integers horizontally, pack to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 05 /r",
          "Instruction": "VPHSUBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract 16-bit signed integers horizontally, pack to ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (r, w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PINSRB",
      "Description": "Insert Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 20 /r ib",
          "Instruction": "PINSRB xmm1, r32/m8, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Insert a byte integer value from r32/m8 into xmm1 at the destination element in xmm1 specified by imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 20 /r ib",
          "Instruction": "VPINSRB xmm1, xmm2, r32/m8, imm8",
          "Bit64Bit32ModeSupport": "V1/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.WIG 20 /r ib",
          "Instruction": "VPINSRB xmm1, xmm2, r32/m8, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Merge a byte integer value from r32/m8 and rest from xmm2 into xmm1 at the byte offset in imm8."
        }
      ]
    },
    {
      "Mnemonic": "PINSRD",
      "Description": "Insert Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html",
      "Table": [
        {
          "Opcode": "66 0F 3A 22 /r ib",
          "Instruction": "PINSRD xmm1, r/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Insert a dword integer value from r/m32 into the xmm1 at the destination element specified by imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 22 /r ib",
          "Instruction": "VPINSRD xmm1, xmm2, r/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 22 /r ib",
          "Instruction": "VPINSRD xmm1, xmm2, r32/m32, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Insert a dword integer value from r32/m32 and rest from xmm2 into xmm1 at the dword offset in imm8."
        }
      ]
    },
    {
      "Mnemonic": "PINSRQ",
      "Description": "Insert Byte/Dword/Qword",
      "Url": "https://www.felixcloutier.com/x86/PINSRB:PINSRD:PINSRQ.html",
      "Table": [
        {
          "Opcode": "66 REX.W 0F 3A 22 /r ib",
          "Instruction": "PINSRQ xmm1, r/m64, imm8",
          "Bit64Bit32ModeSupport": "V/N. E.",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Insert a qword integer value from r/m64 into the xmm1 at the destination element specified by imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W1 22 /r ib",
          "Instruction": "VPINSRQ xmm1, xmm2, r/m64, imm8",
          "Bit64Bit32ModeSupport": "V/I2",
          "CpuidFeatureFlag": "AVX",
          "Description": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 22 /r ib",
          "Instruction": "VPINSRQ xmm1, xmm2, r64/m64, imm8",
          "Bit64Bit32ModeSupport": "V/N.E.2",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Insert a qword integer value from r64/m64 and rest from xmm2 into xmm1 at the qword offset in imm8."
        }
      ]
    },
    {
      "Mnemonic": "PINSRW",
      "Description": "Insert Word",
      "Url": "https://www.felixcloutier.com/x86/PINSRW.html",
      "Table": [
        {
          "Opcode": "NP 0F C4 /r ib1",
          "Instruction": "PINSRW mm, r32/m16, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Insert the low word from r32 or from m16 into mm at the word position specified by imm8."
        },
        {
          "Opcode": "66 0F C4 /r ib",
          "Instruction": "PINSRW xmm, r32/m16, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move the low word of r32 or from m16 into xmm at the word position specified by imm8."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.W0 C4 /r ib",
          "Instruction": "VPINSRW xmm1, xmm2, r32/m16, imm8",
          "Bit64Bit32ModeSupport": "V2/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG C4 /r ib",
          "Instruction": "VPINSRW xmm1, xmm2, r32/m16, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Insert a word integer value from r32/m16 and rest from xmm2 into xmm1 at the word offset in imm8."
        }
      ]
    },
    {
      "Mnemonic": "PMADDUBSW",
      "Description": "Multiply and Add Packed Signed and Unsigned Bytes",
      "Url": "https://www.felixcloutier.com/x86/PMADDUBSW.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 04 /r1",
          "Instruction": "PMADDUBSW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to mm1."
        },
        {
          "Opcode": "66 0F 38 04 /r",
          "Instruction": "PMADDUBSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 04 /r",
          "Instruction": "VPMADDUBSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 04 /r",
          "Instruction": "VPMADDUBSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 04 /r",
          "Instruction": "VPMADDUBSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 04 /r",
          "Instruction": "VPMADDUBSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 04 /r",
          "Instruction": "VPMADDUBSW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply signed and unsigned bytes, add horizontal pair of signed words, pack saturated signed-words to zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMADDWD",
      "Description": "Multiply and Add Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMADDWD.html",
      "Table": [
        {
          "Opcode": "NP 0F F5 /r1",
          "Instruction": "PMADDWD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Multiply the packed words in mm by the packed words in mm/m64, add adjacent doubleword results, and store in mm."
        },
        {
          "Opcode": "66 0F F5 /r",
          "Instruction": "PMADDWD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply the packed word integers in xmm1 by the packed word integers in xmm2/m128, add adjacent doubleword results, and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F5 /r",
          "Instruction": "VPMADDWD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F5 /r",
          "Instruction": "VPMADDWD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG F5 /r",
          "Instruction": "VPMADDWD xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed word integers in xmm2 by the packed word integers in xmm3/m128, add adjacent doubleword results, and store in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG F5 /r",
          "Instruction": "VPMADDWD ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed word integers in ymm2 by the packed word integers in ymm3/m256, add adjacent doubleword results, and store in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG F5 /r",
          "Instruction": "VPMADDWD zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply the packed word integers in zmm2 by the packed word integers in zmm3/m512, add adjacent doubleword results, and store in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXSB",
      "Description": "Maximum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3C /r",
          "Instruction": "PMAXSB xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 3C /r",
          "Instruction": "VPMAXSB xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 3C /r",
          "Instruction": "VPMAXSB ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 3C /r",
          "Instruction": "VPMAXSB xmm1{k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 3C /r",
          "Instruction": "VPMAXSB ymm1{k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 3C /r",
          "Instruction": "VPMAXSB zmm1{k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXSD",
      "Description": "Maximum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3D /r",
          "Instruction": "PMAXSD xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 3D /r",
          "Instruction": "VPMAXSD xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 3D /r",
          "Instruction": "VPMAXSD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 3D /r",
          "Instruction": "VPMAXSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 3D /r",
          "Instruction": "VPMAXSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 3D /r",
          "Instruction": "VPMAXSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXSQ",
      "Description": "Maximum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 3D /r",
          "Instruction": "VPMAXSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 3D /r",
          "Instruction": "VPMAXSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 3D /r",
          "Instruction": "VPMAXSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXSW",
      "Description": "Maximum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXSB:PMAXSW:PMAXSD:PMAXSQ.html",
      "Table": [
        {
          "Opcode": "NP 0F EE /r1",
          "Instruction": "PMAXSW mm1, mm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare signed word integers in mm2/m64 and mm1 and return maximum values."
        },
        {
          "Opcode": "66 0F EE /r",
          "Instruction": "PMAXSW xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed signed word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG EE /r",
          "Instruction": "VPMAXSW xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG EE /r",
          "Instruction": "VPMAXSW ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 and store packed maximum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG EE /r",
          "Instruction": "VPMAXSW xmm1{k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG EE /r",
          "Instruction": "VPMAXSW ymm1{k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG EE /r",
          "Instruction": "VPMAXSW zmm1{k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXUB",
      "Description": "Maximum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXUB:PMAXUW.html",
      "Table": [
        {
          "Opcode": "NP 0F DE /r1",
          "Instruction": "PMAXUB mm1, mm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare unsigned byte integers in mm2/m64 and mm1 and returns maximum values."
        },
        {
          "Opcode": "66 0F DE /r",
          "Instruction": "PMAXUB xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F DE /r",
          "Instruction": "VPMAXUB xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F DE /r",
          "Instruction": "VPMAXUB ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG DE /r",
          "Instruction": "VPMAXUB xmm1{k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG DE /r",
          "Instruction": "VPMAXUB ymm1{k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG DE /r",
          "Instruction": "VPMAXUB zmm1{k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXUD",
      "Description": "Maximum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXUD:PMAXUQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3F /r",
          "Instruction": "PMAXUD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 3F /r",
          "Instruction": "VPMAXUD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 3F /r",
          "Instruction": "VPMAXUD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 3F /r",
          "Instruction": "VPMAXUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 3F /r",
          "Instruction": "VPMAXUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 3F /r",
          "Instruction": "VPMAXUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXUQ",
      "Description": "Maximum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXUD:PMAXUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 3F /r",
          "Instruction": "VPMAXUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 3F /r",
          "Instruction": "VPMAXUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 3F /r",
          "Instruction": "VPMAXUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMAXUW",
      "Description": "Maximum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMAXUB:PMAXUW.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3E/r",
          "Instruction": "PMAXUW xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed unsigned word integers in xmm2/m128 and xmm1 and stores maximum packed values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38 3E/r",
          "Instruction": "VPMAXUW xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and store maximum packed values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38 3E/r",
          "Instruction": "VPMAXUW ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and store maximum packed values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 3E /r",
          "Instruction": "VPMAXUW xmm1{k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in xmm2 and xmm3/m128 and store packed maximum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 3E /r",
          "Instruction": "VPMAXUW ymm1{k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in ymm2 and ymm3/m256 and store packed maximum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 3E /r",
          "Instruction": "VPMAXUW zmm1{k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed unsigned word integers in zmm2 and zmm3/m512 and store packed maximum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINSB",
      "Description": "Minimum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINSB:PMINSW.html",
      "Table": [
        {
          "Opcode": "66 0F 38 38 /r",
          "Instruction": "PMINSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed signed byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38 38 /r",
          "Instruction": "VPMINSB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38 38 /r",
          "Instruction": "VPMINSB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 38 /r",
          "Instruction": "VPMINSB xmm1{k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 38 /r",
          "Instruction": "VPMINSB ymm1{k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 38 /r",
          "Instruction": "VPMINSB zmm1{k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINSD",
      "Description": "Minimum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINSD:PMINSQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 39 /r",
          "Instruction": "PMINSD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed signed dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 39 /r",
          "Instruction": "VPMINSD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 39 /r",
          "Instruction": "VPMINSD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed dword integers in ymm2 and ymm3/m128 and store packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 39 /r",
          "Instruction": "VPMINSD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 39 /r",
          "Instruction": "VPMINSD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 39 /r",
          "Instruction": "VPMINSD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINSQ",
      "Description": "Minimum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINSD:PMINSQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 39 /r",
          "Instruction": "VPMINSQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed qword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 39 /r",
          "Instruction": "VPMINSQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed qword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 39 /r",
          "Instruction": "VPMINSQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINSW",
      "Description": "Minimum of Packed Signed Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINSB:PMINSW.html",
      "Table": [
        {
          "Opcode": "NP 0F EA /r1",
          "Instruction": "PMINSW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare signed word integers in mm2/m64 and mm1 and return minimum values."
        },
        {
          "Opcode": "66 0F EA /r",
          "Instruction": "PMINSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed signed word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F EA /r",
          "Instruction": "VPMINSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F EA /r",
          "Instruction": "VPMINSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG EA /r",
          "Instruction": "VPMINSW xmm1{k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG EA /r",
          "Instruction": "VPMINSW ymm1{k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG EA /r",
          "Instruction": "VPMINSW zmm1{k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed word integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINUB",
      "Description": "Minimum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINUB:PMINUW.html",
      "Table": [
        {
          "Opcode": "NP 0F DA /r1",
          "Instruction": "PMINUB mm1, mm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare unsigned byte integers in mm2/m64 and mm1 and returns minimum values."
        },
        {
          "Opcode": "66 0F DA /r",
          "Instruction": "PMINUB xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare packed unsigned byte integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F DA /r",
          "Instruction": "VPMINUB xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F DA /r",
          "Instruction": "VPMINUB ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F DA /r",
          "Instruction": "VPMINUB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F DA /r",
          "Instruction": "VPMINUB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F DA /r",
          "Instruction": "VPMINUB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed unsigned byte integers in zmm2 and zmm3/m512 and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINUD",
      "Description": "Minimum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINUD:PMINUQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3B /r",
          "Instruction": "PMINUD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed unsigned dword integers in xmm1 and xmm2/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 3B /r",
          "Instruction": "VPMINUD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 3B /r",
          "Instruction": "VPMINUD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256 and store packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 3B /r",
          "Instruction": "VPMINUD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned dword integers in xmm2 and xmm3/m128/m32bcst and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 3B /r",
          "Instruction": "VPMINUD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned dword integers in ymm2 and ymm3/m256/m32bcst and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 3B /r",
          "Instruction": "VPMINUD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned dword integers in zmm2 and zmm3/m512/m32bcst and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINUQ",
      "Description": "Minimum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINUD:PMINUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 3B /r",
          "Instruction": "VPMINUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned qword integers in xmm2 and xmm3/m128/m64bcst and store packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 3B /r",
          "Instruction": "VPMINUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned qword integers in ymm2 and ymm3/m256/m64bcst and store packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 3B /r",
          "Instruction": "VPMINUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned qword integers in zmm2 and zmm3/m512/m64bcst and store packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMINUW",
      "Description": "Minimum of Packed Unsigned Integers",
      "Url": "https://www.felixcloutier.com/x86/PMINUB:PMINUW.html",
      "Table": [
        {
          "Opcode": "66 0F 38 3A/r",
          "Instruction": "PMINUW xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Compare packed unsigned word integers in xmm2/m128 and xmm1 and store packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38 3A/r",
          "Instruction": "VPMINUW xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38 3A/r",
          "Instruction": "VPMINUW ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38 3A/r",
          "Instruction": "VPMINUW xmm1{k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 and return packed minimum values in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38 3A/r",
          "Instruction": "VPMINUW ymm1{k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 and return packed minimum values in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38 3A/r",
          "Instruction": "VPMINUW zmm1{k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed unsigned word integers in zmm3/m512 and zmm2 and return packed minimum values in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMOVMSKB",
      "Description": "Move Byte Mask",
      "Url": "https://www.felixcloutier.com/x86/PMOVMSKB.html",
      "Table": [
        {
          "Opcode": "NP 0F D7 /r1",
          "Instruction": "PMOVMSKB reg, mm",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Move a byte mask of mm to reg. The upper bits of r32 or r64 are zeroed"
        },
        {
          "Opcode": "66 0F D7 /r",
          "Instruction": "PMOVMSKB reg, xmm",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Move a byte mask of xmm to reg. The upper bits of r32 or r64 are zeroed"
        },
        {
          "Opcode": "VEX.128.66.0F.WIG D7 /r",
          "Instruction": "VPMOVMSKB reg, xmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Move a byte mask of xmm1 to reg. The upper bits of r32 or r64 are filled with zeros."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG D7 /r",
          "Instruction": "VPMOVMSKB reg, ymm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Move a 32-bit mask of ymm1 to reg. The upper bits of r64 are filled with zeros."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PMOVSX",
      "Description": "Packed Move with Sign Extend",
      "Url": "https://www.felixcloutier.com/x86/PMOVSX.html",
      "Table": [
        {
          "Opcode": "66 0f 38 20 /r",
          "Instruction": "PMOVSXBW xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 21 /r",
          "Instruction": "PMOVSXBD xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 22 /r",
          "Instruction": "PMOVSXBQ xmm1, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 23/r",
          "Instruction": "PMOVSXWD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 24 /r",
          "Instruction": "PMOVSXWQ xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 25 /r",
          "Instruction": "PMOVSXDQ xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 20 /r",
          "Instruction": "VPMOVSXBW xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 21 /r",
          "Instruction": "VPMOVSXBD xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 22 /r",
          "Instruction": "VPMOVSXBQ xmm1, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 23 /r",
          "Instruction": "VPMOVSXWD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 24 /r",
          "Instruction": "VPMOVSXWQ xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 25 /r",
          "Instruction": "VPMOVSXDQ xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 20 /r",
          "Instruction": "VPMOVSXBW ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 21 /r",
          "Instruction": "VPMOVSXBD ymm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 22 /r",
          "Instruction": "VPMOVSXBQ ymm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 23 /r",
          "Instruction": "VPMOVSXWD ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 32-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 24 /r",
          "Instruction": "VPMOVSXWQ ymm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 25 /r",
          "Instruction": "VPMOVSXDQ ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 20 /r",
          "Instruction": "VPMOVSXBW xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sign extend 8 packed 8-bit integers in xmm2/m64 to 8 packed 16-bit integers in zmm1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 20 /r",
          "Instruction": "VPMOVSXBW ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sign extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 20 /r",
          "Instruction": "VPMOVSXBW zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Sign extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 21 /r",
          "Instruction": "VPMOVSXBD xmm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 21 /r",
          "Instruction": "VPMOVSXBD ymm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 21 /r",
          "Instruction": "VPMOVSXBD zmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Sign extend 16 packed 8-bit integers in the low 16 bytes of xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 22 /r",
          "Instruction": "VPMOVSXBQ xmm1 {k1}{z}, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 22 /r",
          "Instruction": "VPMOVSXBQ ymm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 22 /r",
          "Instruction": "VPMOVSXBQ zmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Sign extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 23 /r",
          "Instruction": "VPMOVSXWD xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of ymm2/mem to 4 packed 32-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 23 /r",
          "Instruction": "VPMOVSXWD ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of ymm2/m128 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 23 /r",
          "Instruction": "VPMOVSXWD zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Sign extend 16 packed 16-bit integers in the low 32 bytes of ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 24 /r",
          "Instruction": "VPMOVSXWQ xmm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 24 /r",
          "Instruction": "VPMOVSXWQ ymm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 24 /r",
          "Instruction": "VPMOVSXWQ zmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Sign extend 8 packed 16-bit integers in the low 16 bytes of xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 25 /r",
          "Instruction": "VPMOVSXDQ xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 25 /r",
          "Instruction": "VPMOVSXDQ ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Sign extend 4 packed 32-bit integers in the low 16 bytes of xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 25 /r",
          "Instruction": "VPMOVSXDQ zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Sign extend 8 packed 32-bit integers in the low 32 bytes of ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMOVZX",
      "Description": "Packed Move with Zero Extend",
      "Url": "https://www.felixcloutier.com/x86/PMOVZX.html",
      "Table": [
        {
          "Opcode": "66 0f 38 30 /r",
          "Instruction": "PMOVZXBW xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 31 /r",
          "Instruction": "PMOVZXBD xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 32 /r",
          "Instruction": "PMOVZXBQ xmm1, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 33 /r",
          "Instruction": "PMOVZXWD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 34 /r",
          "Instruction": "PMOVZXWQ xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "66 0f 38 35 /r",
          "Instruction": "PMOVZXDQ xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 30 /r",
          "Instruction": "VPMOVZXBW xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 31 /r",
          "Instruction": "VPMOVZXBD xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 32 /r",
          "Instruction": "VPMOVZXBQ xmm1, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 33 /r",
          "Instruction": "VPMOVZXWD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 34 /r",
          "Instruction": "VPMOVZXWQ xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F 38.WIG 35 /r",
          "Instruction": "VPMOVZXDQ xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 30 /r",
          "Instruction": "VPMOVZXBW ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 31 /r",
          "Instruction": "VPMOVZXBD ymm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 32 /r",
          "Instruction": "VPMOVZXBQ ymm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 33 /r",
          "Instruction": "VPMOVZXWD ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 8 packed 16-bit integers xmm2/m128 to 8 packed 32-bit integers in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 34 /r",
          "Instruction": "VPMOVZXWQ ymm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 35 /r",
          "Instruction": "VPMOVZXDQ ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38 30.WIG /r",
          "Instruction": "VPMOVZXBW xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 16-bit integers in xmm1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 30 /r",
          "Instruction": "VPMOVZXBW ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 16-bit integers in ymm1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 30 /r",
          "Instruction": "VPMOVZXBW zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Zero extend 32 packed 8-bit integers in ymm2/m256 to 32 packed 16-bit integers in zmm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 31 /r",
          "Instruction": "VPMOVZXBD xmm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 31 /r",
          "Instruction": "VPMOVZXBD ymm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 32-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 31 /r",
          "Instruction": "VPMOVZXBD zmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Zero extend 16 packed 8-bit integers in xmm2/m128 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 32 /r",
          "Instruction": "VPMOVZXBQ xmm1 {k1}{z}, xmm2/m16",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 2 packed 8-bit integers in the low 2 bytes of xmm2/m16 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 32 /r",
          "Instruction": "VPMOVZXBQ ymm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 4 packed 8-bit integers in the low 4 bytes of xmm2/m32 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 32 /r",
          "Instruction": "VPMOVZXBQ zmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Zero extend 8 packed 8-bit integers in the low 8 bytes of xmm2/m64 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 33 /r",
          "Instruction": "VPMOVZXWD xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 32-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 33 /r",
          "Instruction": "VPMOVZXWD ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 32-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 33 /r",
          "Instruction": "VPMOVZXWD zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Zero extend 16 packed 16-bit integers in ymm2/m256 to 16 packed 32-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.WIG 34 /r",
          "Instruction": "VPMOVZXWQ xmm1 {k1}{z}, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 2 packed 16-bit integers in the low 4 bytes of xmm2/m32 to 2 packed 64-bit integers in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.WIG 34 /r",
          "Instruction": "VPMOVZXWQ ymm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 4 packed 16-bit integers in the low 8 bytes of xmm2/m64 to 4 packed 64-bit integers in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.WIG 34 /r",
          "Instruction": "VPMOVZXWQ zmm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Zero extend 8 packed 16-bit integers in xmm2/m128 to 8 packed 64-bit integers in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 35 /r",
          "Instruction": "VPMOVZXDQ xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 2 packed 32-bit integers in the low 8 bytes of xmm2/m64 to 2 packed 64-bit integers in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 35 /r",
          "Instruction": "VPMOVZXDQ ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Zero extend 4 packed 32-bit integers in xmm2/m128 to 4 packed 64-bit integers in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 35 /r",
          "Instruction": "VPMOVZXDQ zmm1 {k1}{z}, ymm2/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Zero extend 8 packed 32-bit integers in ymm2/m256 to 8 packed 64-bit integers in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULDQ",
      "Description": "Multiply Packed Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/PMULDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 28 /r",
          "Instruction": "PMULDQ xmm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Multiply packed signed doubleword integers in xmm1 by packed signed doubleword integers in xmm2/m128, and store the quadword results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 28 /r",
          "Instruction": "VPMULDQ xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128, and store the quadword results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 28 /r",
          "Instruction": "VPMULDQ ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256, and store the quadword results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 28 /r",
          "Instruction": "VPMULDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed signed doubleword integers in xmm2 by packed signed doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 28 /r",
          "Instruction": "VPMULDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed signed doubleword integers in ymm2 by packed signed doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 28 /r",
          "Instruction": "VPMULDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed signed doubleword integers in zmm2 by packed signed doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULHRSW",
      "Description": "Packed Multiply High with Round and Scale",
      "Url": "https://www.felixcloutier.com/x86/PMULHRSW.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 0B /r1",
          "Instruction": "PMULHRSW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to mm1."
        },
        {
          "Opcode": "66 0F 38 0B /r",
          "Instruction": "PMULHRSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 0B /r",
          "Instruction": "VPMULHRSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 0B /r",
          "Instruction": "VPMULHRSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 0B /r",
          "Instruction": "VPMULHRSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 0B /r",
          "Instruction": "VPMULHRSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 0B /r",
          "Instruction": "VPMULHRSW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply 16-bit signed words, scale and round signed doublewords, pack high 16 bits to zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULHUW",
      "Description": "Multiply Packed Unsigned Integers and Store High Result",
      "Url": "https://www.felixcloutier.com/x86/PMULHUW.html",
      "Table": [
        {
          "Opcode": "NP 0F E4 /r1",
          "Instruction": "PMULHUW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Multiply the packed unsigned word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
        },
        {
          "Opcode": "66 0F E4 /r",
          "Instruction": "PMULHUW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply the packed unsigned word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E4 /r",
          "Instruction": "VPMULHUW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E4 /r",
          "Instruction": "VPMULHUW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E4 /r",
          "Instruction": "VPMULHUW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed unsigned word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E4 /r",
          "Instruction": "VPMULHUW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed unsigned word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E4 /r",
          "Instruction": "VPMULHUW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply the packed unsigned word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULHW",
      "Description": "Multiply Packed Signed Integers and Store High Result",
      "Url": "https://www.felixcloutier.com/x86/PMULHW.html",
      "Table": [
        {
          "Opcode": "NP 0F E5 /r1",
          "Instruction": "PMULHW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the high 16 bits of the results in mm1."
        },
        {
          "Opcode": "66 0F E5 /r",
          "Instruction": "PMULHW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the high 16 bits of the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E5 /r",
          "Instruction": "VPMULHW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E5 /r",
          "Instruction": "VPMULHW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E5 /r",
          "Instruction": "VPMULHW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the high 16 bits of the results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E5 /r",
          "Instruction": "VPMULHW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the high 16 bits of the results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E5 /r",
          "Instruction": "VPMULHW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the high 16 bits of the results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULLD",
      "Description": "Multiply Packed Integers and Store Low Result",
      "Url": "https://www.felixcloutier.com/x86/PMULLD:PMULLQ.html",
      "Table": [
        {
          "Opcode": "66 0F 38 40 /r",
          "Instruction": "PMULLD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Multiply the packed dword signed integers in xmm1 and xmm2/m128 and store the low 32 bits of each product in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 40 /r",
          "Instruction": "VPMULLD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 40 /r",
          "Instruction": "VPMULLD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply the packed dword signed integers in ymm2 and ymm3/m256 and store the low 32 bits of each product in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 40 /r",
          "Instruction": "VPMULLD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128/m32bcst and store the low 32 bits of each product in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 40 /r",
          "Instruction": "VPMULLD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply the packed dword signed integers in ymm2 and ymm3/m256/m32bcst and store the low 32 bits of each product in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 40 /r",
          "Instruction": "VPMULLD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply the packed dword signed integers in zmm2 and zmm3/m512/m32bcst and store the low 32 bits of each product in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULLQ",
      "Description": "Multiply Packed Integers and Store Low Result",
      "Url": "https://www.felixcloutier.com/x86/PMULLD:PMULLQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 40 /r",
          "Instruction": "VPMULLQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Multiply the packed qword signed integers in xmm2 and xmm3/m128/m64bcst and store the low 64 bits of each product in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 40 /r",
          "Instruction": "VPMULLQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Multiply the packed qword signed integers in ymm2 and ymm3/m256/m64bcst and store the low 64 bits of each product in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 40 /r",
          "Instruction": "VPMULLQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Multiply the packed qword signed integers in zmm2 and zmm3/m512/m64bcst and store the low 64 bits of each product in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULLW",
      "Description": "Multiply Packed Signed Integers and Store Low Result",
      "Url": "https://www.felixcloutier.com/x86/PMULLW.html",
      "Table": [
        {
          "Opcode": "NP 0F D5 /r1",
          "Instruction": "PMULLW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Multiply the packed signed word integers in mm1 register and mm2/m64, and store the low 16 bits of the results in mm1."
        },
        {
          "Opcode": "66 0F D5 /r",
          "Instruction": "PMULLW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply the packed signed word integers in xmm1 and xmm2/m128, and store the low 16 bits of the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D5 /r",
          "Instruction": "VPMULLW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply the packed dword signed integers in xmm2 and xmm3/m128 and store the low 32 bits of each product in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D5 /r",
          "Instruction": "VPMULLW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG D5 /r",
          "Instruction": "VPMULLW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed signed word integers in xmm2 and xmm3/m128, and store the low 16 bits of the results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG D5 /r",
          "Instruction": "VPMULLW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Multiply the packed signed word integers in ymm2 and ymm3/m256, and store the low 16 bits of the results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG D5 /r",
          "Instruction": "VPMULLW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Multiply the packed signed word integers in zmm2 and zmm3/m512, and store the low 16 bits of the results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PMULUDQ",
      "Description": "Multiply Packed Unsigned Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/PMULUDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F F4 /r1",
          "Instruction": "PMULUDQ mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply unsigned doubleword integer in mm1 by unsigned doubleword integer in mm2/m64, and store the quadword result in mm1."
        },
        {
          "Opcode": "66 0F F4 /r",
          "Instruction": "PMULUDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Multiply packed unsigned doubleword integers in xmm1 by packed unsigned doubleword integers in xmm2/m128, and store the quadword results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F4 /r",
          "Instruction": "VPMULUDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128, and store the quadword results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F4 /r",
          "Instruction": "VPMULUDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256, and store the quadword results in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 F4 /r",
          "Instruction": "VPMULUDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed unsigned doubleword integers in xmm2 by packed unsigned doubleword integers in xmm3/m128/m64bcst, and store the quadword results in xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 F4 /r",
          "Instruction": "VPMULUDQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed unsigned doubleword integers in ymm2 by packed unsigned doubleword integers in ymm3/m256/m64bcst, and store the quadword results in ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 F4 /r",
          "Instruction": "VPMULUDQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed unsigned doubleword integers in zmm2 by packed unsigned doubleword integers in zmm3/m512/m64bcst, and store the quadword results in zmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "POP",
      "Description": "Pop a Value from the Stack",
      "Url": "https://www.felixcloutier.com/x86/POP.html",
      "Table": [
        {
          "Opcode": "8F /0",
          "Instruction": "POP r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into m16; increment stack pointer."
        },
        {
          "Opcode": "8F /0",
          "Instruction": "POP r/m32",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into m32; increment stack pointer."
        },
        {
          "Opcode": "8F /0",
          "Instruction": "POP r/m64",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack into m64; increment stack pointer. Cannot encode 32-bit operand size."
        },
        {
          "Opcode": "58+ rw",
          "Instruction": "POP r16",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into r16; increment stack pointer."
        },
        {
          "Opcode": "58+ rd",
          "Instruction": "POP r32",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into r32; increment stack pointer."
        },
        {
          "Opcode": "58+ rd",
          "Instruction": "POP r64",
          "OperandEncoding": "O",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack into r64; increment stack pointer. Cannot encode 32-bit operand size."
        },
        {
          "Opcode": "1F",
          "Instruction": "POP DS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into DS; increment stack pointer."
        },
        {
          "Opcode": "07",
          "Instruction": "POP ES",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into ES; increment stack pointer."
        },
        {
          "Opcode": "17",
          "Instruction": "POP SS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into SS; increment stack pointer."
        },
        {
          "Opcode": "0F A1",
          "Instruction": "POP FS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into FS; increment stack pointer by 16 bits."
        },
        {
          "Opcode": "0F A1",
          "Instruction": "POP FS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into FS; increment stack pointer by 32 bits."
        },
        {
          "Opcode": "0F A1",
          "Instruction": "POP FS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack into FS; increment stack pointer by 64 bits."
        },
        {
          "Opcode": "0F A9",
          "Instruction": "POP GS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into GS; increment stack pointer by 16 bits."
        },
        {
          "Opcode": "0F A9",
          "Instruction": "POP GS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into GS; increment stack pointer by 32 bits."
        },
        {
          "Opcode": "0F A9",
          "Instruction": "POP GS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack into GS; increment stack pointer by 64 bits."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        },
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (w)"
          ]
        },
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POPA",
      "Description": "Pop All General-Purpose Registers",
      "Url": "https://www.felixcloutier.com/x86/POPA:POPAD.html",
      "Table": [
        {
          "Opcode": "61",
          "Instruction": "POPA",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop DI, SI, BP, BX, DX, CX, and AX."
        },
        {
          "Opcode": "61",
          "Instruction": "POPAD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POPAD",
      "Description": "Pop All General-Purpose Registers",
      "Url": "https://www.felixcloutier.com/x86/POPA:POPAD.html",
      "Table": [
        {
          "Opcode": "61",
          "Instruction": "POPA",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop DI, SI, BP, BX, DX, CX, and AX."
        },
        {
          "Opcode": "61",
          "Instruction": "POPAD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop EDI, ESI, EBP, EBX, EDX, ECX, and EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POPCNT",
      "Description": "Return the Count of Number of Bits Set to 1",
      "Url": "https://www.felixcloutier.com/x86/POPCNT.html",
      "Table": [
        {
          "Opcode": "F3 0F B8 /r",
          "Instruction": "POPCNT r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "POPCNT on r/m16"
        },
        {
          "Opcode": "F3 0F B8 /r",
          "Instruction": "POPCNT r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "POPCNT on r/m32"
        },
        {
          "Opcode": "F3 REX.W 0F B8 /r",
          "Instruction": "POPCNT r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "POPCNT on r/m64"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "POPF",
      "Description": "Pop Stack into EFLAGS Register",
      "Url": "https://www.felixcloutier.com/x86/POPF:POPFD:POPFQ.html",
      "Table": [
        {
          "Opcode": "9D",
          "Instruction": "POPF",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into lower 16 bits of EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack and zero-extend into RFLAGS."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POPFD",
      "Description": "Pop Stack into EFLAGS Register",
      "Url": "https://www.felixcloutier.com/x86/POPF:POPFD:POPFQ.html",
      "Table": [
        {
          "Opcode": "9D",
          "Instruction": "POPF",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into lower 16 bits of EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack and zero-extend into RFLAGS."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POPFQ",
      "Description": "Pop Stack into EFLAGS Register",
      "Url": "https://www.felixcloutier.com/x86/POPF:POPFD:POPFQ.html",
      "Table": [
        {
          "Opcode": "9D",
          "Instruction": "POPF",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into lower 16 bits of EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Pop top of stack into EFLAGS."
        },
        {
          "Opcode": "9D",
          "Instruction": "POPFQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Pop top of stack and zero-extend into RFLAGS."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "POR",
      "Description": "Bitwise Logical OR",
      "Url": "https://www.felixcloutier.com/x86/POR.html",
      "Table": [
        {
          "Opcode": "NP 0F EB /r1",
          "Instruction": "POR mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Bitwise OR of mm/m64 and mm."
        },
        {
          "Opcode": "66 0F EB /r",
          "Instruction": "POR xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Bitwise OR of xmm2/m128 and xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG EB /r",
          "Instruction": "VPOR xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Bitwise OR of xmm2/m128 and xmm3."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG EB /r",
          "Instruction": "VPOR ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Bitwise OR of ymm2/m256 and ymm3."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 EB /r",
          "Instruction": "VPORD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise OR of packed doubleword integers in xmm2 and xmm3/m128/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W0 EB /r",
          "Instruction": "VPORD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise OR of packed doubleword integers in ymm2 and ymm3/m256/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W0 EB /r",
          "Instruction": "VPORD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise OR of packed doubleword integers in zmm2 and zmm3/m512/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 EB /r",
          "Instruction": "VPORQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise OR of packed quadword integers in xmm2 and xmm3/m128/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 EB /r",
          "Instruction": "VPORQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise OR of packed quadword integers in ymm2 and ymm3/m256/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 EB /r",
          "Instruction": "VPORQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise OR of packed quadword integers in zmm2 and zmm3/m512/m64bcst using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PREFETCHW",
      "Description": "Prefetch Data into Caches in Anticipation of a Write",
      "Url": "https://www.felixcloutier.com/x86/PREFETCHW.html",
      "Table": [
        {
          "Opcode": "0F 0D /1",
          "Instruction": "PREFETCHW m8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "PRFCHW",
          "Description": "Move data from m8 closer to the processor in anticipation of a write."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PREFETCHh",
      "Description": "Prefetch Data Into Caches",
      "Url": "https://www.felixcloutier.com/x86/PREFETCHh.html",
      "Table": [
        {
          "Opcode": "0F 18 /1",
          "Instruction": "PREFETCHT0 m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Move data from m8 closer to the processor using T0 hint."
        },
        {
          "Opcode": "0F 18 /2",
          "Instruction": "PREFETCHT1 m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Move data from m8 closer to the processor using T1 hint."
        },
        {
          "Opcode": "0F 18 /3",
          "Instruction": "PREFETCHT2 m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Move data from m8 closer to the processor using T2 hint."
        },
        {
          "Opcode": "0F 18 /0",
          "Instruction": "PREFETCHNTA m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Move data from m8 closer to the processor using NTA hint."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PSADBW",
      "Description": "Compute Sum of Absolute Differences",
      "Url": "https://www.felixcloutier.com/x86/PSADBW.html",
      "Table": [
        {
          "Opcode": "NP 0F F6 /r1",
          "Instruction": "PSADBW mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from mm2 /m64 and mm1; differences are then summed to produce an unsigned word integer result."
        },
        {
          "Opcode": "66 0F F6 /r",
          "Instruction": "PSADBW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm2 /m128 and xmm1; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F6 /r",
          "Instruction": "VPSADBW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; the 8 low differences and 8 high differences are then summed separately to produce two unsigned word integer results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F6 /r",
          "Instruction": "VPSADBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG F6 /r",
          "Instruction": "VPSADBW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from xmm3 /m128 and xmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG F6 /r",
          "Instruction": "VPSADBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from ymm3 /m256 and ymm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG F6 /r",
          "Instruction": "VPSADBW zmm1, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Computes the absolute differences of the packed unsigned byte integers from zmm3 /m512 and zmm2; then each consecutive 8 differences are summed separately to produce four unsigned word integer results."
        }
      ]
    },
    {
      "Mnemonic": "PSHUFB",
      "Description": "Packed Shuffle Bytes",
      "Url": "https://www.felixcloutier.com/x86/PSHUFB.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 00 /r1",
          "Instruction": "PSHUFB mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Shuffle bytes in mm1 according to contents of mm2/m64."
        },
        {
          "Opcode": "66 0F 38 00 /r",
          "Instruction": "PSHUFB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Shuffle bytes in xmm1 according to contents of xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 00 /r",
          "Instruction": "VPSHUFB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle bytes in xmm2 according to contents of xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 00 /r",
          "Instruction": "VPSHUFB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shuffle bytes in ymm2 according to contents of ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.WIG 00 /r",
          "Instruction": "VPSHUFB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle bytes in xmm2 according to contents of xmm3/m128 under write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.WIG 00 /r",
          "Instruction": "VPSHUFB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle bytes in ymm2 according to contents of ymm3/m256 under write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.WIG 00 /r",
          "Instruction": "VPSHUFB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shuffle bytes in zmm2 according to contents of zmm3/m512 under write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSHUFD",
      "Description": "Shuffle Packed Doublewords",
      "Url": "https://www.felixcloutier.com/x86/PSHUFD.html",
      "Table": [
        {
          "Opcode": "66 0F 70 /r ib",
          "Instruction": "PSHUFD xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFD xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle the doublewords in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFD ymm1, ymm2/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shuffle the doublewords in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 70 /r ib",
          "Instruction": "VPSHUFD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shuffle the doublewords in xmm2/m128/m32bcst based on the encoding in imm8 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 70 /r ib",
          "Instruction": "VPSHUFD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shuffle the doublewords in ymm2/m256/m32bcst based on the encoding in imm8 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 70 /r ib",
          "Instruction": "VPSHUFD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle the doublewords in zmm2/m512/m32bcst based on the encoding in imm8 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSHUFHW",
      "Description": "Shuffle Packed High Words",
      "Url": "https://www.felixcloutier.com/x86/PSHUFHW.html",
      "Table": [
        {
          "Opcode": "F3 0F 70 /r ib",
          "Instruction": "PSHUFHW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.128.F3.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFHW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.256.F3.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFHW ymm1, ymm2/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFHW xmm1 {k1}{z}, xmm2/m128, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle the high words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFHW ymm1 {k1}{z}, ymm2/m256, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle the high words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFHW zmm1 {k1}{z}, zmm2/m512, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shuffle the high words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSHUFLW",
      "Description": "Shuffle Packed Low Words",
      "Url": "https://www.felixcloutier.com/x86/PSHUFLW.html",
      "Table": [
        {
          "Opcode": "F2 0F 70 /r ib",
          "Instruction": "PSHUFLW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.128.F2.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFLW xmm1, xmm2/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.256.F2.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFLW ymm1, ymm2/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFLW xmm1 {k1}{z}, xmm2/m128, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle the low words in xmm2/m128 based on the encoding in imm8 and store the result in xmm1 under write mask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFLW ymm1 {k1}{z}, ymm2/m256, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shuffle the low words in ymm2/m256 based on the encoding in imm8 and store the result in ymm1 under write mask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.WIG 70 /r ib",
          "Instruction": "VPSHUFLW zmm1 {k1}{z}, zmm2/m512, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shuffle the low words in zmm2/m512 based on the encoding in imm8 and store the result in zmm1 under write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSHUFW",
      "Description": "Shuffle Packed Words",
      "Url": "https://www.felixcloutier.com/x86/PSHUFW.html",
      "Table": [
        {
          "Opcode": "NP 0F 70 /r ib",
          "Instruction": "PSHUFW mm1, mm2/m64, imm8",
          "OperandEncoding": "RMI",
          "CompatLegMode": "Valid",
          "Description": "Shuffle the words in mm2/m64 based on the encoding in imm8 and store the result in mm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PSIGNB",
      "Description": "Packed SIGN",
      "Url": "https://www.felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 08 /r1",
          "Instruction": "PSIGNB mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed byte integers in mm1 depending on the corresponding sign in mm2/m64."
        },
        {
          "Opcode": "66 0F 38 08 /r",
          "Instruction": "PSIGNB xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed byte integers in xmm1 depending on the corresponding sign in xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 08 /r",
          "Instruction": "VPSIGNB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Negate/zero/preserve packed byte integers in xmm2 depending on the corresponding sign in xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 08 /r",
          "Instruction": "VPSIGNB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Negate packed byte integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PSIGND",
      "Description": "Packed SIGN",
      "Url": "https://www.felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 0A /r1",
          "Instruction": "PSIGND mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed doubleword integers in mm1 depending on the corresponding sign in mm2/m128."
        },
        {
          "Opcode": "66 0F 38 0A /r",
          "Instruction": "PSIGND xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed doubleword integers in xmm1 depending on the corresponding sign in xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 0A /r",
          "Instruction": "VPSIGND xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Negate/zero/preserve packed doubleword integers in xmm2 depending on the corresponding sign in xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 0A /r",
          "Instruction": "VPSIGND ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Negate packed doubleword integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PSIGNW",
      "Description": "Packed SIGN",
      "Url": "https://www.felixcloutier.com/x86/PSIGNB:PSIGNW:PSIGND.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 09 /r1",
          "Instruction": "PSIGNW mm1, mm2/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed word integers in mm1 depending on the corresponding sign in mm2/m128."
        },
        {
          "Opcode": "66 0F 38 09 /r",
          "Instruction": "PSIGNW xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSSE3",
          "Description": "Negate/zero/preserve packed word integers in xmm1 depending on the corresponding sign in xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.WIG 09 /r",
          "Instruction": "VPSIGNW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Negate/zero/preserve packed word integers in xmm2 depending on the corresponding sign in xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.WIG 09 /r",
          "Instruction": "VPSIGNW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "RVM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Negate packed 16-bit integers in ymm2 if the corresponding sign in ymm3/m256 is less than zero."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PSLLD",
      "Description": "Shift Packed Data Left Logical",
      "Url": "https://www.felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F F2 /r1",
          "Instruction": "PSLLD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm left by mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F F2 /r",
          "Instruction": "PSLLD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doublewords in xmm1 left by xmm2/m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 72 /6 ib1",
          "Instruction": "PSLLD mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 72 /6 ib",
          "Instruction": "PSLLD xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doublewords in xmm1 left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F2 /r",
          "Instruction": "VPSLLD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 72 /6 ib",
          "Instruction": "VPSLLD xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 left by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSLLDQ",
      "Description": "Shift Double Quadword Left Logical",
      "Url": "https://www.felixcloutier.com/x86/PSLLDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 73 /7 ib",
          "Instruction": "PSLLDQ xmm1, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift xmm1 left by imm8 bytes while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 73 /7 ib",
          "Instruction": "VPSLLDQ xmm1, xmm2, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift xmm2 left by imm8 bytes while shifting in 0s and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 73 /7 ib",
          "Instruction": "VPSLLDQ ymm1, ymm2, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift ymm2 left by imm8 bytes while shifting in 0s and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDD.128.66.0F.WIG 73 /7 ib",
          "Instruction": "VPSLLDQ xmm1,xmm2/ m128, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift xmm2/m128 left by imm8 bytes while shifting in 0s and store result in xmm1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.WIG 73 /7 ib",
          "Instruction": "VPSLLDQ ymm1, ymm2/m256, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift ymm2/m256 left by imm8 bytes while shifting in 0s and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.WIG 73 /7 ib",
          "Instruction": "VPSLLDQ zmm1, zmm2/m512, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift zmm2/m512 left by imm8 bytes while shifting in 0s and store result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "PSLLQ",
      "Description": "Shift Packed Data Left Logical",
      "Url": "https://www.felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F F3 /r1",
          "Instruction": "PSLLQ mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift quadword in mm left by mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F F3 /r",
          "Instruction": "PSLLQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift quadwords in xmm1 left by xmm2/m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 73 /6 ib1",
          "Instruction": "PSLLQ mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift quadword in mm left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 73 /6 ib",
          "Instruction": "PSLLQ xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift quadwords in xmm1 left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F3 /r",
          "Instruction": "VPSLLQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift quadwords in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 73 /6 ib",
          "Instruction": "VPSLLQ xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift quadwords in xmm2 left by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSLLW",
      "Description": "Shift Packed Data Left Logical",
      "Url": "https://www.felixcloutier.com/x86/PSLLW:PSLLD:PSLLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F F1 /r1",
          "Instruction": "PSLLW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm left mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F F1 /r",
          "Instruction": "PSLLW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 left by xmm2/m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 71 /6 ib",
          "Instruction": "PSLLW mm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 71 /6 ib",
          "Instruction": "PSLLW xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F1 /r",
          "Instruction": "VPSLLW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 left by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 71 /6 ib",
          "Instruction": "VPSLLW xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 left by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F1 /r",
          "Instruction": "VPSLLW ymm1, ymm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 left by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 71 /6 ib",
          "Instruction": "VPSLLW ymm1, ymm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 left by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSRAD",
      "Description": "Shift Packed Data Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html",
      "Table": [
        {
          "Opcode": "NP 0F E2 /r1",
          "Instruction": "PSRAD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm right by mm/m64 while shifting in sign bits."
        },
        {
          "Opcode": "66 0F E2 /r",
          "Instruction": "PSRAD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doubleword in xmm1 right by xmm2 /m128 while shifting in sign bits."
        },
        {
          "Opcode": "NP 0F 72 /4 ib1",
          "Instruction": "PSRAD mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm right by imm8 while shifting in sign bits."
        },
        {
          "Opcode": "66 0F 72 /4 ib",
          "Instruction": "PSRAD xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doublewords in xmm1 right by imm8 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E2 /r",
          "Instruction": "VPSRAD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 72 /4 ib",
          "Instruction": "VPSRAD xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 right by imm8 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E2 /r",
          "Instruction": "VPSRAD ymm1, ymm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 72 /4 ib",
          "Instruction": "VPSRAD ymm1, ymm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in ymm2 right by imm8 while shifting in sign bits."
        }
      ]
    },
    {
      "Mnemonic": "PSRAQ",
      "Description": "Shift Packed Data Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html",
      "Table": []
    },
    {
      "Mnemonic": "PSRAW",
      "Description": "Shift Packed Data Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/PSRAW:PSRAD:PSRAQ.html",
      "Table": [
        {
          "Opcode": "NP 0F E1 /r1",
          "Instruction": "PSRAW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm right by mm/m64 while shifting in sign bits."
        },
        {
          "Opcode": "66 0F E1 /r",
          "Instruction": "PSRAW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 right by xmm2/m128 while shifting in sign bits."
        },
        {
          "Opcode": "NP 0F 71 /4 ib1",
          "Instruction": "PSRAW mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm right by imm8 while shifting in sign bits"
        },
        {
          "Opcode": "66 0F 71 /4 ib",
          "Instruction": "PSRAW xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 right by imm8 while shifting in sign bits"
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E1 /r",
          "Instruction": "VPSRAW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 71 /4 ib",
          "Instruction": "VPSRAW xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 right by imm8 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E1 /r",
          "Instruction": "VPSRAW ymm1, ymm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 71 /4 ib",
          "Instruction": "VPSRAW ymm1, ymm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 right by imm8 while shifting in sign bits."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E1 /r",
          "Instruction": "VPSRAW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "G",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E1 /r",
          "Instruction": "VPSRAW ymm1 {k1}{z}, ymm2, xmm3/m128",
          "OperandEncoding": "G",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E1 /r",
          "Instruction": "VPSRAW zmm1 {k1}{z}, zmm2, xmm3/m128",
          "OperandEncoding": "G",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift words in zmm2 right by amount specified in xmm3/m128 while shifting in sign bits using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSRLD",
      "Description": "Shift Packed Data Right Logical",
      "Url": "https://www.felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F D2 /r1",
          "Instruction": "PSRLD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm right by amount specified in mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F D2 /r",
          "Instruction": "PSRLD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doublewords in xmm1 right by amount specified in xmm2 /m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 72 /2 ib1",
          "Instruction": "PSRLD mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift doublewords in mm right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 72 /2 ib",
          "Instruction": "PSRLD xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift doublewords in xmm1 right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D2 /r",
          "Instruction": "VPSRLD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 72 /2 ib",
          "Instruction": "VPSRLD xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift doublewords in xmm2 right by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSRLDQ",
      "Description": "Shift Double Quadword Right Logical",
      "Url": "https://www.felixcloutier.com/x86/PSRLDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 73 /3 ib",
          "Instruction": "PSRLDQ xmm1, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift xmm1 right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 73 /3 ib",
          "Instruction": "VPSRLDQ xmm1, xmm2, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift xmm2 right by imm8 bytes while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 73 /3 ib",
          "Instruction": "VPSRLDQ ymm1, ymm2, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift ymm1 right by imm8 bytes while shifting in 0s."
        },
        {
          "Opcode": "EVEX.NDD.128.66.0F.WIG 73 /3 ib",
          "Instruction": "VPSRLDQ xmm1, xmm2/m128, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift xmm2/m128 right by imm8 bytes while shifting in 0s and store result in xmm1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.WIG 73 /3 ib",
          "Instruction": "VPSRLDQ ymm1, ymm2/m256, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift ymm2/m256 right by imm8 bytes while shifting in 0s and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.WIG 73 /3 ib",
          "Instruction": "VPSRLDQ zmm1, zmm2/m512, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift zmm2/m512 right by imm8 bytes while shifting in 0s and store result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "PSRLQ",
      "Description": "Shift Packed Data Right Logical",
      "Url": "https://www.felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F D3 /r1",
          "Instruction": "PSRLQ mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift mm right by amount specified in mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F D3 /r",
          "Instruction": "PSRLQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift quadwords in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 73 /2 ib1",
          "Instruction": "PSRLQ mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift mm right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 73 /2 ib",
          "Instruction": "PSRLQ xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift quadwords in xmm1 right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D3 /r",
          "Instruction": "VPSRLQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift quadwords in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 73 /2 ib",
          "Instruction": "VPSRLQ xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift quadwords in xmm2 right by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSRLW",
      "Description": "Shift Packed Data Right Logical",
      "Url": "https://www.felixcloutier.com/x86/PSRLW:PSRLD:PSRLQ.html",
      "Table": [
        {
          "Opcode": "NP 0F D1 /r1",
          "Instruction": "PSRLW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm right by amount specified in mm/m64 while shifting in 0s."
        },
        {
          "Opcode": "66 0F D1 /r",
          "Instruction": "PSRLW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 right by amount specified in xmm2/m128 while shifting in 0s."
        },
        {
          "Opcode": "NP 0F 71 /2 ib1",
          "Instruction": "PSRLW mm, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Shift words in mm right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "66 0F 71 /2 ib",
          "Instruction": "PSRLW xmm1, imm8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shift words in xmm1 right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D1 /r",
          "Instruction": "VPSRLW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 right by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.128.66.0F.WIG 71 /2 ib",
          "Instruction": "VPSRLW xmm1, xmm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shift words in xmm2 right by imm8 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D1 /r",
          "Instruction": "VPSRLW ymm1, ymm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 right by amount specified in xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDD.256.66.0F.WIG 71 /2 ib",
          "Instruction": "VPSRLW ymm1, ymm2, imm8",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift words in ymm2 right by imm8 while shifting in 0s."
        }
      ]
    },
    {
      "Mnemonic": "PSUBB",
      "Description": "Subtract Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html",
      "Table": [
        {
          "Opcode": "NP 0F F8 /r1",
          "Instruction": "PSUBB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract packed byte integers in mm/m64 from packed byte integers in mm."
        },
        {
          "Opcode": "66 0F F8 /r",
          "Instruction": "PSUBB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed byte integers in xmm2/m128 from packed byte integers in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F8 /r",
          "Instruction": "VPSUBB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed byte integers in xmm3/m128 from xmm2."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F8 /r",
          "Instruction": "VPSUBB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed byte integers in ymm3/m256 from ymm2."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG F8 /r",
          "Instruction": "VPSUBB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed byte integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG F8 /r",
          "Instruction": "VPSUBB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed byte integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG F8 /r",
          "Instruction": "VPSUBB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Subtract packed byte integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBD",
      "Description": "Subtract Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html",
      "Table": [
        {
          "Opcode": "NP 0F FA /r1",
          "Instruction": "PSUBD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract packed doubleword integers in mm/m64 from packed doubleword integers in mm."
        },
        {
          "Opcode": "66 0F FA /r",
          "Instruction": "PSUBD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed doubleword integers in xmm2/mem128 from packed doubleword integers in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG FA /r",
          "Instruction": "VPSUBD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed doubleword integers in xmm3/m128 from xmm2."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG FA /r",
          "Instruction": "VPSUBD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed doubleword integers in ymm3/m256 from ymm2."
        }
      ]
    },
    {
      "Mnemonic": "PSUBQ",
      "Description": "Subtract Packed Quadword Integers",
      "Url": "https://www.felixcloutier.com/x86/PSUBQ.html",
      "Table": [
        {
          "Opcode": "NP 0F FB /r1",
          "Instruction": "PSUBQ mm1, mm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract quadword integer in mm1 from mm2 /m64."
        },
        {
          "Opcode": "66 0F FB /r",
          "Instruction": "PSUBQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed quadword integers in xmm1 from xmm2 /m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG FB/r",
          "Instruction": "VPSUBQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed quadword integers in xmm3/m128 from xmm2."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG FB /r",
          "Instruction": "VPSUBQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed quadword integers in ymm3/m256 from ymm2."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 FB /r",
          "Instruction": "VPSUBQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed quadword integers in xmm3/m128/m64bcst from xmm2 and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 FB /r",
          "Instruction": "VPSUBQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed quadword integers in ymm3/m256/m64bcst from ymm2 and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 FB/r",
          "Instruction": "VPSUBQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Subtract packed quadword integers in zmm3/m512/m64bcst from zmm2 and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBSB",
      "Description": "Subtract Packed Signed Integers with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PSUBSB:PSUBSW.html",
      "Table": [
        {
          "Opcode": "NP 0F E8 /r1",
          "Instruction": "PSUBSB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract signed packed bytes in mm/m64 from signed packed bytes in mm and saturate results."
        },
        {
          "Opcode": "66 0F E8 /r",
          "Instruction": "PSUBSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed signed byte integers in xmm2/m128 from packed signed byte integers in xmm1 and saturate results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E8 /r",
          "Instruction": "VPSUBSB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E8 /r",
          "Instruction": "VPSUBSB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E8 /r",
          "Instruction": "VPSUBSB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed signed byte integers in xmm3/m128 from packed signed byte integers in xmm2 and saturate results and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E8 /r",
          "Instruction": "VPSUBSB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed signed byte integers in ymm3/m256 from packed signed byte integers in ymm2 and saturate results and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG E8 /r",
          "Instruction": "VPSUBSB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Subtract packed signed byte integers in zmm3/m512 from packed signed byte integers in zmm2 and saturate results and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBSW",
      "Description": "Subtract Packed Signed Integers with Signed Saturation",
      "Url": "https://www.felixcloutier.com/x86/PSUBSB:PSUBSW.html",
      "Table": [
        {
          "Opcode": "NP 0F E9 /r1",
          "Instruction": "PSUBSW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract signed packed words in mm/m64 from signed packed words in mm and saturate results."
        },
        {
          "Opcode": "66 0F E9 /r",
          "Instruction": "PSUBSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed signed word integers in xmm2/m128 from packed signed word integers in xmm1 and saturate results."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG E9 /r",
          "Instruction": "VPSUBSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG E9 /r",
          "Instruction": "VPSUBSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG E9 /r",
          "Instruction": "VPSUBSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed signed word integers in xmm3/m128 from packed signed word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG E9 /r",
          "Instruction": "VPSUBSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed signed word integers in ymm3/m256 from packed signed word integers in ymm2 and saturate results and store in ymm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBUSB",
      "Description": "Subtract Packed Unsigned Integers with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PSUBUSB:PSUBUSW.html",
      "Table": [
        {
          "Opcode": "NP 0F D8 /r1",
          "Instruction": "PSUBUSB mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract unsigned packed bytes in mm/m64 from unsigned packed bytes in mm and saturate result."
        },
        {
          "Opcode": "66 0F D8 /r",
          "Instruction": "PSUBUSB xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed unsigned byte integers in xmm2/m128 from packed unsigned byte integers in xmm1 and saturate result."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D8 /r",
          "Instruction": "VPSUBUSB xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2 and saturate result."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D8 /r",
          "Instruction": "VPSUBUSB ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2 and saturate result."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG D8 /r",
          "Instruction": "VPSUBUSB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed unsigned byte integers in xmm3/m128 from packed unsigned byte integers in xmm2, saturate results and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG D8 /r",
          "Instruction": "VPSUBUSB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed unsigned byte integers in ymm3/m256 from packed unsigned byte integers in ymm2, saturate results and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG D8 /r",
          "Instruction": "VPSUBUSB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Subtract packed unsigned byte integers in zmm3/m512 from packed unsigned byte integers in zmm2, saturate results and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBUSW",
      "Description": "Subtract Packed Unsigned Integers with Unsigned Saturation",
      "Url": "https://www.felixcloutier.com/x86/PSUBUSB:PSUBUSW.html",
      "Table": [
        {
          "Opcode": "NP 0F D9 /r1",
          "Instruction": "PSUBUSW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract unsigned packed words in mm/m64 from unsigned packed words in mm and saturate result."
        },
        {
          "Opcode": "66 0F D9 /r",
          "Instruction": "PSUBUSW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed unsigned word integers in xmm2/m128 from packed unsigned word integers in xmm1 and saturate result."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG D9 /r",
          "Instruction": "VPSUBUSW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate result."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG D9 /r",
          "Instruction": "VPSUBUSW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2 and saturate result."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG D9 /r",
          "Instruction": "VPSUBUSW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed unsigned word integers in xmm3/m128 from packed unsigned word integers in xmm2 and saturate results and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG D9 /r",
          "Instruction": "VPSUBUSW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed unsigned word integers in ymm3/m256 from packed unsigned word integers in ymm2, saturate results and store in ymm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PSUBW",
      "Description": "Subtract Packed Integers",
      "Url": "https://www.felixcloutier.com/x86/PSUBB:PSUBW:PSUBD.html",
      "Table": [
        {
          "Opcode": "NP 0F F9 /r1",
          "Instruction": "PSUBW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Subtract packed word integers in mm/m64 from packed word integers in mm."
        },
        {
          "Opcode": "66 0F F9 /r",
          "Instruction": "PSUBW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed word integers in xmm2/m128 from packed word integers in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG F9 /r",
          "Instruction": "VPSUBW xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed word integers in xmm3/m128 from xmm2."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG F9 /r",
          "Instruction": "VPSUBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Subtract packed word integers in ymm3/m256 from ymm2."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG F9 /r",
          "Instruction": "VPSUBW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed word integers in xmm3/m128 from xmm2 and store in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.WIG F9 /r",
          "Instruction": "VPSUBW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Subtract packed word integers in ymm3/m256 from ymm2 and store in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.WIG F9 /r",
          "Instruction": "VPSUBW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Subtract packed word integers in zmm3/m512 from zmm2 and store in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "PTEST",
      "Description": "Logical Compare",
      "Url": "https://www.felixcloutier.com/x86/PTEST.html",
      "Table": [
        {
          "Opcode": "66 0F 38 17 /r",
          "Instruction": "PTEST xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE4_1",
          "Description": "Set ZF if xmm2/m128 AND xmm1 result is all 0s. Set CF if xmm2/m128 AND NOT xmm1 result is all 0s."
        },
        {
          "Opcode": "VEX.128.66.0F38.WIG 17 /r",
          "Instruction": "VPTEST xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on bitwise AND and ANDN of sources."
        },
        {
          "Opcode": "VEX.256.66.0F38.WIG 17 /r",
          "Instruction": "VPTEST ymm1, ymm2/m256",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on bitwise AND and ANDN of sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PTWRITE",
      "Description": "Write Data to a Processor Trace Packet",
      "Url": "https://www.felixcloutier.com/x86/PTWRITE.html",
      "Table": [
        {
          "Opcode": "F3 REX.W 0F AE /4",
          "Instruction": "PTWRITE r64/m64",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/N.E",
          "Description": "Reads the data from r64/m64 to encode into a PTW packet if dependencies are met (see details below)."
        },
        {
          "Opcode": "F3 0F AE /4",
          "Instruction": "PTWRITE r32/m32",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Reads the data from r32/m32 to encode into a PTW packet if dependencies are met (see details below)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:rm (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKHBW",
      "Description": "Unpack High Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 68 /r1",
          "Instruction": "PUNPCKHBW mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Unpack and interleave high-order bytes from mm and mm/m64 into mm."
        },
        {
          "Opcode": "66 0F 68 /r",
          "Instruction": "PUNPCKHBW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpack and interleave high-order bytes from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 68/r",
          "Instruction": "VPUNPCKHBW xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 68 /r",
          "Instruction": "VPUNPCKHBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave high-order bytes from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 68 /r",
          "Instruction": "VPUNPCKHBW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Interleave high-order bytes from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKHDQ",
      "Description": "Unpack High Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 6A /r1",
          "Instruction": "PUNPCKHDQ mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Unpack and interleave high-order doublewords from mm and mm/m64 into mm."
        },
        {
          "Opcode": "66 0F 6A /r",
          "Instruction": "PUNPCKHDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpack and interleave high-order doublewords from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 6A/r",
          "Instruction": "VPUNPCKHDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave high-order doublewords from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 6A /r",
          "Instruction": "VPUNPCKHDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave high-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 6A /r",
          "Instruction": "VPUNPCKHDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Interleave high-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register using k1 write mask."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKHQDQ",
      "Description": "Unpack High Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 6D /r",
          "Instruction": "PUNPCKHQDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpack and interleave high-order quadwords from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 6D/r",
          "Instruction": "VPUNPCKHQDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave high-order quadword from xmm2 and xmm3/m128 into xmm1 register."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 6D /r",
          "Instruction": "VPUNPCKHQDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave high-order quadword from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 6D /r",
          "Instruction": "VPUNPCKHQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Interleave high-order quadword from xmm2 and xmm3/m128/m64bcst into xmm1 register using k1 write mask."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKHWD",
      "Description": "Unpack High Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKHBW:PUNPCKHWD:PUNPCKHDQ:PUNPCKHQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 69 /r1",
          "Instruction": "PUNPCKHWD mm, mm/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Unpack and interleave high-order words from mm and mm/m64 into mm."
        },
        {
          "Opcode": "66 0F 69 /r",
          "Instruction": "PUNPCKHWD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpack and interleave high-order words from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 69/r",
          "Instruction": "VPUNPCKHWD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 69 /r",
          "Instruction": "VPUNPCKHWD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave high-order words from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 69 /r",
          "Instruction": "VPUNPCKHWD xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Interleave high-order words from xmm2 and xmm3/m128 into xmm1 register using k1 write mask."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKLBW",
      "Description": "Unpack Low Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 60 /r1",
          "Instruction": "PUNPCKLBW mm, mm/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Interleave low-order bytes from mm and mm/m32 into mm."
        },
        {
          "Opcode": "66 0F 60 /r",
          "Instruction": "PUNPCKLBW xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Interleave low-order bytes from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 60/r",
          "Instruction": "VPUNPCKLBW xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 60 /r",
          "Instruction": "VPUNPCKLBW ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave low-order bytes from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 60 /r",
          "Instruction": "VPUNPCKLBW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Interleave low-order bytes from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKLDQ",
      "Description": "Unpack Low Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 62 /r1",
          "Instruction": "PUNPCKLDQ mm, mm/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Interleave low-order doublewords from mm and mm/m32 into mm."
        },
        {
          "Opcode": "66 0F 62 /r",
          "Instruction": "PUNPCKLDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Interleave low-order doublewords from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 62/r",
          "Instruction": "VPUNPCKLDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave low-order doublewords from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 62 /r",
          "Instruction": "VPUNPCKLDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave low-order doublewords from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W0 62 /r",
          "Instruction": "VPUNPCKLDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Interleave low-order doublewords from xmm2 and xmm3/m128/m32bcst into xmm1 register subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKLQDQ",
      "Description": "Unpack Low Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html",
      "Table": [
        {
          "Opcode": "66 0F 6C /r",
          "Instruction": "PUNPCKLQDQ xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Interleave low-order quadword from xmm1 and xmm2/m128 into xmm1 register."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 6C/r",
          "Instruction": "VPUNPCKLQDQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave low-order quadword from xmm2 and xmm3/m128 into xmm1 register."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 6C /r",
          "Instruction": "VPUNPCKLQDQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave low-order quadword from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 6C /r",
          "Instruction": "VPUNPCKLQDQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Interleave low-order quadword from zmm2 and zmm3/m512/m64bcst into zmm1 register subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PUNPCKLWD",
      "Description": "Unpack Low Data",
      "Url": "https://www.felixcloutier.com/x86/PUNPCKLBW:PUNPCKLWD:PUNPCKLDQ:PUNPCKLQDQ.html",
      "Table": [
        {
          "Opcode": "NP 0F 61 /r1",
          "Instruction": "PUNPCKLWD mm, mm/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "MMX",
          "Description": "Interleave low-order words from mm and mm/m32 into mm."
        },
        {
          "Opcode": "66 0F 61 /r",
          "Instruction": "PUNPCKLWD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Interleave low-order words from xmm1 and xmm2/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 61/r",
          "Instruction": "VPUNPCKLWD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 61 /r",
          "Instruction": "VPUNPCKLWD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Interleave low-order words from ymm2 and ymm3/m256 into ymm1 register."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.WIG 61 /r",
          "Instruction": "VPUNPCKLWD xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Interleave low-order words from xmm2 and xmm3/m128 into xmm1 register subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "PUSH",
      "Description": "Push Word, Doubleword or Quadword Onto the Stack",
      "Url": "https://www.felixcloutier.com/x86/PUSH.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (r)"
          ]
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PUSHA",
      "Description": "Push All General-Purpose Registers",
      "Url": "https://www.felixcloutier.com/x86/PUSHA:PUSHAD.html",
      "Table": [
        {
          "Opcode": "60",
          "Instruction": "PUSHA",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Push AX, CX, DX, BX, original SP, BP, SI, and DI."
        },
        {
          "Opcode": "60",
          "Instruction": "PUSHAD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PUSHAD",
      "Description": "Push All General-Purpose Registers",
      "Url": "https://www.felixcloutier.com/x86/PUSHA:PUSHAD.html",
      "Table": [
        {
          "Opcode": "60",
          "Instruction": "PUSHA",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Push AX, CX, DX, BX, original SP, BP, SI, and DI."
        },
        {
          "Opcode": "60",
          "Instruction": "PUSHAD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Push EAX, ECX, EDX, EBX, original ESP, EBP, ESI, and EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PUSHF",
      "Description": "Push EFLAGS Register onto the Stack",
      "Url": "https://www.felixcloutier.com/x86/PUSHF:PUSHFD:PUSHFQ.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PUSHFD",
      "Description": "Push EFLAGS Register onto the Stack",
      "Url": "https://www.felixcloutier.com/x86/PUSHF:PUSHFD:PUSHFQ.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PUSHFQ",
      "Description": "Push EFLAGS Register onto the Stack",
      "Url": "https://www.felixcloutier.com/x86/PUSHF:PUSHFD:PUSHFQ.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "PXOR",
      "Description": "Logical Exclusive OR",
      "Url": "https://www.felixcloutier.com/x86/PXOR.html"
    },
    {
      "Mnemonic": "RCL",
      "Description": "Rotate",
      "Url": "https://www.felixcloutier.com/x86/RCL:RCR:ROL:ROR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RCPPS",
      "Description": "Compute Reciprocals of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/RCPPS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RCPSS",
      "Description": "Compute Reciprocal of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/RCPSS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RCR",
      "Description": "Rotate",
      "Url": "https://www.felixcloutier.com/x86/RCL:RCR:ROL:ROR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDFSBASE",
      "Description": "Read FS/GS Segment Base",
      "Url": "https://www.felixcloutier.com/x86/RDFSBASE:RDGSBASE.html",
      "Table": [
        {
          "Opcode": "F3 0F AE /0",
          "Instruction": "RDFSBASE r32",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the 32-bit destination register with the FS base address."
        },
        {
          "Opcode": "F3 REX.W 0F AE /0",
          "Instruction": "RDFSBASE r64",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the 64-bit destination register with the FS base address."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDGSBASE",
      "Description": "Read FS/GS Segment Base",
      "Url": "https://www.felixcloutier.com/x86/RDFSBASE:RDGSBASE.html",
      "Table": [
        {
          "Opcode": "F3 0F AE /1",
          "Instruction": "RDGSBASE r32",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the 32-bit destination register with the GS base address."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDMSR",
      "Description": "Read from Model Specific Register",
      "Url": "https://www.felixcloutier.com/x86/RDMSR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RDPID",
      "Description": "Read Processor ID",
      "Url": "https://www.felixcloutier.com/x86/RDPID.html",
      "Table": [
        {
          "Opcode": "F3 0F C7 /7",
          "Instruction": "RDPID r32",
          "OperandEncoding": "R",
          "CpuidFeatureFlag": "RDPID",
          "Description": "Read IA32_TSC_AUX into r32."
        },
        {
          "Opcode": "F3 0F C7 /7",
          "Instruction": "RDPID r64",
          "OperandEncoding": "R",
          "CpuidFeatureFlag": "RDPID",
          "Description": "Read IA32_TSC_AUX into r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "R",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDPKRU",
      "Description": "Read Protection Key Rights for User Pages",
      "Url": "https://www.felixcloutier.com/x86/RDPKRU.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RDPMC",
      "Description": "Read Performance-Monitoring Counters",
      "Url": "https://www.felixcloutier.com/x86/RDPMC.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RDRAND",
      "Description": "Read Random Number",
      "Url": "https://www.felixcloutier.com/x86/RDRAND.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDSEED",
      "Description": "Read Random SEED",
      "Url": "https://www.felixcloutier.com/x86/RDSEED.html",
      "Table": [
        {
          "Opcode": "0F C7 /7",
          "Instruction": "RDSEED r16",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "RDSEED",
          "Description": "Read a 16-bit NIST SP800-90B &amp; C compliant random value and store in the destination register."
        },
        {
          "Opcode": "0F C7 /7",
          "Instruction": "RDSEED r32",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "RDSEED",
          "Description": "Read a 32-bit NIST SP800-90B &amp; C compliant random value and store in the destination register."
        },
        {
          "Opcode": "REX.W + 0F C7 /7",
          "Instruction": "RDSEED r64",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/I",
          "CpuidFeatureFlag": "RDSEED",
          "Description": "Read a 64-bit NIST SP800-90B &amp; C compliant random value and store in the destination register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RDTSC",
      "Description": "Read Time-Stamp Counter",
      "Url": "https://www.felixcloutier.com/x86/RDTSC.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RDTSCP",
      "Description": "Read Time-Stamp Counter and Processor ID",
      "Url": "https://www.felixcloutier.com/x86/RDTSCP.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "REP",
      "Description": "Repeat String Operation Prefix",
      "Url": "https://www.felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html",
      "Table": [
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX bytes from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX bytes from port DX into [RDI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX words from port DX into ES:[(E)DI.]"
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS r/m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX default size from port DX into [RDI]."
        },
        {
          "Opcode": "F3 A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX bytes from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A5",
          "Instruction": "REP MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX quadwords from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 6E",
          "Instruction": "REP OUTS DX, r/m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6E",
          "Instruction": "REP OUTS DX, r/m8*",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX bytes from [RSI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX words from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX default size from [RSI] to port DX."
        },
        {
          "Opcode": "F3 AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX bytes from DS:[(E)SI] to AL."
        },
        {
          "Opcode": "F3 REX.W AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX bytes from [RSI] to AL."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS AX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX words from DS:[(E)SI] to AX."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS EAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
        },
        {
          "Opcode": "F3 REX.W AD",
          "Instruction": "REP LODS RAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX quadwords from [RSI] to RAX."
        },
        {
          "Opcode": "F3 AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL."
        },
        {
          "Opcode": "F3 REX.W AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX bytes at [RDI] with AL."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX words at ES:[(E)DI] with AX."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
        },
        {
          "Opcode": "F3 REX.W AB",
          "Instruction": "REP STOS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX quadwords at [RDI] with RAX."
        },
        {
          "Opcode": "F3 A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A7",
          "Instruction": "REPE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching quadwords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AL byte starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-AL byte starting at [RDI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AX word starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-EAX doubleword starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AF",
          "Instruction": "REPE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-RAX quadword starting at [RDI]."
        },
        {
          "Opcode": "F2 A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A7",
          "Instruction": "REPNE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching doublewords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AL, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find AL, starting at [RDI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find EAX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AF",
          "Instruction": "REPNE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find RAX, starting at [RDI]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "REPE",
      "Description": "Repeat String Operation Prefix",
      "Url": "https://www.felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html",
      "Table": [
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX bytes from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX bytes from port DX into [RDI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX words from port DX into ES:[(E)DI.]"
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS r/m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX default size from port DX into [RDI]."
        },
        {
          "Opcode": "F3 A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX bytes from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A5",
          "Instruction": "REP MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX quadwords from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 6E",
          "Instruction": "REP OUTS DX, r/m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6E",
          "Instruction": "REP OUTS DX, r/m8*",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX bytes from [RSI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX words from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX default size from [RSI] to port DX."
        },
        {
          "Opcode": "F3 AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX bytes from DS:[(E)SI] to AL."
        },
        {
          "Opcode": "F3 REX.W AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX bytes from [RSI] to AL."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS AX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX words from DS:[(E)SI] to AX."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS EAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
        },
        {
          "Opcode": "F3 REX.W AD",
          "Instruction": "REP LODS RAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX quadwords from [RSI] to RAX."
        },
        {
          "Opcode": "F3 AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL."
        },
        {
          "Opcode": "F3 REX.W AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX bytes at [RDI] with AL."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX words at ES:[(E)DI] with AX."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
        },
        {
          "Opcode": "F3 REX.W AB",
          "Instruction": "REP STOS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX quadwords at [RDI] with RAX."
        },
        {
          "Opcode": "F3 A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A7",
          "Instruction": "REPE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching quadwords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AL byte starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-AL byte starting at [RDI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AX word starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-EAX doubleword starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AF",
          "Instruction": "REPE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-RAX quadword starting at [RDI]."
        },
        {
          "Opcode": "F2 A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A7",
          "Instruction": "REPNE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching doublewords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AL, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find AL, starting at [RDI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find EAX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AF",
          "Instruction": "REPNE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find RAX, starting at [RDI]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "REPNE",
      "Description": "Repeat String Operation Prefix",
      "Url": "https://www.felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html",
      "Table": [
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX bytes from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX bytes from port DX into [RDI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX words from port DX into ES:[(E)DI.]"
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS r/m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX default size from port DX into [RDI]."
        },
        {
          "Opcode": "F3 A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX bytes from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A5",
          "Instruction": "REP MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX quadwords from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 6E",
          "Instruction": "REP OUTS DX, r/m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6E",
          "Instruction": "REP OUTS DX, r/m8*",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX bytes from [RSI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX words from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX default size from [RSI] to port DX."
        },
        {
          "Opcode": "F3 AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX bytes from DS:[(E)SI] to AL."
        },
        {
          "Opcode": "F3 REX.W AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX bytes from [RSI] to AL."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS AX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX words from DS:[(E)SI] to AX."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS EAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
        },
        {
          "Opcode": "F3 REX.W AD",
          "Instruction": "REP LODS RAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX quadwords from [RSI] to RAX."
        },
        {
          "Opcode": "F3 AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL."
        },
        {
          "Opcode": "F3 REX.W AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX bytes at [RDI] with AL."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX words at ES:[(E)DI] with AX."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
        },
        {
          "Opcode": "F3 REX.W AB",
          "Instruction": "REP STOS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX quadwords at [RDI] with RAX."
        },
        {
          "Opcode": "F3 A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A7",
          "Instruction": "REPE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching quadwords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AL byte starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-AL byte starting at [RDI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AX word starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-EAX doubleword starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AF",
          "Instruction": "REPE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-RAX quadword starting at [RDI]."
        },
        {
          "Opcode": "F2 A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A7",
          "Instruction": "REPNE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching doublewords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AL, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find AL, starting at [RDI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find EAX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AF",
          "Instruction": "REPNE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find RAX, starting at [RDI]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "REPNZ",
      "Description": "Repeat String Operation Prefix",
      "Url": "https://www.felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html",
      "Table": [
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX bytes from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX bytes from port DX into [RDI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX words from port DX into ES:[(E)DI.]"
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS r/m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX default size from port DX into [RDI]."
        },
        {
          "Opcode": "F3 A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX bytes from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A5",
          "Instruction": "REP MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX quadwords from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 6E",
          "Instruction": "REP OUTS DX, r/m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6E",
          "Instruction": "REP OUTS DX, r/m8*",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX bytes from [RSI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX words from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX default size from [RSI] to port DX."
        },
        {
          "Opcode": "F3 AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX bytes from DS:[(E)SI] to AL."
        },
        {
          "Opcode": "F3 REX.W AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX bytes from [RSI] to AL."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS AX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX words from DS:[(E)SI] to AX."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS EAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
        },
        {
          "Opcode": "F3 REX.W AD",
          "Instruction": "REP LODS RAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX quadwords from [RSI] to RAX."
        },
        {
          "Opcode": "F3 AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL."
        },
        {
          "Opcode": "F3 REX.W AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX bytes at [RDI] with AL."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX words at ES:[(E)DI] with AX."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
        },
        {
          "Opcode": "F3 REX.W AB",
          "Instruction": "REP STOS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX quadwords at [RDI] with RAX."
        },
        {
          "Opcode": "F3 A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A7",
          "Instruction": "REPE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching quadwords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AL byte starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-AL byte starting at [RDI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AX word starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-EAX doubleword starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AF",
          "Instruction": "REPE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-RAX quadword starting at [RDI]."
        },
        {
          "Opcode": "F2 A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A7",
          "Instruction": "REPNE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching doublewords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AL, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find AL, starting at [RDI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find EAX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AF",
          "Instruction": "REPNE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find RAX, starting at [RDI]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "REPZ",
      "Description": "Repeat String Operation Prefix",
      "Url": "https://www.felixcloutier.com/x86/REP:REPE:REPZ:REPNE:REPNZ.html",
      "Table": [
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX bytes from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6C",
          "Instruction": "REP INS m8, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX bytes from port DX into [RDI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m16, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX words from port DX into ES:[(E)DI.]"
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Input (E)CX doublewords from port DX into ES:[(E)DI]."
        },
        {
          "Opcode": "F3 6D",
          "Instruction": "REP INS r/m32, DX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Input RCX default size from port DX into [RDI]."
        },
        {
          "Opcode": "F3 A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX bytes from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A4",
          "Instruction": "REP MOVS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX bytes from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX words from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 A5",
          "Instruction": "REP MOVS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Move (E)CX doublewords from DS:[(E)SI] to ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W A5",
          "Instruction": "REP MOVS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Move RCX quadwords from [RSI] to [RDI]."
        },
        {
          "Opcode": "F3 6E",
          "Instruction": "REP OUTS DX, r/m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX bytes from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6E",
          "Instruction": "REP OUTS DX, r/m8*",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX bytes from [RSI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX words from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Output (E)CX doublewords from DS:[(E)SI] to port DX."
        },
        {
          "Opcode": "F3 REX.W 6F",
          "Instruction": "REP OUTS DX, r/m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Output RCX default size from [RSI] to port DX."
        },
        {
          "Opcode": "F3 AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX bytes from DS:[(E)SI] to AL."
        },
        {
          "Opcode": "F3 REX.W AC",
          "Instruction": "REP LODS AL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX bytes from [RSI] to AL."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS AX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX words from DS:[(E)SI] to AX."
        },
        {
          "Opcode": "F3 AD",
          "Instruction": "REP LODS EAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Load (E)CX doublewords from DS:[(E)SI] to EAX."
        },
        {
          "Opcode": "F3 REX.W AD",
          "Instruction": "REP LODS RAX",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Load RCX quadwords from [RSI] to RAX."
        },
        {
          "Opcode": "F3 AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX bytes at ES:[(E)DI] with AL."
        },
        {
          "Opcode": "F3 REX.W AA",
          "Instruction": "REP STOS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX bytes at [RDI] with AL."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX words at ES:[(E)DI] with AX."
        },
        {
          "Opcode": "F3 AB",
          "Instruction": "REP STOS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fill (E)CX doublewords at ES:[(E)DI] with EAX."
        },
        {
          "Opcode": "F3 REX.W AB",
          "Instruction": "REP STOS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Fill RCX quadwords at [RDI] with RAX."
        },
        {
          "Opcode": "F3 A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A6",
          "Instruction": "REPE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 A7",
          "Instruction": "REPE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find nonmatching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F3 REX.W A7",
          "Instruction": "REPE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-matching quadwords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F3 AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AL byte starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AE",
          "Instruction": "REPE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-AL byte starting at [RDI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-AX word starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 AF",
          "Instruction": "REPE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find non-EAX doubleword starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F3 REX.W AF",
          "Instruction": "REPE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find non-RAX quadword starting at [RDI]."
        },
        {
          "Opcode": "F2 A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching bytes in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A6",
          "Instruction": "REPNE CMPS m8, m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching bytes in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m16, m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching words in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 A7",
          "Instruction": "REPNE CMPS m32, m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find matching doublewords in ES:[(E)DI] and DS:[(E)SI]."
        },
        {
          "Opcode": "F2 REX.W A7",
          "Instruction": "REPNE CMPS m64, m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find matching doublewords in [RDI] and [RSI]."
        },
        {
          "Opcode": "F2 AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AL, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AE",
          "Instruction": "REPNE SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find AL, starting at [RDI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find AX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 AF",
          "Instruction": "REPNE SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Find EAX, starting at ES:[(E)DI]."
        },
        {
          "Opcode": "F2 REX.W AF",
          "Instruction": "REPNE SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Find RAX, starting at [RDI]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RET",
      "Description": "Return from Procedure",
      "Url": "https://www.felixcloutier.com/x86/RET.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "I",
          "Operands": [
            "imm16"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROL",
      "Description": "Rotate",
      "Url": "https://www.felixcloutier.com/x86/RCL:RCR:ROL:ROR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROR",
      "Description": "Rotate",
      "Url": "https://www.felixcloutier.com/x86/RCL:RCR:ROL:ROR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RORX",
      "Description": "Rotate Right Logical Without Affecting Flags",
      "Url": "https://www.felixcloutier.com/x86/RORX.html",
      "Table": [
        {
          "Opcode": "VEX.LZ.F2.0F3A.W0 F0 /r ib",
          "Instruction": "RORX r32, r/m32, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Rotate 32-bit r/m32 right imm8 times without affecting arithmetic flags."
        },
        {
          "Opcode": "VEX.LZ.F2.0F3A.W1 F0 /r ib",
          "Instruction": "RORX r64, r/m64, imm8",
          "OperandEncoding": "RMI",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Rotate 64-bit r/m64 right imm8 times without affecting arithmetic flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROUNDPD",
      "Description": "Round Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ROUNDPD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROUNDPS",
      "Description": "Round Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ROUNDPS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROUNDSD",
      "Description": "Round Scalar Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ROUNDSD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "ROUNDSS",
      "Description": "Round Scalar Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/ROUNDSS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RSM",
      "Description": "Resume from System Management Mode",
      "Url": "https://www.felixcloutier.com/x86/RSM.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "RSQRTPS",
      "Description": "Compute Reciprocals of Square Roots of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/RSQRTPS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "RSQRTSS",
      "Description": "Compute Reciprocal of Square Root of Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/RSQRTSS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SAHF",
      "Description": "Store AH into Flags",
      "Url": "https://www.felixcloutier.com/x86/SAHF.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SAL",
      "Description": "Shift",
      "Url": "https://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html",
      "Table": [
        {
          "Opcode": "REX.W + D1 /4",
          "Instruction": "SHL r/m64,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /4",
          "Instruction": "SHL r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /4",
          "Instruction": "SHL r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /4 ib",
          "Instruction": "SHL r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /4 ib",
          "Instruction": "SHL r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, imm8 times."
        },
        {
          "Opcode": "D0 /5",
          "Instruction": "SHR r/m8,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "REX + D0 /5",
          "Instruction": "SHR r/m8**, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "D2 /5",
          "Instruction": "SHR r/m8, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "REX + D2 /5",
          "Instruction": "SHR r/m8**, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "C0 /5 ib",
          "Instruction": "SHR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "REX + C0 /5 ib",
          "Instruction": "SHR r/m8**, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m16, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m16, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, CL times"
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m32, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, once."
        },
        {
          "Opcode": "REX.W + D1 /5",
          "Instruction": "SHR r/m64, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /5",
          "Instruction": "SHR r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /5 ib",
          "Instruction": "SHR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, imm8 times."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (r, w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (r, w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SAR",
      "Description": "Shift",
      "Url": "https://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html",
      "Table": [
        {
          "Opcode": "REX.W + D1 /4",
          "Instruction": "SHL r/m64,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /4",
          "Instruction": "SHL r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /4",
          "Instruction": "SHL r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /4 ib",
          "Instruction": "SHL r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /4 ib",
          "Instruction": "SHL r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, imm8 times."
        },
        {
          "Opcode": "D0 /5",
          "Instruction": "SHR r/m8,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "REX + D0 /5",
          "Instruction": "SHR r/m8**, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "D2 /5",
          "Instruction": "SHR r/m8, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "REX + D2 /5",
          "Instruction": "SHR r/m8**, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "C0 /5 ib",
          "Instruction": "SHR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "REX + C0 /5 ib",
          "Instruction": "SHR r/m8**, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m16, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m16, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, CL times"
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m32, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, once."
        },
        {
          "Opcode": "REX.W + D1 /5",
          "Instruction": "SHR r/m64, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /5",
          "Instruction": "SHR r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /5 ib",
          "Instruction": "SHR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, imm8 times."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (r, w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (r, w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SARX",
      "Description": "Shift Without Affecting Flags",
      "Url": "https://www.felixcloutier.com/x86/SARX:SHLX:SHRX.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.F3.0F38.W0 F7 /r",
          "Instruction": "SARX r32a, r/m32, r32b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m32 arithmetically right with count specified in r32b."
        },
        {
          "Opcode": "VEX.NDS.LZ.F3.0F38.W1 F7 /r",
          "Instruction": "SARX r64a, r/m64, r64b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m64 arithmetically right with count specified in r64b."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "VEX.vvvv (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SBB",
      "Description": "Integer Subtraction with Borrow",
      "Url": "https://www.felixcloutier.com/x86/SBB.html",
      "Table": [
        {
          "Opcode": "1C ib",
          "Instruction": "SBB AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm8 from AL."
        },
        {
          "Opcode": "1D iw",
          "Instruction": "SBB AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm16 from AX."
        },
        {
          "Opcode": "1D id",
          "Instruction": "SBB EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm32 from EAX."
        },
        {
          "Opcode": "REX.W + 1D id",
          "Instruction": "SBB RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow sign-extended imm.32 to 64-bits from RAX."
        },
        {
          "Opcode": "80 /3 ib",
          "Instruction": "SBB r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm8 from r/m8."
        },
        {
          "Opcode": "REX + 80 /3 ib",
          "Instruction": "SBB r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow imm8 from r/m8."
        },
        {
          "Opcode": "81 /3 iw",
          "Instruction": "SBB r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm16 from r/m16."
        },
        {
          "Opcode": "81 /3 id",
          "Instruction": "SBB r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow imm32 from r/m32."
        },
        {
          "Opcode": "REX.W + 81 /3 id",
          "Instruction": "SBB r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow sign-extended imm32 to 64-bits from r/m64."
        },
        {
          "Opcode": "83 /3 ib",
          "Instruction": "SBB r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow sign-extended imm8 from r/m16."
        },
        {
          "Opcode": "83 /3 ib",
          "Instruction": "SBB r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow sign-extended imm8 from r/m32."
        },
        {
          "Opcode": "REX.W + 83 /3 ib",
          "Instruction": "SBB r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow sign-extended imm8 from r/m64."
        },
        {
          "Opcode": "18 /r",
          "Instruction": "SBB r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r8 from r/m8."
        },
        {
          "Opcode": "REX + 18 /r",
          "Instruction": "SBB r/m8*, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow r8 from r/m8."
        },
        {
          "Opcode": "19 /r",
          "Instruction": "SBB r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r16 from r/m16."
        },
        {
          "Opcode": "19 /r",
          "Instruction": "SBB r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r32 from r/m32."
        },
        {
          "Opcode": "REX.W + 19 /r",
          "Instruction": "SBB r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow r64 from r/m64."
        },
        {
          "Opcode": "1A /r",
          "Instruction": "SBB r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r/m8 from r8."
        },
        {
          "Opcode": "REX + 1A /r",
          "Instruction": "SBB r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow r/m8 from r8."
        },
        {
          "Opcode": "1B /r",
          "Instruction": "SBB r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r/m16 from r16."
        },
        {
          "Opcode": "1B /r",
          "Instruction": "SBB r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract with borrow r/m32 from r32."
        },
        {
          "Opcode": "REX.W + 1B /r",
          "Instruction": "SBB r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Subtract with borrow r/m64 from r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SCAS",
      "Description": "Scan String",
      "Url": "https://www.felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html",
      "Table": [
        {
          "Opcode": "AE",
          "Instruction": "SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        },
        {
          "Opcode": "AE",
          "Instruction": "SCASB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCASQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SCASB",
      "Description": "Scan String",
      "Url": "https://www.felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html",
      "Table": [
        {
          "Opcode": "AE",
          "Instruction": "SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        },
        {
          "Opcode": "AE",
          "Instruction": "SCASB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCASQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SCASD",
      "Description": "Scan String",
      "Url": "https://www.felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html",
      "Table": [
        {
          "Opcode": "AE",
          "Instruction": "SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        },
        {
          "Opcode": "AE",
          "Instruction": "SCASB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCASQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SCASW",
      "Description": "Scan String",
      "Url": "https://www.felixcloutier.com/x86/SCAS:SCASB:SCASW:SCASD.html",
      "Table": [
        {
          "Opcode": "AE",
          "Instruction": "SCAS m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m16",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI, then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCAS m32",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCAS m64",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        },
        {
          "Opcode": "AE",
          "Instruction": "SCASB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AL with byte at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASW",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare AX with word at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "AF",
          "Instruction": "SCASD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Compare EAX with doubleword at ES:(E)DI or RDI then set status flags.*"
        },
        {
          "Opcode": "REX.W + AF",
          "Instruction": "SCASQ",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Compare RAX with quadword at RDI or EDI then set status flags."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SETcc",
      "Description": "Set Byte on Condition",
      "Url": "https://www.felixcloutier.com/x86/SETcc.html",
      "Table": [
        {
          "Opcode": "0F 97",
          "Instruction": "SETA r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "REX + 0F 97",
          "Instruction": "SETA r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if above (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 93",
          "Instruction": "SETAE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if above or equal (CF=0)."
        },
        {
          "Opcode": "REX + 0F 93",
          "Instruction": "SETAE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if above or equal (CF=0)."
        },
        {
          "Opcode": "0F 92",
          "Instruction": "SETB r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if below (CF=1)."
        },
        {
          "Opcode": "REX + 0F 92",
          "Instruction": "SETB r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if below (CF=1)."
        },
        {
          "Opcode": "0F 96",
          "Instruction": "SETBE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "REX + 0F 96",
          "Instruction": "SETBE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if below or equal (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 92",
          "Instruction": "SETC r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if carry (CF=1)."
        },
        {
          "Opcode": "REX + 0F 92",
          "Instruction": "SETC r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if carry (CF=1)."
        },
        {
          "Opcode": "0F 94",
          "Instruction": "SETE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if equal (ZF=1)."
        },
        {
          "Opcode": "REX + 0F 94",
          "Instruction": "SETE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if equal (ZF=1)."
        },
        {
          "Opcode": "0F 9F",
          "Instruction": "SETG r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "REX + 0F 9F",
          "Instruction": "SETG r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if greater (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 9D",
          "Instruction": "SETGE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if greater or equal (SF=OF)."
        },
        {
          "Opcode": "REX + 0F 9D",
          "Instruction": "SETGE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if greater or equal (SF=OF)."
        },
        {
          "Opcode": "0F 9C",
          "Instruction": "SETL r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if less (SF≠ OF)."
        },
        {
          "Opcode": "REX + 0F 9C",
          "Instruction": "SETL r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if less (SF≠ OF)."
        },
        {
          "Opcode": "0F 9E",
          "Instruction": "SETLE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "REX + 0F 9E",
          "Instruction": "SETLE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if less or equal (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 96",
          "Instruction": "SETNA r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "REX + 0F 96",
          "Instruction": "SETNA r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not above (CF=1 or ZF=1)."
        },
        {
          "Opcode": "0F 92",
          "Instruction": "SETNAE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not above or equal (CF=1)."
        },
        {
          "Opcode": "REX + 0F 92",
          "Instruction": "SETNAE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not above or equal (CF=1)."
        },
        {
          "Opcode": "0F 93",
          "Instruction": "SETNB r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not below (CF=0)."
        },
        {
          "Opcode": "REX + 0F 93",
          "Instruction": "SETNB r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not below (CF=0)."
        },
        {
          "Opcode": "0F 97",
          "Instruction": "SETNBE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "REX + 0F 97",
          "Instruction": "SETNBE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not below or equal (CF=0 and ZF=0)."
        },
        {
          "Opcode": "0F 93",
          "Instruction": "SETNC r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not carry (CF=0)."
        },
        {
          "Opcode": "REX + 0F 93",
          "Instruction": "SETNC r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not carry (CF=0)."
        },
        {
          "Opcode": "0F 95",
          "Instruction": "SETNE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not equal (ZF=0)."
        },
        {
          "Opcode": "REX + 0F 95",
          "Instruction": "SETNE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not equal (ZF=0)."
        },
        {
          "Opcode": "0F 9E",
          "Instruction": "SETNG r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not greater (ZF=1 or SF≠ OF)"
        },
        {
          "Opcode": "REX + 0F 9E",
          "Instruction": "SETNG r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not greater (ZF=1 or SF≠ OF)."
        },
        {
          "Opcode": "0F 9C",
          "Instruction": "SETNGE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "REX + 0F 9C",
          "Instruction": "SETNGE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not greater or equal (SF≠ OF)."
        },
        {
          "Opcode": "0F 9D",
          "Instruction": "SETNL r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not less (SF=OF)."
        },
        {
          "Opcode": "REX + 0F 9D",
          "Instruction": "SETNL r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not less (SF=OF)."
        },
        {
          "Opcode": "0F 9F",
          "Instruction": "SETNLE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "REX + 0F 9F",
          "Instruction": "SETNLE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not less or equal (ZF=0 and SF=OF)."
        },
        {
          "Opcode": "0F 91",
          "Instruction": "SETNO r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not overflow (OF=0)."
        },
        {
          "Opcode": "REX + 0F 91",
          "Instruction": "SETNO r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not overflow (OF=0)."
        },
        {
          "Opcode": "0F 9B",
          "Instruction": "SETNP r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not parity (PF=0)."
        },
        {
          "Opcode": "REX + 0F 9B",
          "Instruction": "SETNP r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not parity (PF=0)."
        },
        {
          "Opcode": "0F 99",
          "Instruction": "SETNS r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not sign (SF=0)."
        },
        {
          "Opcode": "REX + 0F 99",
          "Instruction": "SETNS r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not sign (SF=0)."
        },
        {
          "Opcode": "0F 95",
          "Instruction": "SETNZ r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if not zero (ZF=0)."
        },
        {
          "Opcode": "REX + 0F 95",
          "Instruction": "SETNZ r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if not zero (ZF=0)."
        },
        {
          "Opcode": "0F 90",
          "Instruction": "SETO r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if overflow (OF=1)"
        },
        {
          "Opcode": "REX + 0F 90",
          "Instruction": "SETO r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if overflow (OF=1)."
        },
        {
          "Opcode": "0F 9A",
          "Instruction": "SETP r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if parity (PF=1)."
        },
        {
          "Opcode": "REX + 0F 9A",
          "Instruction": "SETP r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if parity (PF=1)."
        },
        {
          "Opcode": "0F 9A",
          "Instruction": "SETPE r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if parity even (PF=1)."
        },
        {
          "Opcode": "REX + 0F 9A",
          "Instruction": "SETPE r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if parity even (PF=1)."
        },
        {
          "Opcode": "0F 9B",
          "Instruction": "SETPO r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if parity odd (PF=0)."
        },
        {
          "Opcode": "REX + 0F 9B",
          "Instruction": "SETPO r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if parity odd (PF=0)."
        },
        {
          "Opcode": "0F 98",
          "Instruction": "SETS r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if sign (SF=1)."
        },
        {
          "Opcode": "REX + 0F 98",
          "Instruction": "SETS r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if sign (SF=1)."
        },
        {
          "Opcode": "0F 94",
          "Instruction": "SETZ r/m8",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set byte if zero (ZF=1)."
        },
        {
          "Opcode": "REX + 0F 94",
          "Instruction": "SETZ r/m8*",
          "OperandEncoding": "M",
          "CompatLegMode": "N.E.",
          "Description": "Set byte if zero (ZF=1)."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SFENCE",
      "Description": "Store Fence",
      "Url": "https://www.felixcloutier.com/x86/SFENCE.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SGDT",
      "Description": "Store Global Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/SGDT.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA1MSG1",
      "Description": "Perform an Intermediate Calculation for the Next Four SHA1 Message Dwords",
      "Url": "https://www.felixcloutier.com/x86/SHA1MSG1.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 C9 /r",
          "Instruction": "SHA1MSG1 xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Performs an intermediate calculation for the next four SHA1 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA1MSG2",
      "Description": "Perform a Final Calculation for the Next Four SHA1 Message Dwords",
      "Url": "https://www.felixcloutier.com/x86/SHA1MSG2.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 CA /r",
          "Instruction": "SHA1MSG2 xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Performs the final calculation for the next four SHA1 message dwords using intermediate results from xmm1 and the previous message dwords from xmm2/m128, storing the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA1NEXTE",
      "Description": "Calculate SHA1 State Variable E after Four Rounds",
      "Url": "https://www.felixcloutier.com/x86/SHA1NEXTE.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 C8 /r",
          "Instruction": "SHA1NEXTE xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Calculates SHA1 state variable E after four rounds of operation from the current SHA1 state variable A in xmm1. The calculated value of the SHA1 state variable E is added to the scheduled dwords in xmm2/m128, and stored with some of the scheduled dwords in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA1RNDS4",
      "Description": "Perform Four Rounds of SHA1 Operation",
      "Url": "https://www.felixcloutier.com/x86/SHA1RNDS4.html",
      "Table": [
        {
          "Opcode": "NP 0F 3A CC /r ib",
          "Instruction": "SHA1RNDS4 xmm1, xmm2/m128, imm8",
          "OperandEncoding": "RMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Performs four rounds of SHA1 operation operating on SHA1 state (A,B,C,D) from xmm1, with a pre-computed sum of the next 4 round message dwords and state variable E from xmm2/m128. The immediate byte controls logic functions and round constants."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA256MSG1",
      "Description": "Perform an Intermediate Calculation for the Next Four SHA256 Message Dwords",
      "Url": "https://www.felixcloutier.com/x86/SHA256MSG1.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 CC /r",
          "Instruction": "SHA256MSG1 xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Performs an intermediate calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA256MSG2",
      "Description": "Perform a Final Calculation for the Next Four SHA256 Message Dwords",
      "Url": "https://www.felixcloutier.com/x86/SHA256MSG2.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 CD /r",
          "Instruction": "SHA256MSG2 xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Performs the final calculation for the next four SHA256 message dwords using previous message dwords from xmm1 and xmm2/m128, storing the result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHA256RNDS2",
      "Description": "Perform Two Rounds of SHA256 Operation",
      "Url": "https://www.felixcloutier.com/x86/SHA256RNDS2.html",
      "Table": [
        {
          "Opcode": "NP 0F 38 CB /r",
          "Instruction": "SHA256RNDS2 xmm1, xmm2/m128, &lt;XMM0&gt;",
          "OperandEncoding": "RM0",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SHA",
          "Description": "Perform 2 rounds of SHA256 operation using an initial SHA256 state (C,D,G,H) from xmm1, an initial SHA256 state (A,B,E,F) from xmm2/m128, and a pre-computed sum of the next 2 round message dwords and the corresponding round constants from the implicit operand XMM0, storing the updated SHA256 state (A,B,E,F) result in xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMI",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)",
            "Implicit XMM0 (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHL",
      "Description": "Shift",
      "Url": "https://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html",
      "Table": [
        {
          "Opcode": "REX.W + D1 /4",
          "Instruction": "SHL r/m64,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /4",
          "Instruction": "SHL r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /4",
          "Instruction": "SHL r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /4 ib",
          "Instruction": "SHL r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /4 ib",
          "Instruction": "SHL r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, imm8 times."
        },
        {
          "Opcode": "D0 /5",
          "Instruction": "SHR r/m8,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "REX + D0 /5",
          "Instruction": "SHR r/m8**, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "D2 /5",
          "Instruction": "SHR r/m8, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "REX + D2 /5",
          "Instruction": "SHR r/m8**, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "C0 /5 ib",
          "Instruction": "SHR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "REX + C0 /5 ib",
          "Instruction": "SHR r/m8**, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m16, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m16, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, CL times"
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m32, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, once."
        },
        {
          "Opcode": "REX.W + D1 /5",
          "Instruction": "SHR r/m64, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /5",
          "Instruction": "SHR r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /5 ib",
          "Instruction": "SHR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, imm8 times."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (r, w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (r, w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHLD",
      "Description": "Double Precision Shift Left",
      "Url": "https://www.felixcloutier.com/x86/SHLD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "MRI",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "MRC",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)",
            "CL"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHLX",
      "Description": "Shift Without Affecting Flags",
      "Url": "https://www.felixcloutier.com/x86/SARX:SHLX:SHRX.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.66.0F38.W0 F7 /r",
          "Instruction": "SHLX r32a, r/m32, r32b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m32 logically left with count specified in r32b."
        },
        {
          "Opcode": "VEX.NDS.LZ.66.0F38.W1 F7 /r",
          "Instruction": "SHLX r64a, r/m64, r64b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m64 logically left with count specified in r64b."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "VEX.vvvv (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHR",
      "Description": "Shift",
      "Url": "https://www.felixcloutier.com/x86/SAL:SAR:SHL:SHR.html",
      "Table": [
        {
          "Opcode": "REX.W + D1 /4",
          "Instruction": "SHL r/m64,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /4",
          "Instruction": "SHL r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /4",
          "Instruction": "SHL r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /4 ib",
          "Instruction": "SHL r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Multiply r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /4 ib",
          "Instruction": "SHL r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Multiply r/m64 by 2, imm8 times."
        },
        {
          "Opcode": "D0 /5",
          "Instruction": "SHR r/m8,1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "REX + D0 /5",
          "Instruction": "SHR r/m8**, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, once."
        },
        {
          "Opcode": "D2 /5",
          "Instruction": "SHR r/m8, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "REX + D2 /5",
          "Instruction": "SHR r/m8**, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, CL times."
        },
        {
          "Opcode": "C0 /5 ib",
          "Instruction": "SHR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "REX + C0 /5 ib",
          "Instruction": "SHR r/m8**, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m8 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m16, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m16, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, CL times"
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m16 by 2, imm8 times."
        },
        {
          "Opcode": "D1 /5",
          "Instruction": "SHR r/m32, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, once."
        },
        {
          "Opcode": "REX.W + D1 /5",
          "Instruction": "SHR r/m64, 1",
          "OperandEncoding": "M1",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, once."
        },
        {
          "Opcode": "D3 /5",
          "Instruction": "SHR r/m32, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, CL times."
        },
        {
          "Opcode": "REX.W + D3 /5",
          "Instruction": "SHR r/m64, CL",
          "OperandEncoding": "MC",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, CL times."
        },
        {
          "Opcode": "C1 /5 ib",
          "Instruction": "SHR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Unsigned divide r/m32 by 2, imm8 times."
        },
        {
          "Opcode": "REX.W + C1 /5 ib",
          "Instruction": "SHR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Unsigned divide r/m64 by 2, imm8 times."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M1",
          "Operands": [
            "ModRM:r/m (r, w)",
            "1"
          ]
        },
        {
          "OperandEncoding": "MC",
          "Operands": [
            "ModRM:r/m (r, w)",
            "CL"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHRD",
      "Description": "Double Precision Shift Right",
      "Url": "https://www.felixcloutier.com/x86/SHRD.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "MRI",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)",
            "imm8"
          ]
        },
        {
          "OperandEncoding": "MRC",
          "Operands": [
            "ModRM:r/m (w)",
            "ModRM:reg (r)",
            "CL"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHRX",
      "Description": "Shift Without Affecting Flags",
      "Url": "https://www.felixcloutier.com/x86/SARX:SHLX:SHRX.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.LZ.F2.0F38.W0 F7 /r",
          "Instruction": "SHRX r32a, r/m32, r32b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m32 logically right with count specified in r32b."
        },
        {
          "Opcode": "VEX.NDS.LZ.F2.0F38.W1 F7 /r",
          "Instruction": "SHRX r64a, r/m64, r64b",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "BMI2",
          "Description": "Shift r/m64 logically right with count specified in r64b."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)",
            "VEX.vvvv (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SHUFPD",
      "Description": "Packed Interleave Shuffle of Pairs of Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SHUFPD.html",
      "Table": [
        {
          "Opcode": "66 0F C6 /r ib",
          "Instruction": "SHUFPD xmm1, xmm2/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Shuffle two pairs of double-precision floating-point values from xmm1 and xmm2/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG C6 /r ib",
          "Instruction": "VSHUFPD xmm1, xmm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle two pairs of double-precision floating-point values from xmm2 and xmm3/m128 using imm8 to select from each pair, interleaved result is stored in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG C6 /r ib",
          "Instruction": "VSHUFPD ymm1, ymm2, ymm3/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Shuffle four pairs of double-precision floating-point values from ymm2 and ymm3/m256 using imm8 to select from each pair, interleaved result is stored in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 C6 /r ib",
          "Instruction": "VSHUFPD xmm1{k1}{z}, xmm2, xmm3/m128/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shuffle two paris of double-precision floating-point values from xmm2 and xmm3/m128/m64bcst using imm8 to select from each pair. store interleaved results in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 C6 /r ib",
          "Instruction": "VSHUFPD ymm1{k1}{z}, ymm2, ymm3/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shuffle four paris of double-precision floating-point values from ymm2 and ymm3/m256/m64bcst using imm8 to select from each pair. store interleaved results in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 C6 /r ib",
          "Instruction": "VSHUFPD zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle eight paris of double-precision floating-point values from zmm2 and zmm3/m512/m64bcst using imm8 to select from each pair. store interleaved results in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SHUFPS",
      "Description": "Packed Interleave Shuffle of Quadruplets of Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SHUFPS.html",
      "Table": [
        {
          "Opcode": "NP 0F C6 /r ib",
          "Instruction": "SHUFPS xmm1, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG C6 /r ib",
          "Instruction": "VSHUFPS xmm1, xmm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG C6 /r ib",
          "Instruction": "VSHUFPS ymm1, ymm2, ymm3/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 C6 /r ib",
          "Instruction": "VSHUFPS xmm1{k1}{z}, xmm2, xmm3/m128/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Select from quadruplet of single-precision floating-point values in xmm1 and xmm2/m128 using imm8, interleaved result pairs are stored in xmm1, subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 C6 /r ib",
          "Instruction": "VSHUFPS ymm1{k1}{z}, ymm2, ymm3/m256/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Select from quadruplet of single-precision floating-point values in ymm2 and ymm3/m256 using imm8, interleaved result pairs are stored in ymm1, subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 C6 /r ib",
          "Instruction": "VSHUFPS zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Select from quadruplet of single-precision floating-point values in zmm2 and zmm3/m512 using imm8, interleaved result pairs are stored in zmm1, subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SIDT",
      "Description": "Store Interrupt Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/SIDT.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SLDT",
      "Description": "Store Local Descriptor Table Register",
      "Url": "https://www.felixcloutier.com/x86/SLDT.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SMSW",
      "Description": "Store Machine Status Word",
      "Url": "https://www.felixcloutier.com/x86/SMSW.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SQRTPD",
      "Description": "Square Root of Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SQRTPD.html",
      "Table": [
        {
          "Opcode": "66 0F 51 /r",
          "Instruction": "SQRTPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F.WIG 51 /r",
          "Instruction": "VSQRTPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128 and stores the result in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F.WIG 51 /r",
          "Instruction": "VSQRTPD ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256 and stores the result in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 51 /r",
          "Instruction": "VSQRTPD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 51 /r",
          "Instruction": "VSQRTPD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 51 /r",
          "Instruction": "VSQRTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes Square Roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SQRTPS",
      "Description": "Square Root of Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SQRTPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 51 /r",
          "Instruction": "SQRTPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
        },
        {
          "Opcode": "VEX.128.0F.WIG 51 /r",
          "Instruction": "VSQRTPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128 and stores the result in xmm1."
        },
        {
          "Opcode": "VEX.256.0F.WIG 51/r",
          "Instruction": "VSQRTPS ymm1, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256 and stores the result in ymm1."
        },
        {
          "Opcode": "EVEX.128.0F.W0 51 /r",
          "Instruction": "VSQRTPS xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 51 /r",
          "Instruction": "VSQRTPS ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 51/r",
          "Instruction": "VSQRTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes Square Roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SQRTSD",
      "Description": "Compute Square Root of Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/SQRTSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 51/r",
          "Instruction": "SQRTSD xmm1,xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Computes square root of the low double-precision floating-point value in xmm2/m64 and stores the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 51/r",
          "Instruction": "VSQRTSD xmm1,xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 51/r",
          "Instruction": "VSQRTSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes square root of the low double-precision floating-point value in xmm3/m64 and stores the results in xmm1 under writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
        }
      ]
    },
    {
      "Mnemonic": "SQRTSS",
      "Description": "Compute Square Root of Scalar Single-Precision Value",
      "Url": "https://www.felixcloutier.com/x86/SQRTSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 51 /r",
          "Instruction": "SQRTSS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Computes square root of the low single-precision floating-point value in xmm2/m32 and stores the results in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 51 /r",
          "Instruction": "VSQRTSS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 51 /r",
          "Instruction": "VSQRTSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes square root of the low single-precision floating-point value in xmm3/m32 and stores the results in xmm1 under writemask k1. Also, upper single-precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]."
        }
      ]
    },
    {
      "Mnemonic": "STAC",
      "Description": "Set AC Flag in EFLAGS Register",
      "Url": "https://www.felixcloutier.com/x86/STAC.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 CB",
          "Instruction": "STAC",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SMAP",
          "Description": "Set the AC flag in the EFLAGS register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STC",
      "Description": "Set Carry Flag",
      "Url": "https://www.felixcloutier.com/x86/STC.html",
      "Table": [
        {
          "Opcode": "F9",
          "Instruction": "STC",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set CF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STD",
      "Description": "Set Direction Flag",
      "Url": "https://www.felixcloutier.com/x86/STD.html",
      "Table": [
        {
          "Opcode": "FD",
          "Instruction": "STD",
          "OperandEncoding": "ZO",
          "Bit64Mode": "Valid",
          "CompatLegMode": "Valid",
          "Description": "Set DF flag."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STI",
      "Description": "Set Interrupt Flag",
      "Url": "https://www.felixcloutier.com/x86/STI.html",
      "Table": [
        {
          "Opcode": "FB",
          "Instruction": "STI",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set interrupt flag; external, maskable interrupts enabled at the end of the next instruction."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STMXCSR",
      "Description": "Store MXCSR Register State",
      "Url": "https://www.felixcloutier.com/x86/STMXCSR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "STOS",
      "Description": "Store String",
      "Url": "https://www.felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html",
      "Table": [
        {
          "Opcode": "AA",
          "Instruction": "STOS m8",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m16",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m32",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOS m64",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        },
        {
          "Opcode": "AA",
          "Instruction": "STOSB",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSW",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSD",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOSQ",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "NA",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STOSB",
      "Description": "Store String",
      "Url": "https://www.felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html",
      "Table": [
        {
          "Opcode": "AA",
          "Instruction": "STOS m8",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m16",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m32",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOS m64",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        },
        {
          "Opcode": "AA",
          "Instruction": "STOSB",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSW",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSD",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOSQ",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "NA",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STOSD",
      "Description": "Store String",
      "Url": "https://www.felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html",
      "Table": [
        {
          "Opcode": "AA",
          "Instruction": "STOS m8",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m16",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m32",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOS m64",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        },
        {
          "Opcode": "AA",
          "Instruction": "STOSB",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSW",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSD",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOSQ",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "NA",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STOSQ",
      "Description": "Store String",
      "Url": "https://www.felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html",
      "Table": [
        {
          "Opcode": "AA",
          "Instruction": "STOS m8",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m16",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m32",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOS m64",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        },
        {
          "Opcode": "AA",
          "Instruction": "STOSB",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSW",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSD",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOSQ",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "NA",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STOSW",
      "Description": "Store String",
      "Url": "https://www.felixcloutier.com/x86/STOS:STOSB:STOSW:STOSD:STOSQ.html",
      "Table": [
        {
          "Opcode": "AA",
          "Instruction": "STOS m8",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m16",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOS m32",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOS m64",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        },
        {
          "Opcode": "AA",
          "Instruction": "STOSB",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AL at address ES:(E)DI; For 64-bit mode store AL at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSW",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store AX at address ES:(E)DI; For 64-bit mode store AX at address RDI or EDI."
        },
        {
          "Opcode": "AB",
          "Instruction": "STOSD",
          "OperandEncoding": "NA",
          "CompatLegMode": "Valid",
          "Description": "For legacy mode, store EAX at address ES:(E)DI; For 64-bit mode store EAX at address RDI or EDI."
        },
        {
          "Opcode": "REX.W + AB",
          "Instruction": "STOSQ",
          "OperandEncoding": "NA",
          "CompatLegMode": "N.E.",
          "Description": "Store RAX at address RDI or EDI."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "NA",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "STR",
      "Description": "Store Task Register",
      "Url": "https://www.felixcloutier.com/x86/STR.html",
      "Table": [
        {
          "Opcode": "0F 00 /1",
          "Instruction": "STR r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Stores segment selector from TR in r/m16."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SUB",
      "Description": "Subtract",
      "Url": "https://www.felixcloutier.com/x86/SUB.html",
      "Table": [
        {
          "Opcode": "2C ib",
          "Instruction": "SUB AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm8 from AL."
        },
        {
          "Opcode": "2D iw",
          "Instruction": "SUB AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm16 from AX."
        },
        {
          "Opcode": "2D id",
          "Instruction": "SUB EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm32 from EAX."
        },
        {
          "Opcode": "REX.W + 2D id",
          "Instruction": "SUB RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "Subtract imm32 sign-extended to 64-bits from RAX."
        },
        {
          "Opcode": "80 /5 ib",
          "Instruction": "SUB r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm8 from r/m8."
        },
        {
          "Opcode": "REX + 80 /5 ib",
          "Instruction": "SUB r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract imm8 from r/m8."
        },
        {
          "Opcode": "81 /5 iw",
          "Instruction": "SUB r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm16 from r/m16."
        },
        {
          "Opcode": "81 /5 id",
          "Instruction": "SUB r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract imm32 from r/m32."
        },
        {
          "Opcode": "REX.W + 81 /5 id",
          "Instruction": "SUB r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract imm32 sign-extended to 64-bits from r/m64."
        },
        {
          "Opcode": "83 /5 ib",
          "Instruction": "SUB r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract sign-extended imm8 from r/m16."
        },
        {
          "Opcode": "83 /5 ib",
          "Instruction": "SUB r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "Subtract sign-extended imm8 from r/m32."
        },
        {
          "Opcode": "REX.W + 83 /5 ib",
          "Instruction": "SUB r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "Subtract sign-extended imm8 from r/m64."
        },
        {
          "Opcode": "28 /r",
          "Instruction": "SUB r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract r8 from r/m8."
        },
        {
          "Opcode": "REX + 28 /r",
          "Instruction": "SUB r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Subtract r8 from r/m8."
        },
        {
          "Opcode": "29 /r",
          "Instruction": "SUB r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract r16 from r/m16."
        },
        {
          "Opcode": "29 /r",
          "Instruction": "SUB r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Subtract r32 from r/m32."
        },
        {
          "Opcode": "REX.W + 29 /r",
          "Instruction": "SUB r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Subtract r64 from r/m64."
        },
        {
          "Opcode": "2A /r",
          "Instruction": "SUB r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract r/m8 from r8."
        },
        {
          "Opcode": "REX + 2A /r",
          "Instruction": "SUB r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Subtract r/m8 from r8."
        },
        {
          "Opcode": "2B /r",
          "Instruction": "SUB r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract r/m16 from r16."
        },
        {
          "Opcode": "2B /r",
          "Instruction": "SUB r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Subtract r/m32 from r32."
        },
        {
          "Opcode": "REX.W + 2B /r",
          "Instruction": "SUB r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Subtract r/m64 from r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "SUBPD",
      "Description": "Subtract Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SUBPD.html",
      "Table": [
        {
          "Opcode": "66 0F 5C /r",
          "Instruction": "SUBPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract packed double-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 5C /r",
          "Instruction": "VSUBPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed double-precision floating-point values in xmm3/mem from xmm2 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 5C /r",
          "Instruction": "VSUBPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed double-precision floating-point values in ymm3/mem from ymm2 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 5C /r",
          "Instruction": "VSUBPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed double-precision floating-point values from xmm3/m128/m64bcst to xmm2 and store result in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 5C /r",
          "Instruction": "VSUBPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed double-precision floating-point values from ymm3/m256/m64bcst to ymm2 and store result in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 5C /r",
          "Instruction": "VSUBPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Subtract packed double-precision floating-point values from zmm3/m512/m64bcst to zmm2 and store result in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SUBPS",
      "Description": "Subtract Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/SUBPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 5C /r",
          "Instruction": "SUBPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Subtract packed single-precision floating-point values in xmm2/mem from xmm1 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 5C /r",
          "Instruction": "VSUBPS xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed single-precision floating-point values in xmm3/mem from xmm2 and stores result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 5C /r",
          "Instruction": "VSUBPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract packed single-precision floating-point values in ymm3/mem from ymm2 and stores result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 5C /r",
          "Instruction": "VSUBPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed single-precision floating-point values from xmm3/m128/m32bcst to xmm2 and stores result in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 5C /r",
          "Instruction": "VSUBPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Subtract packed single-precision floating-point values from ymm3/m256/m32bcst to ymm2 and stores result in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 5C /r",
          "Instruction": "VSUBPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Subtract packed single-precision floating-point values in zmm3/m512/m32bcst from zmm2 and stores result in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SUBSD",
      "Description": "Subtract Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/SUBSD.html",
      "Table": [
        {
          "Opcode": "F2 0F 5C /r",
          "Instruction": "SUBSD xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Subtract the low double-precision floating-point value in xmm2/m64 from xmm1 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F2.0F.WIG 5C /r",
          "Instruction": "VSUBSD xmm1,xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 5C /r",
          "Instruction": "VSUBSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Subtract the low double-precision floating-point value in xmm3/m64 from xmm2 and store the result in xmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SUBSS",
      "Description": "Subtract Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/SUBSS.html",
      "Table": [
        {
          "Opcode": "F3 0F 5C /r",
          "Instruction": "SUBSS xmm1, xmm2/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Subtract the low single-precision floating-point value in xmm2/m32 from xmm1 and store the result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.LIG.F3.0F.WIG 5C /r",
          "Instruction": "VSUBSS xmm1,xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 5C /r",
          "Instruction": "VSUBSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Subtract the low single-precision floating-point value in xmm3/m32 from xmm2 and store the result in xmm1 under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "SWAPGS",
      "Description": "Swap GS Base Register",
      "Url": "https://www.felixcloutier.com/x86/SWAPGS.html",
      "Table": [
        {
          "Opcode": "0F 01 F8",
          "Instruction": "SWAPGS",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Invalid",
          "Description": "Exchanges the current GS base register value with the value contained in MSR address C0000102H."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SYSCALL",
      "Description": "Fast System Call",
      "Url": "https://www.felixcloutier.com/x86/SYSCALL.html",
      "Table": [
        {
          "Opcode": "0F 05",
          "Instruction": "SYSCALL",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Invalid",
          "Description": "Fast call to privilege level 0 system procedures."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SYSENTER",
      "Description": "Fast System Call",
      "Url": "https://www.felixcloutier.com/x86/SYSENTER.html",
      "Table": [
        {
          "Opcode": "0F 34",
          "Instruction": "SYSENTER",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fast call to privilege level 0 system procedures."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SYSEXIT",
      "Description": "Fast Return from Fast System Call",
      "Url": "https://www.felixcloutier.com/x86/SYSEXIT.html",
      "Table": [
        {
          "Opcode": "0F 35",
          "Instruction": "SYSEXIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fast return to privilege level 3 user code."
        },
        {
          "Opcode": "REX.W + 0F 35",
          "Instruction": "SYSEXIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Fast return to 64-bit mode privilege level 3 user code."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "SYSRET",
      "Description": "Return From Fast System Call",
      "Url": "https://www.felixcloutier.com/x86/SYSRET.html",
      "Table": [
        {
          "Opcode": "0F 07",
          "Instruction": "SYSRET",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Invalid",
          "Description": "Return to compatibility mode from fast system call"
        },
        {
          "Opcode": "REX.W + 0F 07",
          "Instruction": "SYSRET",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Invalid",
          "Description": "Return to 64-bit mode from fast system call"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "TEST",
      "Description": "Logical Compare",
      "Url": "https://www.felixcloutier.com/x86/TEST.html",
      "Table": [
        {
          "Opcode": "A8 ib",
          "Instruction": "TEST AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AND imm8 with AL; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "A9 iw",
          "Instruction": "TEST AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AND imm16 with AX; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "A9 id",
          "Instruction": "TEST EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AND imm32 with EAX; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "REX.W + A9 id",
          "Instruction": "TEST RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "AND imm32 sign-extended to 64-bits with RAX; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "F6 /0 ib",
          "Instruction": "TEST r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "AND imm8 with r/m8; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "REX + F6 /0 ib",
          "Instruction": "TEST r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "AND imm8 with r/m8; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "F7 /0 iw",
          "Instruction": "TEST r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "AND imm16 with r/m16; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "F7 /0 id",
          "Instruction": "TEST r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "AND imm32 with r/m32; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "REX.W + F7 /0 id",
          "Instruction": "TEST r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "AND imm32 sign-extended to 64-bits with r/m64; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "84 /r",
          "Instruction": "TEST r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "AND r8 with r/m8; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "REX + 84 /r",
          "Instruction": "TEST r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "AND r8 with r/m8; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "85 /r",
          "Instruction": "TEST r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "AND r16 with r/m16; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "85 /r",
          "Instruction": "TEST r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "AND r32 with r/m32; set SF, ZF, PF according to result."
        },
        {
          "Opcode": "REX.W + 85 /r",
          "Instruction": "TEST r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "AND r64 with r/m64; set SF, ZF, PF according to result."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "TZCNT",
      "Description": "Count the Number of Trailing Zero Bits",
      "Url": "https://www.felixcloutier.com/x86/TZCNT.html",
      "Table": [
        {
          "Opcode": "F3 0F BC /r",
          "Instruction": "TZCNT r16, r/m16",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Count the number of trailing zero bits in r/m16, return result in r16."
        },
        {
          "Opcode": "F3 0F BC /r",
          "Instruction": "TZCNT r32, r/m32",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Count the number of trailing zero bits in r/m32, return result in r32."
        },
        {
          "Opcode": "F3 REX.W 0F BC /r",
          "Instruction": "TZCNT r64, r/m64",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "BMI1",
          "Description": "Count the number of trailing zero bits in r/m64, return result in r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "UCOMISD",
      "Description": "Unordered Compare Scalar Double-Precision Floating-Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/UCOMISD.html",
      "Table": [
        {
          "Opcode": "66 0F 2E /r",
          "Instruction": "UCOMISD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "VEX.LIG.66.0F.WIG 2E /r",
          "Instruction": "VUCOMISD xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/mem64 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "EVEX.LIG.66.0F.W1 2E /r",
          "Instruction": "VUCOMISD xmm1, xmm2/m64{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low double-precision floating-point values in xmm1 and xmm2/m64 and set the EFLAGS flags accordingly."
        }
      ]
    },
    {
      "Mnemonic": "UCOMISS",
      "Description": "Unordered Compare Scalar Single-Precision Floating-Point Values and Set EFLAGS",
      "Url": "https://www.felixcloutier.com/x86/UCOMISS.html",
      "Table": [
        {
          "Opcode": "NP 0F 2E /r",
          "Instruction": "UCOMISS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "VEX.LIG.0F.WIG 2E /r",
          "Instruction": "VUCOMISS xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        },
        {
          "Opcode": "EVEX.LIG.0F.W0 2E /r",
          "Instruction": "VUCOMISS xmm1, xmm2/m32{sae}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare low single-precision floating-point values in xmm1 and xmm2/mem32 and set the EFLAGS flags accordingly."
        }
      ]
    },
    {
      "Mnemonic": "UD",
      "Description": "Undefined Instruction",
      "Url": "https://www.felixcloutier.com/x86/UD.html",
      "Table": [
        {
          "Opcode": "0F FF /r",
          "Instruction": "UD01 r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Raise invalid opcode exception."
        },
        {
          "Opcode": "0F B9 /r",
          "Instruction": "UD1 r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Raise invalid opcode exception."
        },
        {
          "Opcode": "0F 0B",
          "Instruction": "UD2",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Raise invalid opcode exception."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "UNPCKHPD",
      "Description": "Unpack and Interleave High Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/UNPCKHPD.html",
      "Table": [
        {
          "Opcode": "66 0F 15 /r",
          "Instruction": "UNPCKHPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 15 /r",
          "Instruction": "VUNPCKHPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves double-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 15 /r",
          "Instruction": "VUNPCKHPD ymm1,ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves double-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 15 /r",
          "Instruction": "VUNPCKHPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of xmm2 and xmm3/m128/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 15 /r",
          "Instruction": "VUNPCKHPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves double precision floating-point values from high quadwords of ymm2 and ymm3/m256/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 15 /r",
          "Instruction": "VUNPCKHPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Unpacks and Interleaves double-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m64bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "UNPCKHPS",
      "Description": "Unpack and Interleave High Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/UNPCKHPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 15 /r",
          "Instruction": "UNPCKHPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm1 and xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 15 /r",
          "Instruction": "VUNPCKHPS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 15 /r",
          "Instruction": "VUNPCKHPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 15 /r",
          "Instruction": "VUNPCKHPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of xmm2 and xmm3/m128/m32bcst and write result to xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 15 /r",
          "Instruction": "VUNPCKHPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of ymm2 and ymm3/m256/m32bcst and write result to ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 15 /r",
          "Instruction": "VUNPCKHPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from high quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "UNPCKLPD",
      "Description": "Unpack and Interleave Low Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/UNPCKLPD.html",
      "Table": [
        {
          "Opcode": "66 0F 14 /r",
          "Instruction": "UNPCKLPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 14 /r",
          "Instruction": "VUNPCKLPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves double-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 14 /r",
          "Instruction": "VUNPCKLPD ymm1,ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves double-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 14 /r",
          "Instruction": "VUNPCKLPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of xmm2 and xmm3/m128/m64bcst subject to write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 14 /r",
          "Instruction": "VUNPCKLPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves double precision floating-point values from low quadwords of ymm2 and ymm3/m256/m64bcst subject to write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 14 /r",
          "Instruction": "VUNPCKLPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Unpacks and Interleaves double-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m64bcst subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "UNPCKLPS",
      "Description": "Unpack and Interleave Low Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/UNPCKLPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 14 /r",
          "Instruction": "UNPCKLPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm1 and xmm2/m128."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 14 /r",
          "Instruction": "VUNPCKLPS xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/m128."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 14 /r",
          "Instruction": "VUNPCKLPS ymm1,ymm2,ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/m256."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 14 /r",
          "Instruction": "VUNPCKLPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of xmm2 and xmm3/mem and write result to xmm1 subject to write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 14 /r",
          "Instruction": "VUNPCKLPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of ymm2 and ymm3/mem and write result to ymm1 subject to write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 14 /r",
          "Instruction": "VUNPCKLPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Unpacks and Interleaves single-precision floating-point values from low quadwords of zmm2 and zmm3/m512/m32bcst and write result to zmm1 subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "VALIGND",
      "Description": "Align Doubleword/Quadword Vectors",
      "Url": "https://www.felixcloutier.com/x86/VALIGND:VALIGNQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 03 /r ib",
          "Instruction": "VALIGND xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift right and merge vectors xmm2 and xmm3/m128/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 03 /r ib",
          "Instruction": "VALIGND ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift right and merge vectors ymm2 and ymm3/m256/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 03 /r ib",
          "Instruction": "VALIGND zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift right and merge vectors zmm2 and zmm3/m512/m32bcst with double-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VALIGNQ",
      "Description": "Align Doubleword/Quadword Vectors",
      "Url": "https://www.felixcloutier.com/x86/VALIGND:VALIGNQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 03 /r ib",
          "Instruction": "VALIGNQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift right and merge vectors xmm2 and xmm3/m128/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in xmm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 03 /r ib",
          "Instruction": "VALIGNQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift right and merge vectors ymm2 and ymm3/m256/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in ymm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 03 /r ib",
          "Instruction": "VALIGNQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift right and merge vectors zmm2 and zmm3/m512/m64bcst with quad-word granularity using imm8 as number of elements to shift, and store the final result in zmm1, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VBLENDMPD",
      "Description": "Blend Float64/Float32 Vectors Using an OpMask Control",
      "Url": "https://www.felixcloutier.com/x86/VBLENDMPD:VBLENDMPS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 65 /r",
          "Instruction": "VBLENDMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend double-precision vector xmm2 and double-precision vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 65 /r",
          "Instruction": "VBLENDMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend double-precision vector ymm2 and double-precision vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 65 /r",
          "Instruction": "VBLENDMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Blend double-precision vector zmm2 and double-precision vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
        }
      ]
    },
    {
      "Mnemonic": "VBLENDMPS",
      "Description": "Blend Float64/Float32 Vectors Using an OpMask Control",
      "Url": "https://www.felixcloutier.com/x86/VBLENDMPD:VBLENDMPS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 65 /r",
          "Instruction": "VBLENDMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend single-precision vector xmm2 and single-precision vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 65 /r",
          "Instruction": "VBLENDMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend single-precision vector ymm2 and single-precision vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 65 /r",
          "Instruction": "VBLENDMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Blend single-precision vector zmm2 and single-precision vector zmm3/m512/m32bcst using k1 as select control and store the result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VBROADCAST",
      "Description": "Load with Broadcast Floating-Point Data",
      "Url": "https://www.felixcloutier.com/x86/VBROADCAST.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS xmm1, m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Broadcast single-precision floating-point element in mem to four locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS ymm1, m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Broadcast single-precision floating-point element in mem to eight locations in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 19 /r",
          "Instruction": "VBROADCASTSD ymm1, m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Broadcast double-precision floating-point element in mem to four locations in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 1A /r",
          "Instruction": "VBROADCASTF128 ymm1, m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Broadcast 128 bits of floating-point data in mem to low and high 128-bits in ymm1."
        },
        {
          "Opcode": "VEX.128.66.0F38.W0 18/r",
          "Instruction": "VBROADCASTSS xmm1, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast the low single-precision floating-point element in the source operand to four locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS ymm1, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast low single-precision floating-point element in the source operand to eight locations in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 19 /r",
          "Instruction": "VBROADCASTSD ymm1, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast low double-precision floating-point element in the source operand to four locations in ymm1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 19 /r",
          "Instruction": "VBROADCASTSD ymm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast low double-precision floating-point element in xmm2/m64 to four locations in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 19 /r",
          "Instruction": "VBROADCASTSD zmm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast low double-precision floating-point element in xmm2/m64 to eight locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 19 /r",
          "Instruction": "VBROADCASTF32X2 ymm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 19 /r",
          "Instruction": "VBROADCASTF32X2 zmm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Broadcast two single-precision floating-point elements in xmm2/m64 to locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS xmm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS ymm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 18 /r",
          "Instruction": "VBROADCASTSS zmm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast low single-precision floating-point element in xmm2/m32 to all locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 1A /r",
          "Instruction": "VBROADCASTF32X4 ymm1 {k1}{z}, m128",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 1A /r",
          "Instruction": "VBROADCASTF32X4 zmm1 {k1}{z}, m128",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast 128 bits of 4 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 1A /r",
          "Instruction": "VBROADCASTF64X2 ymm1 {k1}{z}, m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 1A /r",
          "Instruction": "VBROADCASTF64X2 zmm1 {k1}{z}, m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Broadcast 128 bits of 2 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 1B /r",
          "Instruction": "VBROADCASTF32X8 zmm1 {k1}{z}, m256",
          "OperandEncoding": "E",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Broadcast 256 bits of 8 single-precision floating-point data in mem to locations in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 1B /r",
          "Instruction": "VBROADCASTF64X4 zmm1 {k1}{z}, m256",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast 256 bits of 4 double-precision floating-point data in mem to locations in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCOMPRESSPD",
      "Description": "Store Sparse Packed Double-Precision Floating-Point Values into Dense Memory",
      "Url": "https://www.felixcloutier.com/x86/VCOMPRESSPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 8A /r",
          "Instruction": "VCOMPRESSPD xmm1/m128 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed double-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 8A /r",
          "Instruction": "VCOMPRESSPD ymm1/m256 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed double-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 8A /r",
          "Instruction": "VCOMPRESSPD zmm1/m512 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compress packed double-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
        }
      ]
    },
    {
      "Mnemonic": "VCOMPRESSPS",
      "Description": "Store Sparse Packed Single-Precision Floating-Point Values into Dense Memory",
      "Url": "https://www.felixcloutier.com/x86/VCOMPRESSPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 8A /r",
          "Instruction": "VCOMPRESSPS xmm1/m128 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed single-precision floating-point values from xmm2 to xmm1/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 8A /r",
          "Instruction": "VCOMPRESSPS ymm1/m256 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed single-precision floating-point values from ymm2 to ymm1/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 8A /r",
          "Instruction": "VCOMPRESSPS zmm1/m512 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compress packed single-precision floating-point values from zmm2 using control mask k1 to zmm1/m512."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPD2QQ",
      "Description": "Convert Packed Double-Precision Floating-Point Values to Packed Quadword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTPD2QQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W1 7B /r",
          "Instruction": "VCVTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed quadword integers in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 7B /r",
          "Instruction": "VCVTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 7B /r",
          "Instruction": "VCVTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed double-precision floating-point values from zmm2/m512/m64bcst to eight packed quadword integers in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPD2UDQ",
      "Description": "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTPD2UDQ.html"
    },
    {
      "Mnemonic": "VCVTPD2UQQ",
      "Description": "Convert Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTPD2UQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W1 79 /r",
          "Instruction": "VCVTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed double-precision floating-point values from xmm2/mem to two packed unsigned quadword integers in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 79 /r",
          "Instruction": "VCVTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert fourth packed double-precision floating-point values from ymm2/mem to four packed unsigned quadword integers in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 79 /r",
          "Instruction": "VCVTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPH2PS",
      "Description": "Convert 16-bit FP values to Single-Precision FP values",
      "Url": "https://www.felixcloutier.com/x86/VCVTPH2PS.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F38.W0 13 /r",
          "Instruction": "VCVTPH2PS xmm1, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "F16C",
          "Description": "Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 13 /r",
          "Instruction": "VCVTPH2PS ymm1, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "F16C",
          "Description": "Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point value in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 13 /r",
          "Instruction": "VCVTPH2PS xmm1 {k1}{z}, xmm2/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed half precision (16-bit) floating-point values in xmm2/m64 to packed single-precision floating-point values in xmm1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 13 /r",
          "Instruction": "VCVTPH2PS ymm1 {k1}{z}, xmm2/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed half precision (16-bit) floating-point values in xmm2/m128 to packed single-precision floating-point values in ymm1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 13 /r",
          "Instruction": "VCVTPH2PS zmm1 {k1}{z}, ymm2/m256 {sae}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed half precision (16-bit) floating-point values in ymm2/m256 to packed single-precision floating-point values in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPS2PH",
      "Description": "Convert Single-Precision FP value to 16-bit FP value",
      "Url": "https://www.felixcloutier.com/x86/VCVTPS2PH.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F3A.W0 1D /r ib",
          "Instruction": "VCVTPS2PH xmm1/m64, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "F16C",
          "Description": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
        },
        {
          "Opcode": "VEX.256.66.0F3A.W0 1D /r ib",
          "Instruction": "VCVTPS2PH xmm1/m128, ymm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "F16C",
          "Description": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.W0 1D /r ib",
          "Instruction": "VCVTPS2PH xmm1/m64 {k1}{z}, xmm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed single-precision floating-point values in xmm2 to packed half-precision (16-bit) floating-point values in xmm1/m64. Imm8 provides rounding controls."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 1D /r ib",
          "Instruction": "VCVTPS2PH xmm1/m128 {k1}{z}, ymm2, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed single-precision floating-point values in ymm2 to packed half-precision (16-bit) floating-point values in xmm1/m128. Imm8 provides rounding controls."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 1D /r ib",
          "Instruction": "VCVTPS2PH ymm1/m256 {k1}{z}, zmm2{sae}, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed single-precision floating-point values in zmm2 to packed half-precision (16-bit) floating-point values in ymm1/m256. Imm8 provides rounding controls."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPS2QQ",
      "Description": "Convert Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTPS2QQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W0 7B /r",
          "Instruction": "VCVTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 7B /r",
          "Instruction": "VCVTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 7B /r",
          "Instruction": "VCVTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPS2UDQ",
      "Description": "Convert Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTPS2UDQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.0F.W0 79 /r",
          "Instruction": "VCVTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 79 /r",
          "Instruction": "VCVTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 79 /r",
          "Instruction": "VCVTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTPS2UQQ",
      "Description": "Convert Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTPS2UQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W0 79 /r",
          "Instruction": "VCVTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed single precision floating-point values from zmm2/m64/m32bcst to two packed unsigned quadword values in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 79 /r",
          "Instruction": "VCVTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 79 /r",
          "Instruction": "VCVTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTQQ2PD",
      "Description": "Convert Packed Quadword Integers to Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTQQ2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F.W1 E6 /r",
          "Instruction": "VCVTQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed quadword integers from xmm2/m128/m64bcst to packed double-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 E6 /r",
          "Instruction": "VCVTQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 E6 /r",
          "Instruction": "VCVTQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTQQ2PS",
      "Description": "Convert Packed Quadword Integers to Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTQQ2PS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.0F.W1 5B /r",
          "Instruction": "VCVTQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed quadword integers from xmm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W1 5B /r",
          "Instruction": "VCVTQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed quadword integers from ymm2/mem to packed single-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W1 5B /r",
          "Instruction": "VCVTQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed quadword integers from zmm2/mem to eight packed single-precision floating-point values in ymm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTSD2USI",
      "Description": "Convert Scalar Double-Precision Floating-Point Value to Unsigned Doubleword Integer",
      "Url": "https://www.felixcloutier.com/x86/VCVTSD2USI.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.F2.0F.W0 79 /r",
          "Instruction": "VCVTSD2USI r32, xmm1/m64{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 79 /r",
          "Instruction": "VCVTSD2USI r64, xmm1/m64{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64."
        }
      ]
    },
    {
      "Mnemonic": "VCVTSS2USI",
      "Description": "Convert Scalar Single-Precision Floating-Point Value to Unsigned Doubleword Integer",
      "Url": "https://www.felixcloutier.com/x86/VCVTSS2USI.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 79 /r",
          "Instruction": "VCVTSS2USI r32, xmm1/m32{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W1 79 /r",
          "Instruction": "VCVTSS2USI r64, xmm1/m32{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTPD2QQ",
      "Description": "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Quadword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPD2QQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W1 7A /r",
          "Instruction": "VCVTTPD2QQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed double-precision floating-point values from zmm2/m128/m64bcst to two packed quadword integers in zmm1 using truncation with writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 7A /r",
          "Instruction": "VCVTTPD2QQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed quadword integers in ymm1 using truncation with writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 7A /r",
          "Instruction": "VCVTTPD2QQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed double-precision floating-point values from zmm2/m512 to eight packed quadword integers in zmm1 using truncation with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTPD2UDQ",
      "Description": "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Doubleword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPD2UDQ.html"
    },
    {
      "Mnemonic": "VCVTTPD2UQQ",
      "Description": "Convert with Truncation Packed Double-Precision Floating-Point Values to Packed Unsigned Quadword Integers",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPD2UQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W1 78 /r",
          "Instruction": "VCVTTPD2UQQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed double-precision floating-point values from xmm2/m128/m64bcst to two packed unsigned quadword integers in xmm1 using truncation with writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 78 /r",
          "Instruction": "VCVTTPD2UQQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed double-precision floating-point values from ymm2/m256/m64bcst to four packed unsigned quadword integers in ymm1 using truncation with writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 78 /r",
          "Instruction": "VCVTTPD2UQQ zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed double-precision floating-point values from zmm2/mem to eight packed unsigned quadword integers in zmm1 using truncation with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTPS2QQ",
      "Description": "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Singed Quadword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPS2QQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W0 7A /r",
          "Instruction": "VCVTTPS2QQ xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed signed quadword values in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 7A /r",
          "Instruction": "VCVTTPS2QQ ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed signed quadword values in ymm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 7A /r",
          "Instruction": "VCVTTPS2QQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed signed quadword values in zmm1 using truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTPS2UDQ",
      "Description": "Convert with Truncation Packed Single-Precision Floating-Point Values to Packed Unsigned Doubleword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPS2UDQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UDQ xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned doubleword values in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UDQ ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned doubleword values in ymm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UDQ zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed single-precision floating-point values from zmm2/m512/m32bcst to sixteen packed unsigned doubleword values in zmm1 using truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTPS2UQQ",
      "Description": "Convert with Truncation Packed Single Precision Floating-Point Values to Packed Unsigned Quadword Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTTPS2UQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UQQ xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed single precision floating-point values from xmm2/m64/m32bcst to two packed unsigned quadword values in xmm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UQQ ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed single precision floating-point values from xmm2/m128/m32bcst to four packed unsigned quadword values in ymm1 using truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 78 /r",
          "Instruction": "VCVTTPS2UQQ zmm1 {k1}{z}, ymm2/m256/m32bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed single precision floating-point values from ymm2/m256/m32bcst to eight packed unsigned quadword values in zmm1 using truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTSD2USI",
      "Description": "Convert with Truncation Scalar Double-Precision Floating-Point Value to Unsigned Integer",
      "Url": "https://www.felixcloutier.com/x86/VCVTTSD2USI.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.F2.0F.W0 78 /r",
          "Instruction": "VCVTTSD2USI r32, xmm1/m64{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned doubleword integer r32 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F2.0F.W1 78 /r",
          "Instruction": "VCVTTSD2USI r64, xmm1/m64{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one double-precision floating-point value from xmm1/m64 to one unsigned quadword integer zero-extended into r64 using truncation."
        }
      ]
    },
    {
      "Mnemonic": "VCVTTSS2USI",
      "Description": "Convert with Truncation Scalar Single-Precision Floating-Point Value to Unsigned Integer",
      "Url": "https://www.felixcloutier.com/x86/VCVTTSS2USI.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.F3.0F.W0 78 /r",
          "Instruction": "VCVTTSS2USI r32, xmm1/m32{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned doubleword integer in r32 using truncation."
        },
        {
          "Opcode": "EVEX.LIG.F3.0F.W1 78 /r",
          "Instruction": "VCVTTSS2USI r64, xmm1/m32{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one single-precision floating-point value from xmm1/m32 to one unsigned quadword integer in r64 using truncation."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUDQ2PD",
      "Description": "Convert Packed Unsigned Doubleword Integers to Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTUDQ2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PD xmm1 {k1}{z}, xmm2/m64/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert two packed unsigned doubleword integers from ymm2/m64/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PD ymm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed double-precision floating-point values in zmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PD zmm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUDQ2PS",
      "Description": "Convert Packed Unsigned Doubleword Integers to Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTUDQ2PS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F2.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PS xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert four packed unsigned doubleword integers from xmm2/m128/m32bcst to packed single-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PS ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert eight packed unsigned doubleword integers from ymm2/m256/m32bcst to packed single-precision floating-point values in zmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W0 7A /r",
          "Instruction": "VCVTUDQ2PS zmm1 {k1}{z}, zmm2/m512/m32bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert sixteen packed unsigned doubleword integers from zmm2/m512/m32bcst to sixteen packed single-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUQQ2PD",
      "Description": "Convert Packed Unsigned Quadword Integers to Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTUQQ2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to two packed double-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed double-precision floating-point values in ymm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PD zmm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed double-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUQQ2PS",
      "Description": "Convert Packed Unsigned Quadword Integers to Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VCVTUQQ2PS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F2.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PS xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert two packed unsigned quadword integers from xmm2/m128/m64bcst to packed single-precision floating-point values in zmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PS xmm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Convert four packed unsigned quadword integers from ymm2/m256/m64bcst to packed single-precision floating-point values in xmm1 with writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 7A /r",
          "Instruction": "VCVTUQQ2PS ymm1 {k1}{z}, zmm2/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Convert eight packed unsigned quadword integers from zmm2/m512/m64bcst to eight packed single-precision floating-point values in zmm1 with writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUSI2SD",
      "Description": "Convert Unsigned Integer to Scalar Double-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/VCVTUSI2SD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W0 7B /r",
          "Instruction": "VCVTUSI2SD xmm1, xmm2, r/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one unsigned doubleword integer from r/m32 to one double-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F2.0F.W1 7B /r",
          "Instruction": "VCVTUSI2SD xmm1, xmm2, r/m64{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one unsigned quadword integer from r/m64 to one double-precision floating-point value in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VCVTUSI2SS",
      "Description": "Convert Unsigned Integer to Scalar Single-Precision Floating-Point Value",
      "Url": "https://www.felixcloutier.com/x86/VCVTUSI2SS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W0 7B /r",
          "Instruction": "VCVTUSI2SS xmm1, xmm2, r/m32{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed doubleword integer from r/m32 to one single-precision floating-point value in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.LIG.F3.0F.W1 7B /r",
          "Instruction": "VCVTUSI2SS xmm1, xmm2, r/m64{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert one signed quadword integer from r/m64 to one single-precision floating-point value in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VDBPSADBW",
      "Description": "Double Block Packed Sum-Absolute-Differences (SAD) on Unsigned Bytes",
      "Url": "https://www.felixcloutier.com/x86/VDBPSADBW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 42 /r ib",
          "Instruction": "VDBPSADBW xmm1 {k1}{z}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compute packed SAD word results of unsigned bytes in dword block from xmm2 with unsigned bytes of dword blocks transformed from xmm3/m128 using the shuffle controls in imm8. Results are written to xmm1 under the writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 42 /r ib",
          "Instruction": "VDBPSADBW ymm1 {k1}{z}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compute packed SAD word results of unsigned bytes in dword block from ymm2 with unsigned bytes of dword blocks transformed from ymm3/m256 using the shuffle controls in imm8. Results are written to ymm1 under the writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 42 /r ib",
          "Instruction": "VDBPSADBW zmm1 {k1}{z}, zmm2, zmm3/m512, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compute packed SAD word results of unsigned bytes in dword block from zmm2 with unsigned bytes of dword blocks transformed from zmm3/m512 using the shuffle controls in imm8. Results are written to zmm1 under the writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VERR",
      "Description": "Verify a Segment for Reading or Writing",
      "Url": "https://www.felixcloutier.com/x86/VERR:VERW.html",
      "Table": [
        {
          "Opcode": "0F 00 /4",
          "Instruction": "VERR r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set ZF=1 if segment specified with r/m16 can be read."
        },
        {
          "Opcode": "0F 00 /5",
          "Instruction": "VERW r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set ZF=1 if segment specified with r/m16 can be written."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VERW",
      "Description": "Verify a Segment for Reading or Writing",
      "Url": "https://www.felixcloutier.com/x86/VERR:VERW.html",
      "Table": [
        {
          "Opcode": "0F 00 /4",
          "Instruction": "VERR r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set ZF=1 if segment specified with r/m16 can be read."
        },
        {
          "Opcode": "0F 00 /5",
          "Instruction": "VERW r/m16",
          "OperandEncoding": "M",
          "CompatLegMode": "Valid",
          "Description": "Set ZF=1 if segment specified with r/m16 can be written."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VEXPANDPD",
      "Description": "Load Sparse Packed Double-Precision Floating-Point Values from Dense Memory",
      "Url": "https://www.felixcloutier.com/x86/VEXPANDPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 88 /r",
          "Instruction": "VEXPANDPD xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed double-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 88 /r",
          "Instruction": "VEXPANDPD ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed double-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 88 /r",
          "Instruction": "VEXPANDPD zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Expand packed double-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VEXPANDPS",
      "Description": "Load Sparse Packed Single-Precision Floating-Point Values from Dense Memory",
      "Url": "https://www.felixcloutier.com/x86/VEXPANDPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 88 /r",
          "Instruction": "VEXPANDPS xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed single-precision floating-point values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 88 /r",
          "Instruction": "VEXPANDPS ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed single-precision floating-point values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 88 /r",
          "Instruction": "VEXPANDPS zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Expand packed single-precision floating-point values from zmm2/m512 to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTF128",
      "Description": "Extra ct Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html",
      "Table": [
        {
          "Opcode": "VEX.256.66.0F3A.W0 19 /r ib",
          "Instruction": "VEXTRACTF128 xmm1/m128, ymm2, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Extract 128 bits of packed floating-point values from ymm2 and store results in xmm1/m128."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTF32x4",
      "Description": "Extra ct Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html",
      "Table": [
        {
          "Opcode": "EVEX.512.66.0F3A.W0 19 /r ib",
          "Instruction": "VEXTRACTF32x4 xmm1/m128 {k1}{z}, zmm2, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract 128 bits of packed single-precision floating-point values from zmm2 and store results in xmm1/m128 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTF32x8",
      "Description": "Extra ct Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VEXTRACTF64x2",
      "Description": "Extra ct Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VEXTRACTF64x4",
      "Description": "Extra ct Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTF128:VEXTRACTF32x4:VEXTRACTF64x2:VEXTRACTF32x8:VEXTRACTF64x4.html",
      "Table": [
        {
          "Opcode": "EVEX.512.66.0F3A.W1 1B /r ib",
          "Instruction": "VEXTRACTF64x4 ymm1/m256 {k1}{z}, zmm2, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract 256 bits of packed double-precision floating-point values from zmm2 and store results in ymm1/m256 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTI128",
      "Description": "Extract packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html",
      "Table": [
        {
          "Opcode": "VEX.256.66.0F3A.W0 39 /r ib",
          "Instruction": "VEXTRACTI128 xmm1/m128, ymm2, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Extract 128 bits of integer data from ymm2 and store results in xmm1/m128."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTI32x4",
      "Description": "Extract packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html",
      "Table": [
        {
          "Opcode": "EVEX.512.66.0F3A.W0 39 /r ib",
          "Instruction": "VEXTRACTI32x4 xmm1/m128 {k1}{z}, zmm2, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract 128 bits of double-word integer values from zmm2 and store results in xmm1/m128 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VEXTRACTI32x8",
      "Description": "Extract packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VEXTRACTI64x2",
      "Description": "Extract packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VEXTRACTI64x4",
      "Description": "Extract packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VEXTRACTI128:VEXTRACTI32x4:VEXTRACTI64x2:VEXTRACTI32x8:VEXTRACTI64x4.html",
      "Table": [
        {
          "Opcode": "EVEX.512.66.0F3A.W1 3B /r ib",
          "Instruction": "VEXTRACTI64x4 ymm1/m256 {k1}{z}, zmm2, imm8",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract 256 bits of quad-word integer values from zmm2 and store results in ymm1/m256 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFIXUPIMMPD",
      "Description": "Fix Up Special Packed Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VFIXUPIMMPD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 54 /r ib",
          "Instruction": "VFIXUPIMMPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Fix up special numbers in float64 vector xmm1, float64 vector xmm2 and int64 vector xmm3/m128/m64bcst and store the result in xmm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 54 /r ib",
          "Instruction": "VFIXUPIMMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Fix up special numbers in float64 vector ymm1, float64 vector ymm2 and int64 vector ymm3/m256/m64bcst and store the result in ymm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 54 /r ib",
          "Instruction": "VFIXUPIMMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Fix up elements of float64 vector in zmm2 using int64 vector table in zmm3/m512/m64bcst, combine with preserved elements from zmm1, and store the result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFIXUPIMMPS",
      "Description": "Fix Up Special Packed Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VFIXUPIMMPS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 54 /r",
          "Instruction": "VFIXUPIMMPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Fix up special numbers in float32 vector xmm1, float32 vector xmm2 and int32 vector xmm3/m128/m32bcst and store the result in xmm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 54 /r",
          "Instruction": "VFIXUPIMMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Fix up special numbers in float32 vector ymm1, float32 vector ymm2 and int32 vector ymm3/m256/m32bcst and store the result in ymm1, under writemask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 54 /r ib",
          "Instruction": "VFIXUPIMMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Fix up elements of float32 vector in zmm2 using int32 vector table in zmm3/m512/m32bcst, combine with preserved elements from zmm1, and store the result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFIXUPIMMSD",
      "Description": "Fix Up Special Scalar Float64 Value",
      "Url": "https://www.felixcloutier.com/x86/VFIXUPIMMSD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W1 55 /r ib",
          "Instruction": "VFIXUPIMMSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Fix up a float64 number in the low quadword element of xmm2 using scalar int32 table in xmm3/m64 and store the result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFIXUPIMMSS",
      "Description": "Fix Up Special Scalar Float32 Value",
      "Url": "https://www.felixcloutier.com/x86/VFIXUPIMMSS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W0 55 /r ib",
          "Instruction": "VFIXUPIMMSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Fix up a float32 number in the low doubleword element in xmm2 using scalar int32 table in xmm3/m32 and store the result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD132PD",
      "Description": "Fused Multiply-Add of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 98 /r",
          "Instruction": "VFMADD132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 98 /r",
          "Instruction": "VFMADD132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 98 /r",
          "Instruction": "VFMADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 98 /r",
          "Instruction": "VFMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 98 /r",
          "Instruction": "VFMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add to zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD132PS",
      "Description": "Fused Multiply-Add of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 98 /r",
          "Instruction": "VFMADD132PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 98 /r",
          "Instruction": "VFMADD132PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 98 /r",
          "Instruction": "VFMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 98 /r",
          "Instruction": "VFMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 98 /r",
          "Instruction": "VFMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add to zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD132SD",
      "Description": "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 99 /r",
          "Instruction": "VFMADD132SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 99 /r",
          "Instruction": "VFMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, add to xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD132SS",
      "Description": "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 99 /r",
          "Instruction": "VFMADD132SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 99 /r",
          "Instruction": "VFMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, add to xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD213PD",
      "Description": "Fused Multiply-Add of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 A8 /r",
          "Instruction": "VFMADD213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 A8 /r",
          "Instruction": "VFMADD213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 A8 /r",
          "Instruction": "VFMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m64bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 A8 /r",
          "Instruction": "VFMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m64bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 A8 /r",
          "Instruction": "VFMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m64bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD213PS",
      "Description": "Fused Multiply-Add of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 A8 /r",
          "Instruction": "VFMADD213PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 A8 /r",
          "Instruction": "VFMADD213PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 A8 /r",
          "Instruction": "VFMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add to xmm3/m128/m32bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 A8 /r",
          "Instruction": "VFMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add to ymm3/m256/m32bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 A8 /r",
          "Instruction": "VFMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, add to zmm3/m512/m32bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD213SD",
      "Description": "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 A9 /r",
          "Instruction": "VFMADD213SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 A9 /r",
          "Instruction": "VFMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, add to xmm3/m64 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD213SS",
      "Description": "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 A9 /r",
          "Instruction": "VFMADD213SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 A9 /r",
          "Instruction": "VFMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, add to xmm3/m32 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD231PD",
      "Description": "Fused Multiply-Add of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PD:VFMADD213PD:VFMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 B8 /r",
          "Instruction": "VFMADD231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 B8 /r",
          "Instruction": "VFMADD231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 B8 /r",
          "Instruction": "VFMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 B8 /r",
          "Instruction": "VFMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 B8 /r",
          "Instruction": "VFMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add to zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD231PS",
      "Description": "Fused Multiply-Add of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132PS:VFMADD213PS:VFMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 B8 /r",
          "Instruction": "VFMADD231PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.0 B8 /r",
          "Instruction": "VFMADD231PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 B8 /r",
          "Instruction": "VFMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 B8 /r",
          "Instruction": "VFMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 B8 /r",
          "Instruction": "VFMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add to zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD231SD",
      "Description": "Fused Multiply-Add of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SD:VFMADD213SD:VFMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 B9 /r",
          "Instruction": "VFMADD231SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 B9 /r",
          "Instruction": "VFMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, add to xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADD231SS",
      "Description": "Fused Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADD132SS:VFMADD213SS:VFMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 B9 /r",
          "Instruction": "VFMADD231SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 B9 /r",
          "Instruction": "VFMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, add to xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB132PD",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 96 /r",
          "Instruction": "VFMADDSUB132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 96 /r",
          "Instruction": "VFMADDSUB132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 96 /r",
          "Instruction": "VFMADDSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, add/subtract elements in xmm2 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 96 /r",
          "Instruction": "VFMADDSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 96 /r",
          "Instruction": "VFMADDSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB132PS",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 96 /r",
          "Instruction": "VFMADDSUB132PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, add/subtract elements in xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 96 /r",
          "Instruction": "VFMADDSUB132PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, add/subtract elements in ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 96 /r",
          "Instruction": "VFMADDSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, add/subtract elements in zmm2 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 96 /r",
          "Instruction": "VFMADDSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, add/subtract elements in ymm2 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 96 /r",
          "Instruction": "VFMADDSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, add/subtract elements in zmm2 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB213PD",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 A6 /r",
          "Instruction": "VFMADDSUB213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 A6 /r",
          "Instruction": "VFMADDSUB213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 A6 /r",
          "Instruction": "VFMADDSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 A6 /r",
          "Instruction": "VFMADDSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 A6 /r",
          "Instruction": "VFMADDSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1and zmm2, add/subtract elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB213PS",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 A6 /r",
          "Instruction": "VFMADDSUB213PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 A6 /r",
          "Instruction": "VFMADDSUB213PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 A6 /r",
          "Instruction": "VFMADDSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, add/subtract elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 A6 /r",
          "Instruction": "VFMADDSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, add/subtract elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 A6 /r",
          "Instruction": "VFMADDSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, add/subtract elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB231PD",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PD:VFMADDSUB213PD:VFMADDSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 B6 /r",
          "Instruction": "VFMADDSUB231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 B6 /r",
          "Instruction": "VFMADDSUB231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 B6 /r",
          "Instruction": "VFMADDSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 B6 /r",
          "Instruction": "VFMADDSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 B6 /r",
          "Instruction": "VFMADDSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMADDSUB231PS",
      "Description": "Fused Multiply-Alternating Add/Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMADDSUB132PS:VFMADDSUB213PS:VFMADDSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 B6 /r",
          "Instruction": "VFMADDSUB231PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, add/subtract elements in xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 B6 /r",
          "Instruction": "VFMADDSUB231PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, add/subtract elements in ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 B6 /r",
          "Instruction": "VFMADDSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, add/subtract elements in xmm1 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 B6 /r",
          "Instruction": "VFMADDSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, add/subtract elements in ymm1 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 B6 /r",
          "Instruction": "VFMADDSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, add/subtract elements in zmm1 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB132PD",
      "Description": "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 9A /r",
          "Instruction": "VFMSUB132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 9A /r",
          "Instruction": "VFMSUB132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 9A /r",
          "Instruction": "VFMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract xmm2 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 9A /r",
          "Instruction": "VFMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract ymm2 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 9A /r",
          "Instruction": "VFMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract zmm2 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB132PS",
      "Description": "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 9A /r",
          "Instruction": "VFMSUB132PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 9A /r",
          "Instruction": "VFMSUB132PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 9A /r",
          "Instruction": "VFMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 9A /r",
          "Instruction": "VFMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 9A /r",
          "Instruction": "VFMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB132SD",
      "Description": "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 9B /r",
          "Instruction": "VFMSUB132SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 9B /r",
          "Instruction": "VFMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, subtract xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB132SS",
      "Description": "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 9B /r",
          "Instruction": "VFMSUB132SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 9B /r",
          "Instruction": "VFMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, subtract xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB213PD",
      "Description": "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 AA /r",
          "Instruction": "VFMSUB213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 AA /r",
          "Instruction": "VFMSUB213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 AA /r",
          "Instruction": "VFMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 AA /r",
          "Instruction": "VFMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 AA /r",
          "Instruction": "VFMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB213PS",
      "Description": "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 AA /r",
          "Instruction": "VFMSUB213PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 AA /r",
          "Instruction": "VFMSUB213PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 AA /r",
          "Instruction": "VFMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract xmm3/m128/m32bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 AA /r",
          "Instruction": "VFMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract ymm3/m256/m32bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 AA /r",
          "Instruction": "VFMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract zmm3/m512/m32bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB213SD",
      "Description": "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 AB /r",
          "Instruction": "VFMSUB213SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 AB /r",
          "Instruction": "VFMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, subtract xmm3/m64 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB213SS",
      "Description": "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 AB /r",
          "Instruction": "VFMSUB213SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 AB /r",
          "Instruction": "VFMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, subtract xmm3/m32 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB231PD",
      "Description": "Fused Multiply-Subtract of Packed Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PD:VFMSUB213PD:VFMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 BA /r",
          "Instruction": "VFMSUB231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 BA /r",
          "Instruction": "VFMSUB231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1.S"
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 BA /r",
          "Instruction": "VFMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract xmm1 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 BA /r",
          "Instruction": "VFMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract ymm1 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 BA /r",
          "Instruction": "VFMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract zmm1 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB231PS",
      "Description": "Fused Multiply-Subtract of Packed Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132PS:VFMSUB213PS:VFMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 BA /r",
          "Instruction": "VFMSUB231PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.0 BA /r",
          "Instruction": "VFMSUB231PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 BA /r",
          "Instruction": "VFMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 BA /r",
          "Instruction": "VFMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 BA /r",
          "Instruction": "VFMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB231SD",
      "Description": "Fused Multiply-Subtract of Scalar Double- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SD:VFMSUB213SD:VFMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 BB /r",
          "Instruction": "VFMSUB231SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 BB /r",
          "Instruction": "VFMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, subtract xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUB231SS",
      "Description": "Fused Multiply-Subtract of Scalar Single- Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUB132SS:VFMSUB213SS:VFMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 BB /r",
          "Instruction": "VFMSUB231SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 BB /r",
          "Instruction": "VFMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, subtract xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD132PD",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 97 /r",
          "Instruction": "VFMSUBADD132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 97 /r",
          "Instruction": "VFMSUBADD132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 97 /r",
          "Instruction": "VFMSUBADD132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 97 /r",
          "Instruction": "VFMSUBADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 97 /r",
          "Instruction": "VFMSUBADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD132PS",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 97 /r",
          "Instruction": "VFMSUBADD132PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, subtract/add elements in xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 97 /r",
          "Instruction": "VFMSUBADD132PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, subtract/add elements in ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 97 /r",
          "Instruction": "VFMSUBADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, subtract/add elements in xmm2 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 97 /r",
          "Instruction": "VFMSUBADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, subtract/add elements in ymm2 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 97 /r",
          "Instruction": "VFMSUBADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, subtract/add elements in zmm2 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD213PD",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 A7 /r",
          "Instruction": "VFMSUBADD213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 A7 /r",
          "Instruction": "VFMSUBADD213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 A7 /r",
          "Instruction": "VFMSUBADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m64bcst and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 A7 /r",
          "Instruction": "VFMSUBADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m64bcst and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 A7 /r",
          "Instruction": "VFMSUBADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m64bcst and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD213PS",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 A7 /r",
          "Instruction": "VFMSUBADD213PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 A7 /r",
          "Instruction": "VFMSUBADD213PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 A7 /r",
          "Instruction": "VFMSUBADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, subtract/add elements in xmm3/m128/m32bcst and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 A7 /r",
          "Instruction": "VFMSUBADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, subtract/add elements in ymm3/m256/m32bcst and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 A7 /r",
          "Instruction": "VFMSUBADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, subtract/add elements in zmm3/m512/m32bcst and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD231PD",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PD:VFMSUBADD213PD:VFMSUBADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 B7 /r",
          "Instruction": "VFMSUBADD231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 B7 /r",
          "Instruction": "VFMSUBADD231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 B7 /r",
          "Instruction": "VFMSUBADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 B7 /r",
          "Instruction": "VFMSUBADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 B7 /r",
          "Instruction": "VFMSUBADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFMSUBADD231PS",
      "Description": "Fused Multiply-Alternating Subtract/Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFMSUBADD132PS:VFMSUBADD213PS:VFMSUBADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 B7 /r",
          "Instruction": "VFMSUBADD231PS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, subtract/add elements in xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 B7 /r",
          "Instruction": "VFMSUBADD231PS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, subtract/add elements in ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 B7 /r",
          "Instruction": "VFMSUBADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, subtract/add elements in xmm1 and put result in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 B7 /r",
          "Instruction": "VFMSUBADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, subtract/add elements in ymm1 and put result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 B7 /r",
          "Instruction": "VFMSUBADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, subtract/add elements in zmm1 and put result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD132PD",
      "Description": "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 9C /r",
          "Instruction": "VFNMADD132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 9C /r",
          "Instruction": "VFNMADD132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 9C /r",
          "Instruction": "VFNMADD132PD xmm0 {k1}{z}, xmm1, xmm2/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 9C /r",
          "Instruction": "VFNMADD132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 9C /r",
          "Instruction": "VFNMADD132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD132PS",
      "Description": "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 9C /r",
          "Instruction": "VFNMADD132PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 9C /r",
          "Instruction": "VFNMADD132PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 9C /r",
          "Instruction": "VFNMADD132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 9C /r",
          "Instruction": "VFNMADD132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 9C /r",
          "Instruction": "VFNMADD132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD132SD",
      "Description": "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 9D /r",
          "Instruction": "VFNMADD132SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 9D /r",
          "Instruction": "VFNMADD132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and add to xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD132SS",
      "Description": "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 9D /r",
          "Instruction": "VFNMADD132SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 9D /r",
          "Instruction": "VFNMADD132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and add to xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD213PD",
      "Description": "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 AC /r",
          "Instruction": "VFNMADD213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 AC /r",
          "Instruction": "VFNMADD213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 AC /r",
          "Instruction": "VFNMADD213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m64bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 AC /r",
          "Instruction": "VFNMADD213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m64bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 AC /r",
          "Instruction": "VFNMADD213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m64bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD213PS",
      "Description": "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 AC /r",
          "Instruction": "VFNMADD213PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 AC /r",
          "Instruction": "VFNMADD213PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 AC /r",
          "Instruction": "VFNMADD213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and add to xmm3/m128/m32bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 AC /r",
          "Instruction": "VFNMADD213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and add to ymm3/m256/m32bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 AC /r",
          "Instruction": "VFNMADD213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and add to zmm3/m512/m32bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD213SD",
      "Description": "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 AD /r",
          "Instruction": "VFNMADD213SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 AD /r",
          "Instruction": "VFNMADD213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m64 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD213SS",
      "Description": "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 AD /r",
          "Instruction": "VFNMADD213SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 AD /r",
          "Instruction": "VFNMADD213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and add to xmm3/m32 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD231PD",
      "Description": "Fused Negative Multiply-Add of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PD:VFNMADD213PD:VFNMADD231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 BC /r",
          "Instruction": "VFNMADD231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 BC /r",
          "Instruction": "VFNMADD231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 BC /r",
          "Instruction": "VFNMADD231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 BC /r",
          "Instruction": "VFNMADD231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 BC /r",
          "Instruction": "VFNMADD231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD231PS",
      "Description": "Fused Negative Multiply-Add of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132PS:VFNMADD213PS:VFNMADD231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 BC /r",
          "Instruction": "VFNMADD231PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.0 BC /r",
          "Instruction": "VFNMADD231PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 BC /r",
          "Instruction": "VFNMADD231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 BC /r",
          "Instruction": "VFNMADD231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result and add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 BC /r",
          "Instruction": "VFNMADD231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result and add to zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD231SD",
      "Description": "Fused Negative Multiply-Add of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SD:VFNMADD213SD:VFNMADD231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 BD /r",
          "Instruction": "VFNMADD231SD xmm1, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 BD /r",
          "Instruction": "VFNMADD231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and add to xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMADD231SS",
      "Description": "Fused Negative Multiply-Add of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMADD132SS:VFNMADD213SS:VFNMADD231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 BD /r",
          "Instruction": "VFNMADD231SS xmm1, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 BD /r",
          "Instruction": "VFNMADD231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and add to xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB132PD",
      "Description": "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 9E /r",
          "Instruction": "VFNMSUB132PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 9E /r",
          "Instruction": "VFNMSUB132PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 9E /r",
          "Instruction": "VFNMSUB132PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 9E /r",
          "Instruction": "VFNMSUB132PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 9E /r",
          "Instruction": "VFNMSUB132PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB132PS",
      "Description": "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 9E /r",
          "Instruction": "VFNMSUB132PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 9E /r",
          "Instruction": "VFNMSUB132PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/mem, negate the multiplication result and subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 9E /r",
          "Instruction": "VFNMSUB132PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm3/m128/m32bcst, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 9E /r",
          "Instruction": "VFNMSUB132PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm3/m256/m32bcst, negate the multiplication result and subtract ymm2 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 9E /r",
          "Instruction": "VFNMSUB132PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm3/m512/m32bcst, negate the multiplication result and subtract zmm2 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB132SD",
      "Description": "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 9F /r",
          "Instruction": "VFNMSUB132SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/mem, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 9F /r",
          "Instruction": "VFNMSUB132SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm3/m64, negate the multiplication result and subtract xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB132SS",
      "Description": "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 9F /r",
          "Instruction": "VFNMSUB132SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 9F /r",
          "Instruction": "VFNMSUB132SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm3/m32, negate the multiplication result and subtract xmm2 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB213PD",
      "Description": "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 AE /r",
          "Instruction": "VFNMSUB213PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 AE /r",
          "Instruction": "VFNMSUB213PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 AE /r",
          "Instruction": "VFNMSUB213PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m64bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 AE /r",
          "Instruction": "VFNMSUB213PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m64bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 AE /r",
          "Instruction": "VFNMSUB213PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m64bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB213PS",
      "Description": "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 AE /r",
          "Instruction": "VFNMSUB213PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 AE /r",
          "Instruction": "VFNMSUB213PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/mem and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 AE /r",
          "Instruction": "VFNMSUB213PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m128/m32bcst and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 AE /r",
          "Instruction": "VFNMSUB213PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm1 and ymm2, negate the multiplication result and subtract ymm3/m256/m32bcst and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 AE /r",
          "Instruction": "VFNMSUB213PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm1 and zmm2, negate the multiplication result and subtract zmm3/m512/m32bcst and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB213SD",
      "Description": "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 AF /r",
          "Instruction": "VFNMSUB213SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/mem and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 AF /r",
          "Instruction": "VFNMSUB213SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m64 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB213SS",
      "Description": "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 AF /r",
          "Instruction": "VFNMSUB213SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 AF /r",
          "Instruction": "VFNMSUB213SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm1 and xmm2, negate the multiplication result and subtract xmm3/m32 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB231PD",
      "Description": "Fused Negative Multiply-Subtract of Packed Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PD:VFNMSUB213PD:VFNMSUB231PD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 BE /r",
          "Instruction": "VFNMSUB231PD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 BE /r",
          "Instruction": "VFNMSUB231PD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 BE /r",
          "Instruction": "VFNMSUB231PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from xmm2 and xmm3/m128/m64bcst, negate the multiplication result and subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 BE /r",
          "Instruction": "VFNMSUB231PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed double-precision floating-point values from ymm2 and ymm3/m256/m64bcst, negate the multiplication result and subtract ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 BE /r",
          "Instruction": "VFNMSUB231PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed double-precision floating-point values from zmm2 and zmm3/m512/m64bcst, negate the multiplication result and subtract zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB231PS",
      "Description": "Fused Negative Multiply-Subtract of Packed Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132PS:VFNMSUB213PS:VFNMSUB231PS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 BE /r",
          "Instruction": "VFNMSUB231PS xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.0 BE /r",
          "Instruction": "VFNMSUB231PS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/mem, negate the multiplication result and subtract ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 BE /r",
          "Instruction": "VFNMSUB231PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from xmm2 and xmm3/m128/m32bcst, negate the multiplication result subtract add to xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 BE /r",
          "Instruction": "VFNMSUB231PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Multiply packed single-precision floating-point values from ymm2 and ymm3/m256/m32bcst, negate the multiplication result subtract add to ymm1 and put result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 BE /r",
          "Instruction": "VFNMSUB231PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply packed single-precision floating-point values from zmm2 and zmm3/m512/m32bcst, negate the multiplication result subtract add to zmm1 and put result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB231SD",
      "Description": "Fused Negative Multiply-Subtract of Scalar Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SD:VFNMSUB213SD:VFNMSUB231SD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W1 BF /r",
          "Instruction": "VFNMSUB231SD xmm1, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/mem, negate the multiplication result and subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W1 BF /r",
          "Instruction": "VFNMSUB231SD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar double-precision floating-point value from xmm2 and xmm3/m64, negate the multiplication result and subtract xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFNMSUB231SS",
      "Description": "Fused Negative Multiply-Subtract of Scalar Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VFNMSUB132SS:VFNMSUB213SS:VFNMSUB231SS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.LIG.66.0F38.W0 BF /r",
          "Instruction": "VFNMSUB231SS xmm1, xmm2, xmm3/m32",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "FMA",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
        },
        {
          "Opcode": "EVEX.DDS.LIG.66.0F38.W0 BF /r",
          "Instruction": "VFNMSUB231SS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Multiply scalar single-precision floating-point value from xmm2 and xmm3/m32, negate the multiplication result and subtract xmm1 and put result in xmm1."
        }
      ]
    },
    {
      "Mnemonic": "VFPCLASSPD",
      "Description": "Tests Types Of a Packed Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VFPCLASSPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W1 66 /r ib",
          "Instruction": "VFPCLASSPD k2 {k1}, xmm2/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 66 /r ib",
          "Instruction": "VFPCLASSPD k2 {k1}, ymm2/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 66 /r ib",
          "Instruction": "VFPCLASSPD k2 {k1}, zmm2/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        }
      ]
    },
    {
      "Mnemonic": "VFPCLASSPS",
      "Description": "Tests Types Of a Packed Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VFPCLASSPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W0 66 /r ib",
          "Instruction": "VFPCLASSPS k2 {k1}, xmm2/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 66 /r ib",
          "Instruction": "VFPCLASSPS k2 {k1}, ymm2/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 66 /r ib",
          "Instruction": "VFPCLASSPS k2 {k1}, zmm2/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        }
      ]
    },
    {
      "Mnemonic": "VFPCLASSSD",
      "Description": "Tests Types Of a Scalar Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VFPCLASSSD.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.66.0F3A.W1 67 /r ib",
          "Instruction": "VFPCLASSSD k2 {k1}, xmm2/m64, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        }
      ]
    },
    {
      "Mnemonic": "VFPCLASSSS",
      "Description": "Tests Types Of a Scalar Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VFPCLASSSS.html",
      "Table": [
        {
          "Opcode": "EVEX.LIG.66.0F3A.W0 67 /r",
          "Instruction": "VFPCLASSSS k2 {k1}, xmm2/m32, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Tests the input for the following categories: NaN, +0, -0, +Infinity, -Infinity, denormal, finite negative. The immediate field provides a mask bit for each of these category tests. The masked test results are OR-ed together to form a mask result."
        }
      ]
    },
    {
      "Mnemonic": "VGATHERDPD",
      "Description": "Gather Packed DP FP Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPD:VGATHERQPD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 92 /r",
          "Instruction": "VGATHERDPD xmm1, vm32x, xmm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 92 /r",
          "Instruction": "VGATHERDPD ymm1, vm32x, ymm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VGATHERDPD",
      "UniqueName": "vgatherdpd_s",
      "Description": "Gather Packed Single, Packed Double with Signed Dword",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPS:VGATHERDPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 92 /vsib",
          "Instruction": "VGATHERDPD xmm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 92 /vsib",
          "Instruction": "VGATHERDPD ymm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 92 /vsib",
          "Instruction": "VGATHERDPD zmm1 {k1}, vm32y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
        }
      ]
    },
    {
      "Mnemonic": "VGATHERDPS",
      "Description": "Gather Packed SP FP values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPS:VGATHERQPS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 92 /r",
          "Instruction": "VGATHERDPS xmm1, vm32x, xmm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 92 /r",
          "Instruction": "VGATHERDPS ymm1, vm32y, ymm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32y, gather single-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VGATHERDPS",
      "UniqueName": "vgatherdps_s",
      "Description": "Gather Packed Single, Packed Double with Signed Dword",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPS:VGATHERDPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 92 /vsib",
          "Instruction": "VGATHERDPS xmm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 92 /vsib",
          "Instruction": "VGATHERDPS ymm1 {k1}, vm32y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 92 /vsib",
          "Instruction": "VGATHERDPS zmm1 {k1}, vm32z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        }
      ]
    },
    {
      "Mnemonic": "VGATHERQPD",
      "Description": "Gather Packed DP FP Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPD:VGATHERQPD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 93 /r",
          "Instruction": "VGATHERQPD xmm1, vm64x, xmm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64x, gather double-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 93 /r",
          "Instruction": "VGATHERQPD ymm1, vm64y, ymm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64y, gather double-precision FP values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VGATHERQPD",
      "UniqueName": "vgatherqpd_s",
      "Description": "Gather Packed Single, Packed Double with Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERQPS:VGATHERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 93 /vsib",
          "Instruction": "VGATHERQPD xmm1 {k1}, vm64x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather float64 vector into float64 vector xmm1 using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 93 /vsib",
          "Instruction": "VGATHERQPD ymm1 {k1}, vm64y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather float64 vector into float64 vector ymm1 using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 93 /vsib",
          "Instruction": "VGATHERQPD zmm1 {k1}, vm64z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, gather float64 vector into float64 vector zmm1 using k1 as completion mask."
        }
      ]
    },
    {
      "Mnemonic": "VGATHERQPS",
      "Description": "Gather Packed SP FP values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERDPS:VGATHERQPS.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 93 /r",
          "Instruction": "VGATHERQPS xmm1, vm64x, xmm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64x, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 93 /r",
          "Instruction": "VGATHERQPS xmm1, vm64y, xmm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64y, gather single-precision FP values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VGATHERQPS",
      "UniqueName": "vgatherqps_s",
      "Description": "Gather Packed Single, Packed Double with Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VGATHERQPS:VGATHERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 93 /vsib",
          "Instruction": "VGATHERQPS xmm1 {k1}, vm64x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 93 /vsib",
          "Instruction": "VGATHERQPS xmm1 {k1}, vm64y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 93 /vsib",
          "Instruction": "VGATHERQPS ymm1 {k1}, vm64z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, gather single-precision floating-point values from memory using k1 as completion mask."
        }
      ]
    },
    {
      "Mnemonic": "VGETEXPPD",
      "Description": "Convert Exponents of Packed DP FP Values to DP FP Values",
      "Url": "https://www.felixcloutier.com/x86/VGETEXPPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 42 /r",
          "Instruction": "VGETEXPPD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 42 /r",
          "Instruction": "VGETEXPPD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination register."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 42 /r",
          "Instruction": "VGETEXPPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert the exponent of packed double-precision floating-point values in the source operand to DP FP results representing unbiased integer exponents and stores the results in the destination under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VGETEXPPS",
      "Description": "Convert Exponents of Packed SP FP Values to SP FP Values",
      "Url": "https://www.felixcloutier.com/x86/VGETEXPPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 42 /r",
          "Instruction": "VGETEXPPS xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 42 /r",
          "Instruction": "VGETEXPPS ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 42 /r",
          "Instruction": "VGETEXPPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert the exponent of packed single-precision floating-point values in the source operand to SP FP results representing unbiased integer exponents and stores the results in the destination register."
        }
      ]
    },
    {
      "Mnemonic": "VGETEXPSD",
      "Description": "Convert Exponents of Scalar DP FP Values to DP FP Value",
      "Url": "https://www.felixcloutier.com/x86/VGETEXPSD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W1 43 /r",
          "Instruction": "VGETEXPSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert the biased exponent (bits 62:52) of the low double-precision floating-point value in xmm3/m64 to a DP FP value representing unbiased integer exponent. Stores the result to the low 64-bit of xmm1 under the writemask k1 and merge with the other elements of xmm2."
        }
      ]
    },
    {
      "Mnemonic": "VGETEXPSS",
      "Description": "Convert Exponents of Scalar SP FP Values to SP FP Value",
      "Url": "https://www.felixcloutier.com/x86/VGETEXPSS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W0 43 /r",
          "Instruction": "VGETEXPSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Convert the biased exponent (bits 30:23) of the low single-precision floating-point value in xmm3/m32 to a SP FP value representing unbiased integer exponent. Stores the result to xmm1 under the writemask k1 and merge with the other elements of xmm2."
        }
      ]
    },
    {
      "Mnemonic": "VGETMANTPD",
      "Description": "Extract Float64 Vector of Normalized Mantissas from Float64 Vector",
      "Url": "https://www.felixcloutier.com/x86/VGETMANTPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W1 26 /r ib",
          "Instruction": "VGETMANTPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Get Normalized Mantissa from float64 vector xmm2/m128/m64bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 26 /r ib",
          "Instruction": "VGETMANTPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Get Normalized Mantissa from float64 vector ymm2/m256/m64bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 26 /r ib",
          "Instruction": "VGETMANTPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Get Normalized Mantissa from float64 vector zmm2/m512/m64bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VGETMANTPS",
      "Description": "Extract Float32 Vector of Normalized Mantissas from Float32 Vector",
      "Url": "https://www.felixcloutier.com/x86/VGETMANTPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W0 26 /r ib",
          "Instruction": "VGETMANTPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Get normalized mantissa from float32 vector xmm2/m128/m32bcst and store the result in xmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 26 /r ib",
          "Instruction": "VGETMANTPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Get normalized mantissa from float32 vector ymm2/m256/m32bcst and store the result in ymm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 26 /r ib",
          "Instruction": "VGETMANTPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Get normalized mantissa from float32 vector zmm2/m512/m32bcst and store the result in zmm1, using imm8 for sign control and mantissa interval normalization, under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VGETMANTSD",
      "Description": "Extract Float64 of Normalized Mantissas from Float64 Scalar",
      "Url": "https://www.felixcloutier.com/x86/VGETMANTSD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W1 27 /r ib",
          "Instruction": "VGETMANTSD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract the normalized mantissa of the low float64 element in xmm3/m64 using imm8 for sign control and mantissa interval normalization. Store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
        }
      ]
    },
    {
      "Mnemonic": "VGETMANTSS",
      "Description": "Extract Float32 Vector of Normalized Mantissa from Float32 Vector",
      "Url": "https://www.felixcloutier.com/x86/VGETMANTSS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W0 27 /r ib",
          "Instruction": "VGETMANTSS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Extract the normalized mantissa from the low float32 element of xmm3/m32 using imm8 for sign control and mantissa interval normalization, store the mantissa to xmm1 under the writemask k1 and merge with the other elements of xmm2."
        }
      ]
    },
    {
      "Mnemonic": "VINSERTF128",
      "Description": "Insert Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 18 /r ib",
          "Instruction": "VINSERTF128 ymm1, ymm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Insert 128 bits of packed floating-point values from xmm3/m128 and the remaining values from ymm2 into ymm1."
        }
      ]
    },
    {
      "Mnemonic": "VINSERTF32x4",
      "Description": "Insert Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTF32x8",
      "Description": "Insert Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTF64x2",
      "Description": "Insert Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTF64x4",
      "Description": "Insert Packed Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTF128:VINSERTF32x4:VINSERTF64x2:VINSERTF32x8:VINSERTF64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTI128",
      "Description": "Insert Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 38 /r ib",
          "Instruction": "VINSERTI128 ymm1, ymm2, xmm3/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Insert 128 bits of integer data from xmm3/m128 and the remaining values from ymm2 into ymm1."
        }
      ]
    },
    {
      "Mnemonic": "VINSERTI32x4",
      "Description": "Insert Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTI32x8",
      "Description": "Insert Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTI64x2",
      "Description": "Insert Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VINSERTI64x4",
      "Description": "Insert Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VINSERTI128:VINSERTI32x4:VINSERTI64x2:VINSERTI32x8:VINSERTI64x4.html",
      "Table": []
    },
    {
      "Mnemonic": "VMASKMOV",
      "Description": "Conditional SIMD Packed Loads and Stores",
      "Url": "https://www.felixcloutier.com/x86/VMASKMOV.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 2C /r",
          "Instruction": "VMASKMOVPS xmm1, xmm2, m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally load packed single-precision values from m128 using mask in xmm2 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 2C /r",
          "Instruction": "VMASKMOVPS ymm1, ymm2, m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally load packed single-precision values from m256 using mask in ymm2 and store in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 2D /r",
          "Instruction": "VMASKMOVPD xmm1, xmm2, m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally load packed double-precision values from m128 using mask in xmm2 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 2D /r",
          "Instruction": "VMASKMOVPD ymm1, ymm2, m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally load packed double-precision values from m256 using mask in ymm2 and store in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 2E /r",
          "Instruction": "VMASKMOVPS m128, xmm1, xmm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally store packed single-precision values from xmm2 using mask in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 2E /r",
          "Instruction": "VMASKMOVPS m256, ymm1, ymm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally store packed single-precision values from ymm2 using mask in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 2F /r",
          "Instruction": "VMASKMOVPD m128, xmm1, xmm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally store packed double-precision values from xmm2 using mask in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 2F /r",
          "Instruction": "VMASKMOVPD m256, ymm1, ymm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX",
          "Description": "Conditionally store packed double-precision values from ymm2 using mask in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MVR",
          "Operands": [
            "ModRM:r/m (w)",
            "VEX.vvvv (r)",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQA32",
      "Description": "Move Aligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 6F /r",
          "Instruction": "VMOVDQA32 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W0 7F /r",
          "Instruction": "VMOVDQA32 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQA64",
      "Description": "Move Aligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQA:VMOVDQA32:VMOVDQA64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned quadword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned quadword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 6F /r",
          "Instruction": "VMOVDQA64 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move aligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F.W1 7F /r",
          "Instruction": "VMOVDQA64 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move aligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQU16",
      "Description": "Move Unaligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 6F /r",
          "Instruction": "VMOVDQU16 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed word integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed word integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W1 7F /r",
          "Instruction": "VMOVDQU16 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed word integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQU32",
      "Description": "Move Unaligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 xmm1 {k1}{z}, xmm2/mm128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 6F /r",
          "Instruction": "VMOVDQU32 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed doubleword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed doubleword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W0 7F /r",
          "Instruction": "VMOVDQU32 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed doubleword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQU64",
      "Description": "Move Unaligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 6F /r",
          "Instruction": "VMOVDQU64 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed quadword integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Move unaligned packed quadword integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F.W1 7F /r",
          "Instruction": "VMOVDQU64 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Move unaligned packed quadword integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VMOVDQU8",
      "Description": "Move Unaligned Packed Integer Values",
      "Url": "https://www.felixcloutier.com/x86/MOVDQU:VMOVDQU8:VMOVDQU16:VMOVDQU32:VMOVDQU64.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W0 6F /r",
          "Instruction": "VMOVDQU8 zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed byte integer values from zmm2/m512 to zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 xmm2/m128 {k1}{z}, xmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from xmm1 to xmm2/m128 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 ymm2/m256 {k1}{z}, ymm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Move unaligned packed byte integer values from ymm1 to ymm2/m256 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.F2.0F.W0 7F /r",
          "Instruction": "VMOVDQU8 zmm2/m512 {k1}{z}, zmm1",
          "OperandEncoding": "D",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Move unaligned packed byte integer values from zmm1 to zmm2/m512 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPBLENDD",
      "Description": "Blend Packed Dwords",
      "Url": "https://www.felixcloutier.com/x86/VPBLENDD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F3A.W0 02 /r ib",
          "Instruction": "VPBLENDD xmm1, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Select dwords from xmm2 and xmm3/m128 from mask specified in imm8 and store the values into xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 02 /r ib",
          "Instruction": "VPBLENDD ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Select dwords from ymm2 and ymm3/m256 from mask specified in imm8 and store the values into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv",
            "ModRM:r/m (r)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPBLENDMB",
      "Description": "Blend Byte/Word Vectors Using an Opmask Control",
      "Url": "https://www.felixcloutier.com/x86/VPBLENDMB:VPBLENDMW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 66 /r",
          "Instruction": "VPBLENDMB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Blend byte integer vector xmm2 and byte vector xmm3/m128 and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 66 /r",
          "Instruction": "VPBLENDMB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Blend byte integer vector ymm2 and byte vector ymm3/m256 and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 66 /r",
          "Instruction": "VPBLENDMB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Blend byte integer vector zmm2 and byte vector zmm3/m512 and store the result in zmm1, under control mask."
        }
      ]
    },
    {
      "Mnemonic": "VPBLENDMD",
      "Description": "Blend Int32/Int64 Vectors Using an OpMask Control",
      "Url": "https://www.felixcloutier.com/x86/VPBLENDMD:VPBLENDMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 64 /r",
          "Instruction": "VPBLENDMD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend doubleword integer vector xmm2 and doubleword vector xmm3/m128/m32bcst and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 64 /r",
          "Instruction": "VPBLENDMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend doubleword integer vector ymm2 and doubleword vector ymm3/m256/m32bcst and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 64 /r",
          "Instruction": "VPBLENDMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Blend doubleword integer vector zmm2 and doubleword vector zmm3/m512/m32bcst and store the result in zmm1, under control mask."
        }
      ]
    },
    {
      "Mnemonic": "VPBLENDMQ",
      "Description": "Blend Int32/Int64 Vectors Using an OpMask Control",
      "Url": "https://www.felixcloutier.com/x86/VPBLENDMD:VPBLENDMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 64 /r",
          "Instruction": "VPBLENDMQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend quadword integer vector xmm2 and quadword vector xmm3/m128/m64bcst and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 64 /r",
          "Instruction": "VPBLENDMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Blend quadword integer vector ymm2 and quadword vector ymm3/m256/m64bcst and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 64 /r",
          "Instruction": "VPBLENDMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Blend quadword integer vector zmm2 and quadword vector zmm3/m512/m64bcst and store the result in zmm1, under control mask."
        }
      ]
    },
    {
      "Mnemonic": "VPBLENDMW",
      "Description": "Blend Byte/Word Vectors Using an Opmask Control",
      "Url": "https://www.felixcloutier.com/x86/VPBLENDMB:VPBLENDMW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 66 /r",
          "Instruction": "VPBLENDMW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Blend word integer vector xmm2 and word vector xmm3/m128 and store the result in xmm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 66 /r",
          "Instruction": "VPBLENDMW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Blend word integer vector ymm2 and word vector ymm3/m256 and store the result in ymm1, under control mask."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 66 /r",
          "Instruction": "VPBLENDMW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Blend word integer vector zmm2 and word vector zmm3/m512 and store the result in zmm1, under control mask."
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCAST",
      "Description": "Load Integer and Broadcast",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCAST.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F38.W0 78 /r",
          "Instruction": "VPBROADCASTB xmm1, xmm2/m8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a byte integer in the source operand to sixteen locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 78 /r",
          "Instruction": "VPBROADCASTB ymm1, xmm2/m8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a byte integer in the source operand to thirty-two locations in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 78 /r",
          "Instruction": "VPBROADCASTB xmm1{k1}{z}, xmm2/m8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a byte integer in the source operand to locations in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 78 /r",
          "Instruction": "VPBROADCASTB ymm1{k1}{z}, xmm2/m8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a byte integer in the source operand to locations in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 78 /r",
          "Instruction": "VPBROADCASTB zmm1{k1}{z}, xmm2/m8",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Broadcast a byte integer in the source operand to 64 locations in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "VEX.128.66.0F38.W0 79 /r",
          "Instruction": "VPBROADCASTW xmm1, xmm2/m16",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a word integer in the source operand to eight locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 79 /r",
          "Instruction": "VPBROADCASTW ymm1, xmm2/m16",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a word integer in the source operand to sixteen locations in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 79 /r",
          "Instruction": "VPBROADCASTW xmm1{k1}{z}, xmm2/m16",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a word integer in the source operand to locations in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 79 /r",
          "Instruction": "VPBROADCASTW ymm1{k1}{z}, xmm2/m16",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a word integer in the source operand to locations in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 79 /r",
          "Instruction": "VPBROADCASTW zmm1{k1}{z}, xmm2/m16",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Broadcast a word integer in the source operand to 32 locations in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "VEX.128.66.0F38.W0 58 /r",
          "Instruction": "VPBROADCASTD xmm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a dword integer in the source operand to four locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 58 /r",
          "Instruction": "VPBROADCASTD ymm1, xmm2/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a dword integer in the source operand to eight locations in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W0 58 /r",
          "Instruction": "VPBROADCASTD xmm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a dword integer in the source operand to locations in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 58 /r",
          "Instruction": "VPBROADCASTD ymm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a dword integer in the source operand to locations in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 58 /r",
          "Instruction": "VPBROADCASTD zmm1 {k1}{z}, xmm2/m32",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast a dword integer in the source operand to locations in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "VEX.128.66.0F38.W0 59 /r",
          "Instruction": "VPBROADCASTQ xmm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a qword element in source operand to two locations in xmm1."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 59 /r",
          "Instruction": "VPBROADCASTQ ymm1, xmm2/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Broadcast a qword element in source operand to four locations in ymm1."
        },
        {
          "Opcode": "EVEX.128.66.0F38.W1 59 /r",
          "Instruction": "VPBROADCASTQ xmm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a qword element in source operand to locations in xmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 59 /r",
          "Instruction": "VPBROADCASTQ ymm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a qword element in source operand to locations in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 59 /r",
          "Instruction": "VPBROADCASTQ zmm1 {k1}{z}, xmm2/m64",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast a qword element in source operand to locations in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCASTB",
      "Description": "Load with Broadcast Integer Data from General Purpose Register",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 7A /r",
          "Instruction": "VPBROADCASTB xmm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 128-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 7A /r",
          "Instruction": "VPBROADCASTB ymm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 256-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 7A /r",
          "Instruction": "VPBROADCASTB zmm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Broadcast an 8-bit value from a GPR to all bytes in the 512-bit destination subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCASTD",
      "Description": "Load with Broadcast Integer Data from General Purpose Register",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 7C /r",
          "Instruction": "VPBROADCASTD xmm1 {k1}{z}, r32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a 32-bit value from a GPR to all double-words in the 128-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 7C /r",
          "Instruction": "VPBROADCASTD ymm1 {k1}{z}, r32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a 32-bit value from a GPR to all double-words in the 256-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 7C /r",
          "Instruction": "VPBROADCASTD zmm1 {k1}{z}, r32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast a 32-bit value from a GPR to all double-words in the 512-bit destination subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCASTM",
      "Description": "Broadcast Mask to Vector Register",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCASTM.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W1 2A /r",
          "Instruction": "VPBROADCASTMB2Q xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Broadcast low byte value in k1 to two locations in xmm1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W1 2A /r",
          "Instruction": "VPBROADCASTMB2Q ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Broadcast low byte value in k1 to four locations in ymm1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W1 2A /r",
          "Instruction": "VPBROADCASTMB2Q zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Broadcast low byte value in k1 to eight locations in zmm1."
        },
        {
          "Opcode": "EVEX.128.F3.0F38.W0 3A /r",
          "Instruction": "VPBROADCASTMW2D xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Broadcast low word value in k1 to four locations in xmm1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 3A /r",
          "Instruction": "VPBROADCASTMW2D ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Broadcast low word value in k1 to eight locations in ymm1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 3A /r",
          "Instruction": "VPBROADCASTMW2D zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Broadcast low word value in k1 to sixteen locations in zmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCASTQ",
      "Description": "Load with Broadcast Integer Data from General Purpose Register",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 7C /r",
          "Instruction": "VPBROADCASTQ xmm1 {k1}{z}, r64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a 64-bit value from a GPR to all quad-words in the 128-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 7C /r",
          "Instruction": "VPBROADCASTQ ymm1 {k1}{z}, r64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Broadcast a 64-bit value from a GPR to all quad-words in the 256-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 7C /r",
          "Instruction": "VPBROADCASTQ zmm1 {k1}{z}, r64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/N.E.1",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Broadcast a 64-bit value from a GPR to all quad-words in the 512-bit destination subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPBROADCASTW",
      "Description": "Load with Broadcast Integer Data from General Purpose Register",
      "Url": "https://www.felixcloutier.com/x86/VPBROADCASTB:VPBROADCASTW:VPBROADCASTD:VPBROADCASTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 7B /r",
          "Instruction": "VPBROADCASTW xmm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a 16-bit value from a GPR to all words in the 128-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 7B /r",
          "Instruction": "VPBROADCASTW ymm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Broadcast a 16-bit value from a GPR to all words in the 256-bit destination subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 7B /r",
          "Instruction": "VPBROADCASTW zmm1 {k1}{z}, reg",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Broadcast a 16-bit value from a GPR to all words in the 512-bit destination subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPB",
      "Description": "Compare Packed Byte Values Into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPB:VPCMPUB.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 3F /r ib",
          "Instruction": "VPCMPB k1 {k2}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 3F /r ib",
          "Instruction": "VPCMPB k1 {k2}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 3F /r ib",
          "Instruction": "VPCMPB k1 {k2}, zmm2, zmm3/m512, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPD",
      "Description": "Compare Packed Integer Values into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPD:VPCMPUD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 1F /r ib",
          "Instruction": "VPCMPD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 1F /r ib",
          "Instruction": "VPCMPD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 1F /r ib",
          "Instruction": "VPCMPD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPQ",
      "Description": "Compare Packed Integer Values into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPQ:VPCMPUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 1F /r ib",
          "Instruction": "VPCMPQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 1F /r ib",
          "Instruction": "VPCMPQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 1F /r ib",
          "Instruction": "VPCMPQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPUB",
      "Description": "Compare Packed Byte Values Into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPB:VPCMPUB.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 3E /r ib",
          "Instruction": "VPCMPUB k1 {k2}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte values in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 3E /r ib",
          "Instruction": "VPCMPUB k1 {k2}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned byte values in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 3E /r ib",
          "Instruction": "VPCMPUB k1 {k2}, zmm2, zmm3/m512, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed unsigned byte values in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPUD",
      "Description": "Compare Packed Integer Values into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPD:VPCMPUD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 1E /r ib",
          "Instruction": "VPCMPUD k1 {k2}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned doubleword integer values in xmm3/m128/m32bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 1E /r ib",
          "Instruction": "VPCMPUD k1 {k2}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned doubleword integer values in ymm3/m256/m32bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 1E /r ib",
          "Instruction": "VPCMPUD k1 {k2}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned doubleword integer values in zmm2 and zmm3/m512/m32bcst using bits 2:0 of imm8 as a comparison predicate. The comparison results are written to the destination k1 under writemask k2."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPUQ",
      "Description": "Compare Packed Integer Values into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPQ:VPCMPUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 1E /r ib",
          "Instruction": "VPCMPUQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 1E /r ib",
          "Instruction": "VPCMPUQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 1E /r ib",
          "Instruction": "VPCMPUQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPUW",
      "Description": "Compare Packed Word Values Into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPW:VPCMPUW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 3E /r ib",
          "Instruction": "VPCMPUW k1 {k2}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 3E /r ib",
          "Instruction": "VPCMPUW k1 {k2}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed unsigned word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCMPW",
      "Description": "Compare Packed Word Values Into Mask",
      "Url": "https://www.felixcloutier.com/x86/VPCMPW:VPCMPUW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 3F /r ib",
          "Instruction": "VPCMPW k1 {k2}, xmm2, xmm3/m128, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in xmm3/m128 and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 3F /r ib",
          "Instruction": "VPCMPW k1 {k2}, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Compare packed signed word integers in ymm3/m256 and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 3F /r ib",
          "Instruction": "VPCMPW k1 {k2}, zmm2, zmm3/m512, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Compare packed signed word integers in zmm3/m512 and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCOMPRESSD",
      "Description": "Store Sparse Packed Doubleword Integer Values into Dense Memory/Register",
      "Url": "https://www.felixcloutier.com/x86/VPCOMPRESSD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 8B /r",
          "Instruction": "VPCOMPRESSD xmm1/m128 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed doubleword integer values from xmm2 to xmm1/m128 using controlmask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 8B /r",
          "Instruction": "VPCOMPRESSD ymm1/m256 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed doubleword integer values from ymm2 to ymm1/m256 using controlmask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 8B /r",
          "Instruction": "VPCOMPRESSD zmm1/m512 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compress packed doubleword integer values from zmm2 to zmm1/m512 using controlmask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCOMPRESSQ",
      "Description": "Store Sparse Packed Quadword Integer Values into Dense Memory/Register",
      "Url": "https://www.felixcloutier.com/x86/VPCOMPRESSQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 8B /r",
          "Instruction": "VPCOMPRESSQ xmm1/m128 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed quadword integer values from xmm2 to xmm1/m128 using controlmask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 8B /r",
          "Instruction": "VPCOMPRESSQ ymm1/m256 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Compress packed quadword integer values from ymm2 to ymm1/m256 using controlmask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 8B /r",
          "Instruction": "VPCOMPRESSQ zmm1/m512 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Compress packed quadword integer values from zmm2 to zmm1/m512 using controlmask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCONFLICTD",
      "Description": "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register",
      "Url": "https://www.felixcloutier.com/x86/VPCONFLICTD:VPCONFLICTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 C4 /r",
          "Instruction": "VPCONFLICTD xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Detect duplicate double-word values in xmm2/m128/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 C4 /r",
          "Instruction": "VPCONFLICTD ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Detect duplicate double-word values in ymm2/m256/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 C4 /r",
          "Instruction": "VPCONFLICTD zmm1 {k1}{z}, zmm2/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Detect duplicate double-word values in zmm2/m512/m32bcst using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPCONFLICTQ",
      "Description": "Detect Conflicts Within a Vector of Packed Dword/Qword Values into Dense Memory/ Register",
      "Url": "https://www.felixcloutier.com/x86/VPCONFLICTD:VPCONFLICTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 C4 /r",
          "Instruction": "VPCONFLICTQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Detect duplicate quad-word values in xmm2/m128/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 C4 /r",
          "Instruction": "VPCONFLICTQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Detect duplicate quad-word values in ymm2/m256/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 C4 /r",
          "Instruction": "VPCONFLICTQ zmm1 {k1}{z}, zmm2/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Detect duplicate quad-word values in zmm2/m512/m64bcst using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERM2F128",
      "Description": "Permute Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VPERM2F128.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 06 /r ib",
          "Instruction": "VPERM2F128 ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute 128-bit floating-point fields in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv (r)",
            "ModRM:r/m (r)",
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPERM2I128",
      "Description": "Permute Integer Values",
      "Url": "https://www.felixcloutier.com/x86/VPERM2I128.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.256.66.0F3A.W0 46 /r ib",
          "Instruction": "VPERM2I128 ymm1, ymm2, ymm3/m256, imm8",
          "OperandEncoding": "RVMI",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Permute 128-bit integer data in ymm2 and ymm3/mem using controls from imm8 and store result in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVMI",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv",
            "ModRM:r/m (r)",
            "Imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPERMB",
      "Description": "Permute Packed Bytes Elements",
      "Url": "https://www.felixcloutier.com/x86/VPERMB.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 8D /r",
          "Instruction": "VPERMB xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in xmm3/m128 using byte indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 8D /r",
          "Instruction": "VPERMB ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in ymm3/m256 using byte indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 8D /r",
          "Instruction": "VPERMB zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512_VBMI",
          "Description": "Permute bytes in zmm3/m512 using byte indexes in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMD",
      "Description": "Permute Packed Doublewords/Words Elements",
      "Url": "https://www.felixcloutier.com/x86/VPERMD:VPERMW.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 36 /r",
          "Instruction": "VPERMD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Permute doublewords in ymm3/m256 using indices in ymm2 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 36 /r",
          "Instruction": "VPERMD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute doublewords in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 36 /r",
          "Instruction": "VPERMD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute doublewords in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2B",
      "Description": "Full Permute of Bytes from Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2B.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 75 /r",
          "Instruction": "VPERMI2B xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in xmm3/m128 and xmm2 using byte indexes in xmm1 and store the byte results in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 75 /r",
          "Instruction": "VPERMI2B ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in ymm3/m256 and ymm2 using byte indexes in ymm1 and store the byte results in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 75 /r",
          "Instruction": "VPERMI2B zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512_VBMI",
          "Description": "Permute bytes in zmm3/m512 and zmm2 using byte indexes in zmm1 and store the byte results in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2D",
      "Description": "Full Permute From Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 76 /r",
          "Instruction": "VPERMI2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 76 /r",
          "Instruction": "VPERMI2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 76 /r",
          "Instruction": "VPERMI2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2PD",
      "Description": "Full Permute From Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 77 /r",
          "Instruction": "VPERMI2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 77 /r",
          "Instruction": "VPERMI2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 77 /r",
          "Instruction": "VPERMI2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2PS",
      "Description": "Full Permute From Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 77 /r",
          "Instruction": "VPERMI2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 77 /r",
          "Instruction": "VPERMI2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 77 /r",
          "Instruction": "VPERMI2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2Q",
      "Description": "Full Permute From Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 76 /r",
          "Instruction": "VPERMI2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 76 /r",
          "Instruction": "VPERMI2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 76 /r",
          "Instruction": "VPERMI2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm2 using indices in zmm1 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMI2W",
      "Description": "Full Permute From Two Tables Overwriting the Index",
      "Url": "https://www.felixcloutier.com/x86/VPERMI2W:VPERMI2D:VPERMI2Q:VPERMI2PS:VPERMI2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 75 /r",
          "Instruction": "VPERMI2W xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers from two tables in xmm3/m128 and xmm2 using indexes in xmm1 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 75 /r",
          "Instruction": "VPERMI2W ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers from two tables in ymm3/m256 and ymm2 using indexes in ymm1 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 75 /r",
          "Instruction": "VPERMI2W zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Permute word integers from two tables in zmm3/m512 and zmm2 using indexes in zmm1 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMILPD",
      "Description": "Permute In-Lane of Pairs of Double-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VPERMILPD.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 0D /r",
          "Instruction": "VPERMILPD xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute double-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 0D /r",
          "Instruction": "VPERMILPD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute double-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 0D /r",
          "Instruction": "VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 0D /r",
          "Instruction": "VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 0D /r",
          "Instruction": "VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W0 05 /r ib",
          "Instruction": "VPERMILPD xmm1, xmm2/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute double-precision floating-point values in xmm2/m128 using controls from imm8."
        },
        {
          "Opcode": "VEX.256.66.0F3A.W0 05 /r ib",
          "Instruction": "VPERMILPD ymm1, ymm2/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute double-precision floating-point values in ymm2/m256 using controls from imm8."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.W1 05 /r ib",
          "Instruction": "VPERMILPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point values in xmm2/m128/m64bcst using controls from imm8 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 05 /r ib",
          "Instruction": "VPERMILPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point values in ymm2/m256/m64bcst using controls from imm8 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 05 /r ib",
          "Instruction": "VPERMILPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision floating-point values in zmm2/m512/m64bcst using controls from imm8 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMILPS",
      "Description": "Permute In-Lane of Quadruples of Single-Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/VPERMILPS.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 0C /r",
          "Instruction": "VPERMILPS xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute single-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1."
        },
        {
          "Opcode": "VEX.128.66.0F3A.W0 04 /r ib",
          "Instruction": "VPERMILPS xmm1, xmm2/m128, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute single-precision floating-point values in xmm2/m128 using controls from imm8 and store result in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 0C /r",
          "Instruction": "VPERMILPS ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute single-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1."
        },
        {
          "Opcode": "VEX.256.66.0F3A.W0 04 /r ib",
          "Instruction": "VPERMILPS ymm1, ymm2/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Permute single-precision floating-point values in ymm2/m256 using controls from imm8 and store result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 0C /r",
          "Instruction": "VPERMILPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision floating-point values xmm2 using control from xmm3/m128/m32bcst and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 0C /r",
          "Instruction": "VPERMILPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision floating-point values ymm2 using control from ymm3/m256/m32bcst and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 0C /r",
          "Instruction": "VPERMILPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute single-precision floating-point values zmm2 using control from zmm3/m512/m32bcst and store the result in zmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.128.66.0F3A.W0 04 /r ib",
          "Instruction": "VPERMILPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision floating-point values xmm2/m128/m32bcst using controls from imm8 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 04 /r ib",
          "Instruction": "VPERMILPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision floating-point values ymm2/m256/m32bcst using controls from imm8 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 04 /r",
          "Instruction": "ibVPERMILPS zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute single-precision floating-point values zmm2/m512/m32bcst using controls from imm8 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMPD",
      "Description": "Permute Double-Precision Floating-Point Elements",
      "Url": "https://www.felixcloutier.com/x86/VPERMPD.html",
      "Table": [
        {
          "Opcode": "VEX.256.66.0F3A.W1 01 /r ib",
          "Instruction": "VPERMPD ymm1, ymm2/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Permute double-precision floating-point elements in ymm2/m256 using indices in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 01 /r ib",
          "Instruction": "VPERMPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point elements in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 01 /r ib",
          "Instruction": "VPERMPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision floating-point elements in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 16 /r",
          "Instruction": "VPERMPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision floating-point elements in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1 subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 16 /r",
          "Instruction": "VPERMPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision floating-point elements in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMPS",
      "Description": "Permute Single-Precision Floating-Point Elements",
      "Url": "https://www.felixcloutier.com/x86/VPERMPS.html",
      "Table": [
        {
          "Opcode": "VEX.256.66.0F38.W0 16 /r",
          "Instruction": "VPERMPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Permute single-precision floating-point elements in ymm3/m256 using indices in ymm2 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 16 /r",
          "Instruction": "VPERMPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision floating-point elements in ymm3/m256/m32bcst using indexes in ymm2 and store the result in ymm1 subject to write mask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 16 /r",
          "Instruction": "VPERMPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute single-precision floating-point values in zmm3/m512/m32bcst using indices in zmm2 and store the result in zmm1 subject to write mask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMQ",
      "Description": "Qwords Element Permutation",
      "Url": "https://www.felixcloutier.com/x86/VPERMQ.html",
      "Table": [
        {
          "Opcode": "VEX.256.66.0F3A.W1 00 /r ib",
          "Instruction": "VPERMQ ymm1, ymm2/m256, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Permute qwords in ymm2/m256 using indices in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 00 /r ib",
          "Instruction": "VPERMQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute qwords in ymm2/m256/m64bcst using indexes in imm8 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 00 /r ib",
          "Instruction": "VPERMQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute qwords in zmm2/m512/m64bcst using indices in imm8 and store the result in zmm1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 36 /r",
          "Instruction": "VPERMQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute qwords in ymm3/m256/m64bcst using indexes in ymm2 and store the result in ymm1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 36 /r",
          "Instruction": "VPERMQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute qwords in zmm3/m512/m64bcst using indices in zmm2 and store the result in zmm1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2B",
      "Description": "Full Permute of Bytes from Two Tables Overwriting a Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2B.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 7D /r",
          "Instruction": "VPERMT2B xmm1 {k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in xmm3/m128 and xmm1 using byte indexes in xmm2 and store the byte results in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 7D /r",
          "Instruction": "VPERMT2B ymm1 {k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512_VBMI",
          "Description": "Permute bytes in ymm3/m256 and ymm1 using byte indexes in ymm2 and store the byte results in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 7D /r",
          "Instruction": "VPERMT2B zmm1 {k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512_VBMI",
          "Description": "Permute bytes in zmm3/m512 and zmm1 using byte indexes in zmm2 and store the byte results in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2D",
      "Description": "Full Permute from Two Tables Overwriting one Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 7E /r",
          "Instruction": "VPERMT2D xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-words from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 7E /r",
          "Instruction": "VPERMT2D ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-words from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 7E /r",
          "Instruction": "VPERMT2D zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-words from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2PD",
      "Description": "Full Permute from Two Tables Overwriting one Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 7F /r",
          "Instruction": "VPERMT2PD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision FP values from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 7F /r",
          "Instruction": "VPERMT2PD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute double-precision FP values from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 7F /r",
          "Instruction": "VPERMT2PD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute double-precision FP values from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2PS",
      "Description": "Full Permute from Two Tables Overwriting one Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W0 7F /r",
          "Instruction": "VPERMT2PS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision FP values from two tables in xmm3/m128/m32bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W0 7F /r",
          "Instruction": "VPERMT2PS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute single-precision FP values from two tables in ymm3/m256/m32bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W0 7F /r",
          "Instruction": "VPERMT2PS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute single-precision FP values from two tables in zmm3/m512/m32bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2Q",
      "Description": "Full Permute from Two Tables Overwriting one Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 7E /r",
          "Instruction": "VPERMT2Q xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute quad-words from two tables in xmm3/m128/m64bcst and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 7E /r",
          "Instruction": "VPERMT2Q ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Permute quad-words from two tables in ymm3/m256/m64bcst and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 7E /r",
          "Instruction": "VPERMT2Q zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Permute quad-words from two tables in zmm3/m512/m64bcst and zmm1 using indices in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMT2W",
      "Description": "Full Permute from Two Tables Overwriting one Table",
      "Url": "https://www.felixcloutier.com/x86/VPERMT2W:VPERMT2D:VPERMT2Q:VPERMT2PS:VPERMT2PD.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 7D /r",
          "Instruction": "VPERMT2W xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers from two tables in xmm3/m128 and xmm1 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 7D /r",
          "Instruction": "VPERMT2W ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers from two tables in ymm3/m256 and ymm1 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 7D /r",
          "Instruction": "VPERMT2W zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Permute word integers from two tables in zmm3/m512 and zmm1 using indexes in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPERMW",
      "Description": "Permute Packed Doublewords/Words Elements",
      "Url": "https://www.felixcloutier.com/x86/VPERMD:VPERMW.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 8D /r",
          "Instruction": "VPERMW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers in xmm3/m128 using indexes in xmm2 and store the result in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 8D /r",
          "Instruction": "VPERMW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Permute word integers in ymm3/m256 using indexes in ymm2 and store the result in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 8D /r",
          "Instruction": "VPERMW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Permute word integers in zmm3/m512 using indexes in zmm2 and store the result in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPEXPANDD",
      "Description": "Load Sparse Packed Doubleword Integer Values from Dense Memory / Register",
      "Url": "https://www.felixcloutier.com/x86/VPEXPANDD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 89 /r",
          "Instruction": "VPEXPANDD xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed double-word integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 89 /r",
          "Instruction": "VPEXPANDD ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed double-word integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 89 /r",
          "Instruction": "VPEXPANDD zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Expand packed double-word integer values from zmm2/m512 to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPEXPANDQ",
      "Description": "Load Sparse Packed Quadword Integer Values from Dense Memory / Register",
      "Url": "https://www.felixcloutier.com/x86/VPEXPANDQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 89 /r",
          "Instruction": "VPEXPANDQ xmm1 {k1}{z}, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed quad-word integer values from xmm2/m128 to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 89 /r",
          "Instruction": "VPEXPANDQ ymm1 {k1}{z}, ymm2/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Expand packed quad-word integer values from ymm2/m256 to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 89 /r",
          "Instruction": "VPEXPANDQ zmm1 {k1}{z}, zmm2/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Expand packed quad-word integer values from zmm2/m512 to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERDD",
      "Description": "Gather Packed Dword Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 90 /r",
          "Instruction": "VPGATHERDD xmm1, vm32x, xmm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 90 /r",
          "Instruction": "VPGATHERDD ymm1, vm32y, ymm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32y, gather dword from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERDD",
      "UniqueName": "vpgatherdd_s",
      "Description": "Gather Packed Dword, Packed Qword with Signed Dword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDD:VPGATHERDQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 90 /vsib",
          "Instruction": "VPGATHERDD xmm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 90 /vsib",
          "Instruction": "VPGATHERDD ymm1 {k1}, vm32y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 90 /vsib",
          "Instruction": "VPGATHERDD zmm1 {k1}, vm32z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, gather dword values from memory using writemask k1 for merging-masking."
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERDQ",
      "UniqueName": "vpgatherdq_s",
      "Description": "Gather Packed Dword, Packed Qword with Signed Dword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDD:VPGATHERDQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 90 /vsib",
          "Instruction": "VPGATHERDQ xmm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 90 /vsib",
          "Instruction": "VPGATHERDQ ymm1 {k1}, vm32x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 90 /vsib",
          "Instruction": "VPGATHERDQ zmm1 {k1}, vm32y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, gather quadword values from memory using writemask k1 for merging-masking."
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERDQ",
      "Description": "Gather Packed Qword Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 90 /r",
          "Instruction": "VPGATHERDQ xmm1, vm32x, xmm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 90 /r",
          "Instruction": "VPGATHERDQ ymm1, vm32x, ymm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using dword indices specified in vm32x, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERQD",
      "Description": "Gather Packed Dword Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDD:VPGATHERQD.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W0 91 /r",
          "Instruction": "VPGATHERQD xmm1, vm64x, xmm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64x, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W0 91 /r",
          "Instruction": "VPGATHERQD xmm1, vm64y, xmm2",
          "OperandEncoding": "RMV",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64y, gather dword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RMV",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERQD",
      "UniqueName": "vpgatherqd_s",
      "Description": "Gather Packed Dword, Packed Qword with Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERQD:VPGATHERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 91 /vsib",
          "Instruction": "VPGATHERQD xmm1 {k1}, vm64x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 91 /vsib",
          "Instruction": "VPGATHERQD xmm1 {k1}, vm64y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 91 /vsib",
          "Instruction": "VPGATHERQD ymm1 {k1}, vm64z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, gather dword values from memory using writemask k1 for merging-masking."
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERQQ",
      "Description": "Gather Packed Qword Values Using Signed Dword/Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERDQ:VPGATHERQQ.html",
      "Table": [
        {
          "Opcode": "VEX.DDS.128.66.0F38.W1 91 /r",
          "Instruction": "VPGATHERQQ xmm1, vm64x, xmm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64x, gather qword values from memory conditioned on mask specified by xmm2. Conditionally gathered elements are merged into xmm1."
        },
        {
          "Opcode": "VEX.DDS.256.66.0F38.W1 91 /r",
          "Instruction": "VPGATHERQQ ymm1, vm64y, ymm2",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Using qword indices specified in vm64y, gather qword values from memory conditioned on mask specified by ymm2. Conditionally gathered elements are merged into ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "ModRM:reg (r,w)",
            "BaseReg (R): VSIB:base, VectorReg(R): VSIB:index",
            "VEX.vvvv (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPGATHERQQ",
      "UniqueName": "vpgatherqq_s",
      "Description": "Gather Packed Dword, Packed Qword with Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPGATHERQD:VPGATHERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 91 /vsib",
          "Instruction": "VPGATHERQQ xmm1 {k1}, vm64x",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 91 /vsib",
          "Instruction": "VPGATHERQQ ymm1 {k1}, vm64y",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 91 /vsib",
          "Instruction": "VPGATHERQQ zmm1 {k1}, vm64z",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, gather quadword values from memory using writemask k1 for merging-masking."
        }
      ]
    },
    {
      "Mnemonic": "VPLZCNTD",
      "Description": "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values",
      "Url": "https://www.felixcloutier.com/x86/VPLZCNTD:VPLZCNTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 44 /r",
          "Instruction": "VPLZCNTD xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Count the number of leading zero bits in each dword element of xmm2/m128/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 44 /r",
          "Instruction": "VPLZCNTD ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Count the number of leading zero bits in each dword element of ymm2/m256/m32bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 44 /r",
          "Instruction": "VPLZCNTD zmm1 {k1}{z}, zmm2/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Count the number of leading zero bits in each dword element of zmm2/m512/m32bcst using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPLZCNTQ",
      "Description": "Count the Number of Leading Zero Bits for Packed Dword, Packed Qword Values",
      "Url": "https://www.felixcloutier.com/x86/VPLZCNTD:VPLZCNTQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 44 /r",
          "Instruction": "VPLZCNTQ xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Count the number of leading zero bits in each qword element of xmm2/m128/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 44 /r",
          "Instruction": "VPLZCNTQ ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512CD",
          "Description": "Count the number of leading zero bits in each qword element of ymm2/m256/m64bcst using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 44 /r",
          "Instruction": "VPLZCNTQ zmm1 {k1}{z}, zmm2/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512CD",
          "Description": "Count the number of leading zero bits in each qword element of zmm2/m512/m64bcst using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMADD52HUQ",
      "Description": "Packed Multiply of Unsigned 52-bit Unsigned Integers and Add High 52-bit Products to 64-bit Accumulators",
      "Url": "https://www.felixcloutier.com/x86/VPMADD52HUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 B5 /r",
          "Instruction": "VPMADD52HUQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 B5 /r",
          "Instruction": "VPMADD52HUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 B5 /r",
          "Instruction": "VPMADD52HUQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m128 and add the high 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMADD52LUQ",
      "Description": "Packed Multiply of Unsigned 52-bit Integers and Add the Low 52-bit Products to Qword Accumulators",
      "Url": "https://www.felixcloutier.com/x86/VPMADD52LUQ.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F38.W1 B4 /r",
          "Instruction": "VPMADD52LUQ xmm1 {k1}{z}, xmm2,xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in xmm2 and xmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F38.W1 B4 /r",
          "Instruction": "VPMADD52LUQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in ymm2 and ymm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F38.W1 B4 /r",
          "Instruction": "VPMADD52LUQ zmm1 {k1}{z}, zmm2,zmm3/m512/m64bcst",
          "OperandEncoding": "A",
          "Description": "Multiply unsigned 52-bit integers in zmm2 and zmm3/m128 and add the low 52 bits of the 104-bit product to the qword unsigned integers in zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMASKMOV",
      "Description": "Conditional SIMD Integer Packed Loads and Stores",
      "Url": "https://www.felixcloutier.com/x86/VPMASKMOV.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 8C /r",
          "Instruction": "VPMASKMOVD xmm1, xmm2, m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally load dword values from m128 using mask in xmm2 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 8C /r",
          "Instruction": "VPMASKMOVD ymm1, ymm2, m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally load dword values from m256 using mask in ymm2 and store in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 8C /r",
          "Instruction": "VPMASKMOVQ xmm1, xmm2, m128",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally load qword values from m128 using mask in xmm2 and store in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 8C /r",
          "Instruction": "VPMASKMOVQ ymm1, ymm2, m256",
          "OperandEncoding": "RVM",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally load qword values from m256 using mask in ymm2 and store in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 8E /r",
          "Instruction": "VPMASKMOVD m128, xmm1, xmm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally store dword values from xmm2 using mask in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 8E /r",
          "Instruction": "VPMASKMOVD m256, ymm1, ymm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally store dword values from ymm2 using mask in ymm1."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 8E /r",
          "Instruction": "VPMASKMOVQ m128, xmm1, xmm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally store qword values from xmm2 using mask in xmm1."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 8E /r",
          "Instruction": "VPMASKMOVQ m256, ymm1, ymm2",
          "OperandEncoding": "MVR",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Conditionally store qword values from ymm2 using mask in ymm1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RVM",
          "Operands": [
            "ModRM:reg (w)",
            "VEX.vvvv",
            "ModRM:r/m (r)"
          ]
        },
        {
          "OperandEncoding": "MVR",
          "Operands": [
            "ModRM:r/m (w)",
            "VEX.vvvv",
            "ModRM:reg (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVB2M",
      "Description": "Convert a Vector Register to a Mask",
      "Url": "https://www.felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 29 /r",
          "Instruction": "VPMOVB2M k1, xmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in XMM1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 29 /r",
          "Instruction": "VPMOVB2M k1, ymm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in YMM1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 29 /r",
          "Instruction": "VPMOVB2M k1, zmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding byte in ZMM1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVD2M",
      "Description": "Convert a Vector Register to a Mask",
      "Url": "https://www.felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 39 /r",
          "Instruction": "VPMOVD2M k1, xmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in XMM1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 39 /r",
          "Instruction": "VPMOVD2M k1, ymm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in YMM1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 39 /r",
          "Instruction": "VPMOVD2M k1, zmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding doubleword in ZMM1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVDB",
      "Description": "Down Convert DWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 31 /r",
          "Instruction": "VPMOVDB xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed double-word integers from xmm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 31 /r",
          "Instruction": "VPMOVDB xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed double-word integers from ymm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 31 /r",
          "Instruction": "VPMOVDB xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed double-word integers from zmm2 into 16 packed byte integers in xmm1/m128 with truncation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVDW",
      "Description": "Down Convert DWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 33 /r",
          "Instruction": "VPMOVDW xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed double-word integers from xmm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 33 /r",
          "Instruction": "VPMOVDW xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed double-word integers from ymm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 33 /r",
          "Instruction": "VPMOVDW ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed double-word integers from zmm2 into 16 packed word integers in ymm1/m256 with truncation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVM2B",
      "Description": "Convert a Mask Register to a Vector Register",
      "Url": "https://www.felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 28 /r",
          "Instruction": "VPMOVM2B xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each byte in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 28 /r",
          "Instruction": "VPMOVM2B ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each byte in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 28 /r",
          "Instruction": "VPMOVM2B zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Sets each byte in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVM2D",
      "Description": "Convert a Mask Register to a Vector Register",
      "Url": "https://www.felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 38 /r",
          "Instruction": "VPMOVM2D xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each doubleword in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 38 /r",
          "Instruction": "VPMOVM2D ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each doubleword in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 38 /r",
          "Instruction": "VPMOVM2D zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Sets each doubleword in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVM2Q",
      "Description": "Convert a Mask Register to a Vector Register",
      "Url": "https://www.felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W1 38 /r",
          "Instruction": "VPMOVM2Q xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each quadword in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W1 38 /r",
          "Instruction": "VPMOVM2Q ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each quadword in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W1 38 /r",
          "Instruction": "VPMOVM2Q zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Sets each quadword in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVM2W",
      "Description": "Convert a Mask Register to a Vector Register",
      "Url": "https://www.felixcloutier.com/x86/VPMOVM2B:VPMOVM2W:VPMOVM2D:VPMOVM2Q.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W1 28 /r",
          "Instruction": "VPMOVM2W xmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each word in XMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W1 28 /r",
          "Instruction": "VPMOVM2W ymm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each word in YMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W1 28 /r",
          "Instruction": "VPMOVM2W zmm1, k1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Sets each word in ZMM1 to all 1’s or all 0’s based on the value of the corresponding bit in k1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVQ2M",
      "Description": "Convert a Vector Register to a Mask",
      "Url": "https://www.felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W1 39 /r",
          "Instruction": "VPMOVQ2M k1, xmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in XMM1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W1 39 /r",
          "Instruction": "VPMOVQ2M k1, ymm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in YMM1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W1 39 /r",
          "Instruction": "VPMOVQ2M k1, zmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding quadword in ZMM1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVQB",
      "Description": "Down Convert QWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 32 /r",
          "Instruction": "VPMOVQB xmm1/m16 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed byte integers in xmm1/m16 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 32 /r",
          "Instruction": "VPMOVQB xmm1/m32 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed byte integers in xmm1/m32 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 32 /r",
          "Instruction": "VPMOVQB xmm1/m64 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed byte integers in xmm1/m64 with truncation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVQD",
      "Description": "Down Convert QWord to DWord",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 35 /r",
          "Instruction": "VPMOVQD xmm1/m128 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 35 /r",
          "Instruction": "VPMOVQD xmm1/m128 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed double-word integers in xmm1/m128 with truncation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 35 /r",
          "Instruction": "VPMOVQD ymm1/m256 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed double-word integers in ymm1/m256 with truncation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVQW",
      "Description": "Down Convert QWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 34 /r",
          "Instruction": "VPMOVQW xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed quad-word integers from xmm2 into 2 packed word integers in xmm1/m32 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 34 /r",
          "Instruction": "VPMOVQW xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed quad-word integers from ymm2 into 4 packed word integers in xmm1/m64 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 34 /r",
          "Instruction": "VPMOVQW xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed quad-word integers from zmm2 into 8 packed word integers in xmm1/m128 with truncation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSDB",
      "Description": "Down Convert DWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 21 /r",
          "Instruction": "VPMOVSDB xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 21 /r",
          "Instruction": "VPMOVSDB xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 21 /r",
          "Instruction": "VPMOVSDB xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed byte integers in xmm1/m128 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSDW",
      "Description": "Down Convert DWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 23 /r",
          "Instruction": "VPMOVSDW xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed signed double-word integers from xmm2 into 4 packed signed word integers in ymm1/m64 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 23 /r",
          "Instruction": "VPMOVSDW xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed signed double-word integers from ymm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 23 /r",
          "Instruction": "VPMOVSDW ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed signed double-word integers from zmm2 into 16 packed signed word integers in ymm1/m256 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSQB",
      "Description": "Down Convert QWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 22 /r",
          "Instruction": "VPMOVSQB xmm1/m16 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed byte integers in xmm1/m16 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 22 /r",
          "Instruction": "VPMOVSQB xmm1/m32 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed byte integers in xmm1/m32 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 22 /r",
          "Instruction": "VPMOVSQB xmm1/m64 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed byte integers in xmm1/m64 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSQD",
      "Description": "Down Convert QWord to DWord",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 25 /r",
          "Instruction": "VPMOVSQD xmm1/m64 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed signed quad-word integers from xmm2 into 2 packed signed double-word integers in xmm1/m64 using signed saturation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 25 /r",
          "Instruction": "VPMOVSQD xmm1/m128 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed double-word integers in xmm1/m128 using signed saturation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 25 /r",
          "Instruction": "VPMOVSQD ymm1/m256 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed double-word integers in ymm1/m256 using signed saturation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSQW",
      "Description": "Down Convert QWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 24 /r",
          "Instruction": "VPMOVSQW xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m32 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 24 /r",
          "Instruction": "VPMOVSQW xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed signed quad-word integers from ymm2 into 4 packed signed word integers in xmm1/m64 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 24 /r",
          "Instruction": "VPMOVSQW xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed signed quad-word integers from zmm2 into 8 packed signed word integers in xmm1/m128 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVSWB",
      "Description": "Down Convert Word to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 20 /r",
          "Instruction": "VPMOVSWB xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 8 packed signed word integers from xmm2 into 8 packed signed bytes in xmm1/m64 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 20 /r",
          "Instruction": "VPMOVSWB xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 16 packed signed word integers from ymm2 into 16 packed signed bytes in xmm1/m128 using signed saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 20 /r",
          "Instruction": "VPMOVSWB ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Converts 32 packed signed word integers from zmm2 into 32 packed signed bytes in ymm1/m256 using signed saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSDB",
      "Description": "Down Convert DWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDB:VPMOVSDB:VPMOVUSDB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 11 /r",
          "Instruction": "VPMOVUSDB xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 11 /r",
          "Instruction": "VPMOVUSDB xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 11 /r",
          "Instruction": "VPMOVUSDB xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned byte integers in xmm1/m128 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSDW",
      "Description": "Down Convert DWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVDW:VPMOVSDW:VPMOVUSDW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 13 /r",
          "Instruction": "VPMOVUSDW xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed unsigned double-word integers from xmm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 13 /r",
          "Instruction": "VPMOVUSDW xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 8 packed unsigned double-word integers from ymm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 13 /r",
          "Instruction": "VPMOVUSDW ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 16 packed unsigned double-word integers from zmm2 into 16 packed unsigned word integers in ymm1/m256 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSQB",
      "Description": "Down Convert QWord to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQB:VPMOVSQB:VPMOVUSQB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 12 /r",
          "Instruction": "VPMOVUSQB xmm1/m16 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned byte integers in xmm1/m16 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 12 /r",
          "Instruction": "VPMOVUSQB xmm1/m32 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned byte integers in xmm1/m32 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 12 /r",
          "Instruction": "VPMOVUSQB xmm1/m64 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned byte integers in xmm1/m64 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSQD",
      "Description": "Down Convert QWord to DWord",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQD:VPMOVSQD:VPMOVUSQD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 15 /r",
          "Instruction": "VPMOVUSQD xmm1/m64 {k1}{z}, xmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned double-word integers in xmm1/m64 using unsigned saturation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 15 /r",
          "Instruction": "VPMOVUSQD xmm1/m128 {k1}{z}, ymm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned double-word integers in xmm1/m128 using unsigned saturation subject to writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 15 /r",
          "Instruction": "VPMOVUSQD ymm1/m256 {k1}{z}, zmm2",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned double-word integers in ymm1/m256 using unsigned saturation subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSQW",
      "Description": "Down Convert QWord to Word",
      "Url": "https://www.felixcloutier.com/x86/VPMOVQW:VPMOVSQW:VPMOVUSQW.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 14 /r",
          "Instruction": "VPMOVUSQW xmm1/m32 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 2 packed unsigned quad-word integers from xmm2 into 2 packed unsigned word integers in xmm1/m32 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 14 /r",
          "Instruction": "VPMOVUSQW xmm1/m64 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Converts 4 packed unsigned quad-word integers from ymm2 into 4 packed unsigned word integers in xmm1/m64 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 14 /r",
          "Instruction": "VPMOVUSQW xmm1/m128 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Converts 8 packed unsigned quad-word integers from zmm2 into 8 packed unsigned word integers in xmm1/m128 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVUSWB",
      "Description": "Down Convert Word to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 10 /r",
          "Instruction": "VPMOVUSWB xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 8 packed unsigned word integers from xmm2 into 8 packed unsigned bytes in 8mm1/m64 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 10 /r",
          "Instruction": "VPMOVUSWB xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 16 packed unsigned word integers from ymm2 into 16 packed unsigned bytes in xmm1/m128 using unsigned saturation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 10 /r",
          "Instruction": "VPMOVUSWB ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Converts 32 packed unsigned word integers from zmm2 into 32 packed unsigned bytes in ymm1/m256 using unsigned saturation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMOVW2M",
      "Description": "Convert a Vector Register to a Mask",
      "Url": "https://www.felixcloutier.com/x86/VPMOVB2M:VPMOVW2M:VPMOVD2M:VPMOVQ2M.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W1 29 /r",
          "Instruction": "VPMOVW2M k1, xmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in XMM1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W1 29 /r",
          "Instruction": "VPMOVW2M k1, ymm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in YMM1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W1 29 /r",
          "Instruction": "VPMOVW2M k1, zmm1",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Sets each bit in k1 to 1 or 0 based on the value of the most significant bit of the corresponding word in ZMM1."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VPMOVWB",
      "Description": "Down Convert Word to Byte",
      "Url": "https://www.felixcloutier.com/x86/VPMOVWB:VPMOVSWB:VPMOVUSWB.html",
      "Table": [
        {
          "Opcode": "EVEX.128.F3.0F38.W0 30 /r",
          "Instruction": "VPMOVWB xmm1/m64 {k1}{z}, xmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 8 packed word integers from xmm2 into 8 packed bytes in xmm1/m64 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.256.F3.0F38.W0 30 /r",
          "Instruction": "VPMOVWB xmm1/m128 {k1}{z}, ymm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Converts 16 packed word integers from ymm2 into 16 packed bytes in xmm1/m128 with truncation under writemask k1."
        },
        {
          "Opcode": "EVEX.512.F3.0F38.W0 30 /r",
          "Instruction": "VPMOVWB ymm1/m256 {k1}{z}, zmm2",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Converts 32 packed word integers from zmm2 into 32 packed bytes in ymm1/m256 with truncation under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPMULTISHIFTQB",
      "Description": "Select Packed Unaligned Bytes from Quadword Sources",
      "Url": "https://www.felixcloutier.com/x86/VPMULTISHIFTQB.html"
    },
    {
      "Mnemonic": "VPROLD",
      "Description": "Bit Rotate Left",
      "Url": "https://www.felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDD.128.66.0F.W0 72 /1 ib",
          "Instruction": "VPROLD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in xmm2/m128/m32bcst left by imm8. Result written to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.W0 72 /1 ib",
          "Instruction": "VPROLD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in ymm2/m256/m32bcst left by imm8. Result written to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.W0 72 /1 ib",
          "Instruction": "VPROLD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate left of doublewords in zmm3/m512/m32bcst by imm8. Result written to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPROLQ",
      "Description": "Bit Rotate Left",
      "Url": "https://www.felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDD.128.66.0F.W1 72 /1 ib",
          "Instruction": "VPROLQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in xmm2/m128/m64bcst left by imm8. Result written to xmm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.W1 72 /1 ib",
          "Instruction": "VPROLQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in ymm2/m256/m64bcst left by imm8. Result written to ymm1 using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.W1 72 /1 ib",
          "Instruction": "VPROLQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate quadwords in zmm2/m512/m64bcst left by imm8. Result written to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPROLVD",
      "Description": "Bit Rotate Left",
      "Url": "https://www.felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 15 /r",
          "Instruction": "VPROLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in xmm2 left by count in the corresponding element of xmm3/m128/m32bcst. Result written to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 15 /r",
          "Instruction": "VPROLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in ymm2 left by count in the corresponding element of ymm3/m256/m32bcst. Result written to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 15 /r",
          "Instruction": "VPROLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate left of doublewords in zmm2 by count in the corresponding element of zmm3/m512/m32bcst. Result written to zmm1 using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPROLVQ",
      "Description": "Bit Rotate Left",
      "Url": "https://www.felixcloutier.com/x86/VPROLD:VPROLVD:VPROLQ:VPROLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 15 /r",
          "Instruction": "VPROLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in xmm2 left by count in the corresponding element of xmm3/m128/m64bcst. Result written to xmm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 15 /r",
          "Instruction": "VPROLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in ymm2 left by count in the corresponding element of ymm3/m256/m64bcst. Result written to ymm1 under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 15 /r",
          "Instruction": "VPROLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate quadwords in zmm2 left by count in the corresponding element of zmm3/m512/m64bcst. Result written to zmm1under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPRORD",
      "Description": "Bit Rotate Right",
      "Url": "https://www.felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDD.128.66.0F.W0 72 /0 ib",
          "Instruction": "VPRORD xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in xmm2/m128/m32bcst right by imm8, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.W0 72 /0 ib",
          "Instruction": "VPRORD ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in ymm2/m256/m32bcst right by imm8, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.W0 72 /0 ib",
          "Instruction": "VPRORD zmm1 {k1}{z}, zmm2/m512/m32bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate doublewords in zmm2/m512/m32bcst right by imm8, store result using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPRORQ",
      "Description": "Bit Rotate Right",
      "Url": "https://www.felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDD.128.66.0F.W1 72 /0 ib",
          "Instruction": "VPRORQ xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in xmm2/m128/m64bcst right by imm8, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.256.66.0F.W1 72 /0 ib",
          "Instruction": "VPRORQ ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in ymm2/m256/m64bcst right by imm8, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDD.512.66.0F.W1 72 /0 ib",
          "Instruction": "VPRORQ zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate quadwords in zmm2/m512/m64bcst right by imm8, store result using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPRORVD",
      "Description": "Bit Rotate Right",
      "Url": "https://www.felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 14 /r",
          "Instruction": "VPRORVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in xmm2 right by count in the corresponding element of xmm3/m128/m32bcst, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 14 /r",
          "Instruction": "VPRORVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate doublewords in ymm2 right by count in the corresponding element of ymm3/m256/m32bcst, store using result writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 14 /r",
          "Instruction": "VPRORVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate doublewords in zmm2 right by count in the corresponding element of zmm3/m512/m32bcst, store result using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPRORVQ",
      "Description": "Bit Rotate Right",
      "Url": "https://www.felixcloutier.com/x86/VPRORD:VPRORVD:VPRORQ:VPRORVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 14 /r",
          "Instruction": "VPRORVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in xmm2 right by count in the corresponding element of xmm3/m128/m64bcst, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 14 /r",
          "Instruction": "VPRORVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rotate quadwords in ymm2 right by count in the corresponding element of ymm3/m256/m64bcst, store result using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 14 /r",
          "Instruction": "VPRORVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rotate quadwords in zmm2 right by count in the corresponding element of zmm3/m512/m64bcst, store result using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSCATTERDD",
      "Description": "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 A0 /vsib",
          "Instruction": "VPSCATTERDD vm32x {k1}, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter dword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 A0 /vsib",
          "Instruction": "VPSCATTERDD vm32y {k1}, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter dword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 A0 /vsib",
          "Instruction": "VPSCATTERDD vm32z {k1}, zmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, scatter dword values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSCATTERDQ",
      "Description": "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 A0 /vsib",
          "Instruction": "VPSCATTERDQ vm32x {k1}, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter qword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 A0 /vsib",
          "Instruction": "VPSCATTERDQ vm32x {k1}, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter qword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 A0 /vsib",
          "Instruction": "VPSCATTERDQ vm32y {k1}, zmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, scatter qword values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSCATTERQD",
      "Description": "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 A1 /vsib",
          "Instruction": "VPSCATTERQD vm64x {k1}, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter dword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 A1 /vsib",
          "Instruction": "VPSCATTERQD vm64y {k1}, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter dword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 A1 /vsib",
          "Instruction": "VPSCATTERQD vm64z {k1}, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, scatter dword values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSCATTERQQ",
      "Description": "Scatter Packed Dword, Packed Qword with Signed Dword, Signed Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VPSCATTERDD:VPSCATTERDQ:VPSCATTERQD:VPSCATTERQQ.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 A1 /vsib",
          "Instruction": "VPSCATTERQQ vm64x {k1}, xmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter qword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 A1 /vsib",
          "Instruction": "VPSCATTERQQ vm64y {k1}, ymm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter qword values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 A1 /vsib",
          "Instruction": "VPSCATTERQQ vm64z {k1}, zmm1",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, scatter qword values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSLLVD",
      "Description": "Variable Bit Shift Left Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 47 /r",
          "Instruction": "VPSLLVD xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 47 /r",
          "Instruction": "VPSLLVD ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 47 /r",
          "Instruction": "VPSLLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 47 /r",
          "Instruction": "VPSLLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 47 /r",
          "Instruction": "VPSLLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift doublewords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSLLVQ",
      "Description": "Variable Bit Shift Left Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 47 /r",
          "Instruction": "VPSLLVQ xmm1, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 47 /r",
          "Instruction": "VPSLLVQ ymm1, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 47 /r",
          "Instruction": "VPSLLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in xmm2 left by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 47 /r",
          "Instruction": "VPSLLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in ymm2 left by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 47 /r",
          "Instruction": "VPSLLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift quadwords in zmm2 left by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSLLVW",
      "Description": "Variable Bit Shift Left Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSLLVW:VPSLLVD:VPSLLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 12 /r",
          "Instruction": "VPSLLVW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in xmm2 left by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 12 /r",
          "Instruction": "VPSLLVW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in ymm2 left by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 12 /r",
          "Instruction": "VPSLLVW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift words in zmm2 left by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRAVD",
      "Description": "Variable Bit Shift Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 46 /r",
          "Instruction": "VPSRAVD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 46 /r",
          "Instruction": "VPSRAVD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 46 /r",
          "Instruction": "VPSRAVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 46 /r",
          "Instruction": "VPSRAVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 46 /r",
          "Instruction": "VPSRAVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in sign bits using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRAVQ",
      "Description": "Variable Bit Shift Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 46 /r",
          "Instruction": "VPSRAVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 46 /r",
          "Instruction": "VPSRAVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 46 /r",
          "Instruction": "VPSRAVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in sign bits using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRAVW",
      "Description": "Variable Bit Shift Right Arithmetic",
      "Url": "https://www.felixcloutier.com/x86/VPSRAVW:VPSRAVD:VPSRAVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 11 /r",
          "Instruction": "VPSRAVW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 11 /r",
          "Instruction": "VPSRAVW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in sign bits using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 11 /r",
          "Instruction": "VPSRAVW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in sign bits using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRLVD",
      "Description": "Variable Bit Shift Right Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W0 45 /r",
          "Instruction": "VPSRLVD xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W0 45 /r",
          "Instruction": "VPSRLVD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 45 /r",
          "Instruction": "VPSRLVD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m32bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 45 /r",
          "Instruction": "VPSRLVD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift doublewords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m32bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 45 /r",
          "Instruction": "VPSRLVD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift doublewords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m32bcst while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRLVQ",
      "Description": "Variable Bit Shift Right Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html",
      "Table": [
        {
          "Opcode": "VEX.NDS.128.66.0F38.W1 45 /r",
          "Instruction": "VPSRLVQ xmm1, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F38.W1 45 /r",
          "Instruction": "VPSRLVQ ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX2",
          "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 45 /r",
          "Instruction": "VPSRLVQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in xmm2 right by amount specified in the corresponding element of xmm3/m128/m64bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 45 /r",
          "Instruction": "VPSRLVQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Shift quadwords in ymm2 right by amount specified in the corresponding element of ymm3/m256/m64bcst while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 45 /r",
          "Instruction": "VPSRLVQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shift quadwords in zmm2 right by amount specified in the corresponding element of zmm3/m512/m64bcst while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPSRLVW",
      "Description": "Variable Bit Shift Right Logical",
      "Url": "https://www.felixcloutier.com/x86/VPSRLVW:VPSRLVD:VPSRLVQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 10 /r",
          "Instruction": "VPSRLVW xmm1 {k1}{z}, xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in xmm2 right by amount specified in the corresponding element of xmm3/m128 while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 10 /r",
          "Instruction": "VPSRLVW ymm1 {k1}{z}, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Shift words in ymm2 right by amount specified in the corresponding element of ymm3/m256 while shifting in 0s using writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 10 /r",
          "Instruction": "VPSRLVW zmm1 {k1}{z}, zmm2, zmm3/m512",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Shift words in zmm2 right by amount specified in the corresponding element of zmm3/m512 while shifting in 0s using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTERNLOGD",
      "Description": "Bitwise Ternary Logic",
      "Url": "https://www.felixcloutier.com/x86/VPTERNLOGD:VPTERNLOGQ.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F3A.W0 25 /r ib",
          "Instruction": "VPTERNLOGD xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m32bcst as source operands and writing the result to xmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F3A.W0 25 /r ib",
          "Instruction": "VPTERNLOGD ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m32bcst as source operands and writing the result to ymm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F3A.W0 25 /r ib",
          "Instruction": "VPTERNLOGD zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m32bcst as source operands and writing the result to zmm1 under writemask k1 with dword granularity. The immediate value determines the specific binary function being implemented."
        }
      ]
    },
    {
      "Mnemonic": "VPTERNLOGQ",
      "Description": "Bitwise Ternary Logic",
      "Url": "https://www.felixcloutier.com/x86/VPTERNLOGD:VPTERNLOGQ.html",
      "Table": [
        {
          "Opcode": "EVEX.DDS.128.66.0F3A.W1 25 /r ib",
          "Instruction": "VPTERNLOGQ xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise ternary logic taking xmm1, xmm2 and xmm3/m128/m64bcst as source operands and writing the result to xmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
        },
        {
          "Opcode": "EVEX.DDS.256.66.0F3A.W1 25 /r ib",
          "Instruction": "VPTERNLOGQ ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise ternary logic taking ymm1, ymm2 and ymm3/m256/m64bcst as source operands and writing the result to ymm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
        },
        {
          "Opcode": "EVEX.DDS.512.66.0F3A.W1 25 /r ib",
          "Instruction": "VPTERNLOGQ zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise ternary logic taking zmm1, zmm2 and zmm3/m512/m64bcst as source operands and writing the result to zmm1 under writemask k1 with qword granularity. The immediate value determines the specific binary function being implemented."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTMB",
      "Description": "Logical AND and Set Mask",
      "Url": "https://www.felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 26 /r",
          "Instruction": "VPTESTMB k2 {k1}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Bitwise AND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 26 /r",
          "Instruction": "VPTESTMB k2 {k1}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Bitwise AND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 26 /r",
          "Instruction": "VPTESTMB k2 {k1}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTMD",
      "Description": "Logical AND and Set Mask",
      "Url": "https://www.felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 27 /r",
          "Instruction": "VPTESTMD k2 {k1}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 27 /r",
          "Instruction": "VPTESTMD k2 {k1}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 27 /r",
          "Instruction": "VPTESTMD k2 {k1}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTMQ",
      "Description": "Logical AND and Set Mask",
      "Url": "https://www.felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 27 /r",
          "Instruction": "VPTESTMQ k2 {k1}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 27 /r",
          "Instruction": "VPTESTMQ k2 {k1}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Bitwise AND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 27 /r",
          "Instruction": "VPTESTMQ k2 {k1}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Bitwise AND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTMW",
      "Description": "Logical AND and Set Mask",
      "Url": "https://www.felixcloutier.com/x86/VPTESTMB:VPTESTMW:VPTESTMD:VPTESTMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 26 /r",
          "Instruction": "VPTESTMW k2 {k1}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Bitwise AND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 26 /r",
          "Instruction": "VPTESTMW k2 {k1}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512BW",
          "Description": "Bitwise AND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 26 /r",
          "Instruction": "VPTESTMW k2 {k1}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512BW",
          "Description": "Bitwise AND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTNMB",
      "Description": "Logical NAND and Set",
      "Url": "https://www.felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.F3.0F38.W0 26 /r",
          "Instruction": "VPTESTNMB k2 {k1}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed byte integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.F3.0F38.W0 26 /r",
          "Instruction": "VPTESTNMB k2 {k1}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed byte integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.F3.0F38.W0 26 /r",
          "Instruction": "VPTESTNMB k2 {k1}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed byte integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTNMD",
      "Description": "Logical NAND and Set",
      "Url": "https://www.felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.F3.0F38.W0 27 /r",
          "Instruction": "VPTESTNMD k2 {k1}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed doubleword integers in xmm2 and xmm3/m128/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.F3.0F38.W0 27 /r",
          "Instruction": "VPTESTNMD k2 {k1}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed doubleword integers in ymm2 and ymm3/m256/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.F3.0F38.W0 27 /r",
          "Instruction": "VPTESTNMD k2 {k1}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed doubleword integers in zmm2 and zmm3/m512/m32bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTNMQ",
      "Description": "Logical NAND and Set",
      "Url": "https://www.felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.F3.0F38.W1 27 /r",
          "Instruction": "VPTESTNMQ k2 {k1}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed quadword integers in xmm2 and xmm3/m128/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.F3.0F38.W1 27 /r",
          "Instruction": "VPTESTNMQ k2 {k1}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed quadword integers in ymm2 and ymm3/m256/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.F3.0F38.W1 27 /r",
          "Instruction": "VPTESTNMQ k2 {k1}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed quadword integers in zmm2 and zmm3/m512/m64bcst and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VPTESTNMW",
      "Description": "Logical NAND and Set",
      "Url": "https://www.felixcloutier.com/x86/VPTESTNMB:VPTESTNMW:VPTESTNMD:VPTESTNMQ.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.F3.0F38.W1 26 /r",
          "Instruction": "VPTESTNMW k2 {k1}, xmm2, xmm3/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed word integers in xmm2 and xmm3/m128 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.F3.0F38.W1 26 /r",
          "Instruction": "VPTESTNMW k2 {k1}, ymm2, ymm3/m256",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed word integers in ymm2 and ymm3/m256 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.F3.0F38.W1 26 /r",
          "Instruction": "VPTESTNMW k2 {k1}, zmm2, zmm3/m512",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "Description": "Bitwise NAND of packed word integers in zmm2 and zmm3/m512 and set mask k2 to reflect the zero/non-zero status of each element of the result, under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VRANGEPD",
      "Description": "Range Restriction Calculation For Packed Pairs of Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VRANGEPD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W1 50 /r ib",
          "Instruction": "VRANGEPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Calculate two RANGE operation output value from 2 pairs of double-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W1 50 /r ib",
          "Instruction": "VRANGEPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Calculate four RANGE operation output value from 4pairs of double-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 50 /r ib",
          "Instruction": "VRANGEPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Calculate eight RANGE operation output value from 8 pairs of double-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        }
      ]
    },
    {
      "Mnemonic": "VRANGEPS",
      "Description": "Range Restriction Calculation For Packed Pairs of Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VRANGEPS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F3A.W0 50 /r ib",
          "Instruction": "VRANGEPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Calculate four RANGE operation output value from 4 pairs of single-precision floating-point values in xmm2 and xmm3/m128/m32bcst, store the results to xmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F3A.W0 50 /r ib",
          "Instruction": "VRANGEPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Calculate eight RANGE operation output value from 8 pairs of single-precision floating-point values in ymm2 and ymm3/m256/m32bcst, store the results to ymm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 50 /r ib",
          "Instruction": "VRANGEPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Calculate 16 RANGE operation output value from 16 pairs of single-precision floating-point values in zmm2 and zmm3/m512/m32bcst, store the results to zmm1 under the writemask k1. Imm8 specifies the comparison and sign of the range operation."
        }
      ]
    },
    {
      "Mnemonic": "VRANGESD",
      "Description": "Range Restriction Calculation From a pair of Scalar Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VRANGESD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W1 51 /r",
          "Instruction": "VRANGESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Calculate a RANGE operation output value from 2 double-precision floating-point values in xmm2 and xmm3/m64, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
        }
      ]
    },
    {
      "Mnemonic": "VRANGESS",
      "Description": "Range Restriction Calculation From a Pair of Scalar Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VRANGESS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W0 51 /r",
          "Instruction": "VRANGESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Calculate a RANGE operation output value from 2 single-precision floating-point values in xmm2 and xmm3/m32, store the output to xmm1 under writemask. Imm8 specifies the comparison and sign of the range operation."
        }
      ]
    },
    {
      "Mnemonic": "VRCP14PD",
      "Description": "Compute Approximate Reciprocals of Packed Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VRCP14PD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 4C /r",
          "Instruction": "VRCP14PD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocals of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 4C /r",
          "Instruction": "VRCP14PD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocals of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 4C /r",
          "Instruction": "VRCP14PD zmm1 {k1}{z}, zmm2/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocals of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1. Under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRCP14PS",
      "Description": "Compute Approximate Reciprocals of Packed Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VRCP14PS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 4C /r",
          "Instruction": "VRCP14PS xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 4C /r",
          "Instruction": "VRCP14PS ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 4C /r",
          "Instruction": "VRCP14PS zmm1 {k1}{z}, zmm2/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocals of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRCP14SD",
      "Description": "Compute Approximate Reciprocal of Scalar Float64 Value",
      "Url": "https://www.felixcloutier.com/x86/VRCP14SD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W1 4D /r",
          "Instruction": "VRCP14SD xmm1 {k1}{z}, xmm2, xmm3/m64",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal of the scalar double-precision floating-point value in xmm3/m64 and stores the result in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:64]) from xmm2 is copied to xmm1[127:64]."
        }
      ]
    },
    {
      "Mnemonic": "VRCP14SS",
      "Description": "Compute Approximate Reciprocal of Scalar Float32 Value",
      "Url": "https://www.felixcloutier.com/x86/VRCP14SS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W0 4D /r",
          "Instruction": "VRCP14SS xmm1 {k1}{z}, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal of the scalar single-precision floating-point value in xmm3/m32 and stores the results in xmm1 using writemask k1. Also, upper double-precision floating-point value (bits[127:32]) from xmm2 is copied to xmm1[127:32]."
        }
      ]
    },
    {
      "Mnemonic": "VREDUCEPD",
      "Description": "Perform Reduction Transformation on Packed Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VREDUCEPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W1 56 /r ib",
          "Instruction": "VREDUCEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Perform reduction transformation on packed double-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 56 /r ib",
          "Instruction": "VREDUCEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Perform reduction transformation on packed double-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 56 /r ib",
          "Instruction": "VREDUCEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Perform reduction transformation on double-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VREDUCEPS",
      "Description": "Perform Reduction Transformation on Packed Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VREDUCEPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W0 56 /r ib",
          "Instruction": "VREDUCEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Perform reduction transformation on packed single-precision floating point values in xmm2/m128/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 56 /r ib",
          "Instruction": "VREDUCEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Perform reduction transformation on packed single-precision floating point values in ymm2/m256/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register under writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 56 /r ib",
          "Instruction": "VREDUCEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Perform reduction transformation on packed single-precision floating point values in zmm2/m512/m32bcst by subtracting a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VREDUCESD",
      "Description": "Perform a Reduction Transformation on a Scalar Float64 Value",
      "Url": "https://www.felixcloutier.com/x86/VREDUCESD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W1 57",
          "Instruction": "VREDUCESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8/r",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512D Q",
          "Description": "Perform a reduction transformation on a scalar double-precision floating point value in xmm3/m64 by subtracting a number of fraction bits specified by the imm8 field. Also, upper double precision floating-point value (bits[127:64]) from xmm2 are copied to xmm1[127:64]. Stores the result in xmm1 register."
        }
      ]
    },
    {
      "Mnemonic": "VREDUCESS",
      "Description": "Perform a Reduction Transformation on a Scalar Float32 Value",
      "Url": "https://www.felixcloutier.com/x86/VREDUCESS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W0 57 /r /ib",
          "Instruction": "VREDUCESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Perform a reduction transformation on a scalar single-precision floating point value in xmm3/m32 by subtracting a number of fraction bits specified by the imm8 field. Also, upper single precision floating-point values (bits[127:32]) from xmm2 are copied to xmm1[127:32]. Stores the result in xmm1 register."
        }
      ]
    },
    {
      "Mnemonic": "VRNDSCALEPD",
      "Description": "Round Packed Float64 Values To Include A Given Number Of Fraction Bits",
      "Url": "https://www.felixcloutier.com/x86/VRNDSCALEPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W1 09 /r ib",
          "Instruction": "VRNDSCALEPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rounds packed double-precision floating point values in xmm2/m128/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W1 09 /r ib",
          "Instruction": "VRNDSCALEPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rounds packed double-precision floating point values in ymm2/m256/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W1 09 /r ib",
          "Instruction": "VRNDSCALEPD zmm1 {k1}{z}, zmm2/m512/m64bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rounds packed double-precision floating-point values in zmm2/m512/m64bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VRNDSCALEPS",
      "Description": "Round Packed Float32 Values To Include A Given Number Of Fraction Bits",
      "Url": "https://www.felixcloutier.com/x86/VRNDSCALEPS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F3A.W0 08 /r ib",
          "Instruction": "VRNDSCALEPS xmm1 {k1}{z}, xmm2/m128/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rounds packed single-precision floating point values in xmm2/m128/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F3A.W0 08 /r ib",
          "Instruction": "VRNDSCALEPS ymm1 {k1}{z}, ymm2/m256/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Rounds packed single-precision floating point values in ymm2/m256/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in ymm1 register. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F3A.W0 08 /r ib",
          "Instruction": "VRNDSCALEPS zmm1 {k1}{z}, zmm2/m512/m32bcst{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rounds packed single-precision floating-point values in zmm2/m512/m32bcst to a number of fraction bits specified by the imm8 field. Stores the result in zmm1 register using writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRNDSCALESD",
      "Description": "Round Scalar Float64 Value To Include A Given Number Of Fraction Bits",
      "Url": "https://www.felixcloutier.com/x86/VRNDSCALESD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W1 0B /r ib",
          "Instruction": "VRNDSCALESD xmm1 {k1}{z}, xmm2, xmm3/m64{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rounds scalar double-precision floating-point value in xmm3/m64 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register."
        }
      ]
    },
    {
      "Mnemonic": "VRNDSCALESS",
      "Description": "Round Scalar Float32 Value To Include A Given Number Of Fraction Bits",
      "Url": "https://www.felixcloutier.com/x86/VRNDSCALESS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F3A.W0 0A /r ib",
          "Instruction": "VRNDSCALESS xmm1 {k1}{z}, xmm2, xmm3/m32{sae}, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Rounds scalar single-precision floating-point value in xmm3/m32 to a number of fraction bits specified by the imm8 field. Stores the result in xmm1 register under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRSQRT14PD",
      "Description": "Compute Approximate Reciprocals of Square Roots of Packed Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VRSQRT14PD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 4E /r",
          "Instruction": "VRSQRT14PD xmm1 {k1}{z}, xmm2/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in xmm2/m128/m64bcst and stores the results in xmm1. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 4E /r",
          "Instruction": "VRSQRT14PD ymm1 {k1}{z}, ymm2/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in ymm2/m256/m64bcst and stores the results in ymm1. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 4E /r",
          "Instruction": "VRSQRT14PD zmm1 {k1}{z}, zmm2/m512/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed double-precision floating-point values in zmm2/m512/m64bcst and stores the results in zmm1 under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRSQRT14PS",
      "Description": "Compute Approximate Reciprocals of Square Roots of Packed Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VRSQRT14PS.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 4E /r",
          "Instruction": "VRSQRT14PS xmm1 {k1}{z}, xmm2/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in xmm2/m128/m32bcst and stores the results in xmm1. Under writemask."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 4E /r",
          "Instruction": "VRSQRT14PS ymm1 {k1}{z}, ymm2/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in ymm2/m256/m32bcst and stores the results in ymm1. Under writemask."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 4E /r",
          "Instruction": "VRSQRT14PS zmm1 {k1}{z}, zmm2/m512/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal square roots of the packed single-precision floating-point values in zmm2/m512/m32bcst and stores the results in zmm1. Under writemask."
        }
      ]
    },
    {
      "Mnemonic": "VRSQRT14SD",
      "Description": "Compute Approximate Reciprocal of Square Root of Scalar Float64 Value",
      "Url": "https://www.felixcloutier.com/x86/VRSQRT14SD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W1 4F /r",
          "Instruction": "VRSQRT14SD xmm1 {k1}{z}, xmm2, xmm3/m64",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal square root of the scalar double-precision floating-point value in xmm3/m64 and stores the result in the low quadword element of xmm1 using writemask k1. Bits[127:64] of xmm2 is copied to xmm1[127:64]."
        }
      ]
    },
    {
      "Mnemonic": "VRSQRT14SS",
      "Description": "Compute Approximate Reciprocal of Square Root of Scalar Float32 Value",
      "Url": "https://www.felixcloutier.com/x86/VRSQRT14SS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W0 4F /r",
          "Instruction": "VRSQRT14SS xmm1 {k1}{z}, xmm2, xmm3/m32",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Computes the approximate reciprocal square root of the scalar single-precision floating-point value in xmm3/m32 and stores the result in the low doubleword element of xmm1 using writemask k1. Bits[127:32] of xmm2 is copied to xmm1[127:32]."
        }
      ]
    },
    {
      "Mnemonic": "VSCALEFPD",
      "Description": "Scale Packed Float64 Values With Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VSCALEFPD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W1 2C /r",
          "Instruction": "VSCALEFPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Scale the packed double-precision floating-point values in xmm2 using values from xmm3/m128/m64bcst. Under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W1 2C /r",
          "Instruction": "VSCALEFPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Scale the packed double-precision floating-point values in ymm2 using values from ymm3/m256/m64bcst. Under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W1 2C /r",
          "Instruction": "VSCALEFPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Scale the packed double-precision floating-point values in zmm2 using values from zmm3/m512/m64bcst. Under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCALEFPS",
      "Description": "Scale Packed Float32 Values With Float32 Values",
      "Url": "https://www.felixcloutier.com/x86/VSCALEFPS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.128.66.0F38.W0 2C /r",
          "Instruction": "VSCALEFPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Scale the packed single-precision floating-point values in xmm2 using values from xmm3/m128/m32bcst. Under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F38.W0 2C /r",
          "Instruction": "VSCALEFPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Scale the packed single-precision values in ymm2 using floating point values from ymm3/m256/m32bcst. Under writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F38.W0 2C /r",
          "Instruction": "VSCALEFPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Scale the packed single-precision floating-point values in zmm2 using floating-point values from zmm3/m512/m32bcst. Under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCALEFSD",
      "Description": "Scale Scalar Float64 Values With Float64 Values",
      "Url": "https://www.felixcloutier.com/x86/VSCALEFSD.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W1 2D /r",
          "Instruction": "VSCALEFSD xmm1 {k1}{z}, xmm2, xmm3/m64{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Scale the scalar double-precision floating-point values in xmm2 using the value from xmm3/m64. Under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCALEFSS",
      "Description": "Scale Scalar Float32 Value With Float32 Value",
      "Url": "https://www.felixcloutier.com/x86/VSCALEFSS.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.LIG.66.0F38.W0 2D /r",
          "Instruction": "VSCALEFSS xmm1 {k1}{z}, xmm2, xmm3/m32{er}",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Scale the scalar single-precision floating-point value in xmm2 using floating-point value from xmm3/m32. Under writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCATTERDPD",
      "Description": "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 A2 /vsib",
          "Instruction": "VSCATTERDPD vm32x {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 A2 /vsib",
          "Instruction": "VSCATTERDPD vm32x {k1}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 A2 /vsib",
          "Instruction": "VSCATTERDPD vm32y {k1}, zmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, scatter double-precision floating-point values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCATTERDPS",
      "Description": "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 A2 /vsib",
          "Instruction": "VSCATTERDPS vm32x {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 A2 /vsib",
          "Instruction": "VSCATTERDPS vm32y {k1}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 A2 /vsib",
          "Instruction": "VSCATTERDPS vm32z {k1}, zmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed dword indices, scatter single-precision floating-point values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCATTERQPD",
      "Description": "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W1 A3 /vsib",
          "Instruction": "VSCATTERQPD vm64x {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W1 A3 /vsib",
          "Instruction": "VSCATTERQPD vm64y {k1}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W1 A3 /vsib",
          "Instruction": "VSCATTERQPD vm64z {k1}, zmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, scatter double-precision floating-point values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSCATTERQPS",
      "Description": "Scatter Packed Single, Packed Double with Signed Dword and Qword Indices",
      "Url": "https://www.felixcloutier.com/x86/VSCATTERDPS:VSCATTERDPD:VSCATTERQPS:VSCATTERQPD.html",
      "Table": [
        {
          "Opcode": "EVEX.128.66.0F38.W0 A3 /vsib",
          "Instruction": "VSCATTERQPS vm64x {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.256.66.0F38.W0 A3 /vsib",
          "Instruction": "VSCATTERQPS vm64y {k1}, xmm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512F",
          "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
        },
        {
          "Opcode": "EVEX.512.66.0F38.W0 A3 /vsib",
          "Instruction": "VSCATTERQPS vm64z {k1}, ymm1",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Using signed qword indices, scatter single-precision floating-point values to memory using writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSHUFF32x4",
      "Description": "Shuffle Packed Values at 128-bit Granularity",
      "Url": "https://www.felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 23 /r ib",
          "Instruction": "VSHUFF32x4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle 128-bit packed single-precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSHUFF64x2",
      "Description": "Shuffle Packed Values at 128-bit Granularity",
      "Url": "https://www.felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 23 /r ib",
          "Instruction": "VSHUFF64x2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle 128-bit packed double-precision floating-point values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSHUFI32x4",
      "Description": "Shuffle Packed Values at 128-bit Granularity",
      "Url": "https://www.felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W0 43 /r ib",
          "Instruction": "VSHUFI32x4 zmm1{k1}{z}, zmm2, zmm3/m512/m32bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle 128-bit packed double-word values selected by imm8 from zmm2 and zmm3/m512/m32bcst and place results in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VSHUFI64x2",
      "Description": "Shuffle Packed Values at 128-bit Granularity",
      "Url": "https://www.felixcloutier.com/x86/VSHUFF32x4:VSHUFF64x2:VSHUFI32x4:VSHUFI64x2.html",
      "Table": [
        {
          "Opcode": "EVEX.NDS.512.66.0F3A.W1 43 /r ib",
          "Instruction": "VSHUFI64x2 zmm1{k1}{z}, zmm2, zmm3/m512/m64bcst, imm8",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512F",
          "Description": "Shuffle 128-bit packed quad-word values selected by imm8 from zmm2 and zmm3/m512/m64bcst and place results in zmm1 subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "VTESTPD",
      "Description": "Packed Bit Test",
      "Url": "https://www.felixcloutier.com/x86/VTESTPD:VTESTPS.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F38.W0 0F /r",
          "Instruction": "VTESTPD xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 0F /r",
          "Instruction": "VTESTPD ymm1, ymm2/m256",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed double-precision floating-point sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VTESTPS",
      "Description": "Packed Bit Test",
      "Url": "https://www.felixcloutier.com/x86/VTESTPD:VTESTPS.html",
      "Table": [
        {
          "Opcode": "VEX.128.66.0F38.W0 0E /r",
          "Instruction": "VTESTPS xmm1, xmm2/m128",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
        },
        {
          "Opcode": "VEX.256.66.0F38.W0 0E /r",
          "Instruction": "VTESTPS ymm1, ymm2/m256",
          "OperandEncoding": "RM",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Set ZF and CF depending on sign bit AND and ANDN of packed single-precision floating-point sources."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "VZEROALL",
      "Description": "Zero All YMM Registers",
      "Url": "https://www.felixcloutier.com/x86/VZEROALL.html",
      "Table": [
        {
          "Opcode": "VEX.256.0F.WIG 77",
          "Instruction": "VZEROALL",
          "OperandEncoding": "ZO",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero all YMM registers."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "VZEROUPPER",
      "Description": "Zero Upper Bits of YMM Registers",
      "Url": "https://www.felixcloutier.com/x86/VZEROUPPER.html",
      "Table": [
        {
          "Opcode": "VEX.128.0F.WIG 77",
          "Instruction": "VZEROUPPER",
          "OperandEncoding": "ZO",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Zero upper 128 bits of all YMM registers."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "WAIT",
      "Description": "Wait",
      "Url": "https://www.felixcloutier.com/x86/WAIT:FWAIT.html",
      "Table": [
        {
          "Opcode": "9B",
          "Instruction": "WAIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Check pending unmasked floating-point exceptions."
        },
        {
          "Opcode": "9B",
          "Instruction": "FWAIT",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Check pending unmasked floating-point exceptions."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "WBINVD",
      "Description": "Write Back and Invalidate Cache",
      "Url": "https://www.felixcloutier.com/x86/WBINVD.html",
      "Table": [
        {
          "Opcode": "0F 09",
          "Instruction": "WBINVD",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Write back and flush Internal caches; initiate writing-back and flushing of external caches."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "WRFSBASE",
      "Description": "Write FS/GS Segment Base",
      "Url": "https://www.felixcloutier.com/x86/WRFSBASE:WRGSBASE.html",
      "Table": [
        {
          "Opcode": "F3 0F AE /2",
          "Instruction": "WRFSBASE r32",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the FS base address with the 32-bit value in the source register."
        },
        {
          "Opcode": "F3 REX.W 0F AE /2",
          "Instruction": "WRFSBASE r64",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the FS base address with the 64-bit value in the source register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "WRGSBASE",
      "Description": "Write FS/GS Segment Base",
      "Url": "https://www.felixcloutier.com/x86/WRFSBASE:WRGSBASE.html",
      "Table": [
        {
          "Opcode": "F3 REX.W 0F AE /3",
          "Instruction": "WRGSBASE r64",
          "OperandEncoding": "M",
          "CpuidFeatureFlag": "FSGSBASE",
          "Description": "Load the GS base address with the 64-bit value in the source register."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "WRMSR",
      "Description": "Write to Model Specific Register",
      "Url": "https://www.felixcloutier.com/x86/WRMSR.html",
      "Table": [
        {
          "Opcode": "0F 30",
          "Instruction": "WRMSR",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Write the value in EDX:EAX to MSR specified by ECX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "WRPKRU",
      "Description": "Write Data to User Page Key Register",
      "Url": "https://www.felixcloutier.com/x86/WRPKRU.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XABORT",
      "Description": "Transactional Abort",
      "Url": "https://www.felixcloutier.com/x86/XABORT.html",
      "Table": [
        {
          "Opcode": "C6 F8 ib",
          "Instruction": "XABORT imm8",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "RTM",
          "Description": "Causes an RTM abort if in RTM execution"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "imm8"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XACQUIRE",
      "Description": "Hardware Lock Elision Prefix Hints",
      "Url": "https://www.felixcloutier.com/x86/XACQUIRE:XRELEASE.html",
      "Table": [
        {
          "Opcode": "F2",
          "Instruction": "XACQUIRE",
          "CpuidFeatureFlag": "HLE1",
          "Description": "A hint used with an “XACQUIRE-enabled“ instruction to start lock elision on the instruction memory operand address."
        }
      ]
    },
    {
      "Mnemonic": "XADD",
      "Description": "Exchange and Add",
      "Url": "https://www.felixcloutier.com/x86/XADD.html",
      "Table": [
        {
          "Opcode": "0F C0 /r",
          "Instruction": "XADD r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r8 and r/m8; load sum into r/m8."
        },
        {
          "Opcode": "REX + 0F C0 /r",
          "Instruction": "XADD r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Exchange r8 and r/m8; load sum into r/m8."
        },
        {
          "Opcode": "0F C1 /r",
          "Instruction": "XADD r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r16 and r/m16; load sum into r/m16."
        },
        {
          "Opcode": "0F C1 /r",
          "Instruction": "XADD r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r32 and r/m32; load sum into r/m32."
        },
        {
          "Opcode": "REX.W + 0F C1 /r",
          "Instruction": "XADD r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Exchange r64 and r/m64; load sum into r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r, w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XBEGIN",
      "Description": "Transactional Begin",
      "Url": "https://www.felixcloutier.com/x86/XBEGIN.html",
      "Table": [
        {
          "Opcode": "C7 F8",
          "Instruction": "XBEGIN rel16",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "RTM",
          "Description": "Specifies the start of an RTM region. Provides a 16-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
        },
        {
          "Opcode": "C7 F8",
          "Instruction": "XBEGIN rel32",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "RTM",
          "Description": "Specifies the start of an RTM region. Provides a 32-bit relative offset to compute the address of the fallback instruction address at which execution resumes following an RTM abort."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": [
            "Offset"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XCHG",
      "Description": "Exchange Register/Memory with Register",
      "Url": "https://www.felixcloutier.com/x86/XCHG.html",
      "Table": [
        {
          "Opcode": "90+rw",
          "Instruction": "XCHG AX, r16",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Exchange r16 with AX."
        },
        {
          "Opcode": "90+rw",
          "Instruction": "XCHG r16, AX",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Exchange AX with r16."
        },
        {
          "Opcode": "90+rd",
          "Instruction": "XCHG EAX, r32",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Exchange r32 with EAX."
        },
        {
          "Opcode": "REX.W + 90+rd",
          "Instruction": "XCHG RAX, r64",
          "OperandEncoding": "O",
          "CompatLegMode": "N.E.",
          "Description": "Exchange r64 with RAX."
        },
        {
          "Opcode": "90+rd",
          "Instruction": "XCHG r32, EAX",
          "OperandEncoding": "O",
          "CompatLegMode": "Valid",
          "Description": "Exchange EAX with r32."
        },
        {
          "Opcode": "REX.W + 90+rd",
          "Instruction": "XCHG r64, RAX",
          "OperandEncoding": "O",
          "CompatLegMode": "N.E.",
          "Description": "Exchange RAX with r64."
        },
        {
          "Opcode": "86 /r",
          "Instruction": "XCHG r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r8 (byte register) with byte from r/m8."
        },
        {
          "Opcode": "REX + 86 /r",
          "Instruction": "XCHG r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Exchange r8 (byte register) with byte from r/m8."
        },
        {
          "Opcode": "86 /r",
          "Instruction": "XCHG r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Exchange byte from r/m8 with r8 (byte register)."
        },
        {
          "Opcode": "REX + 86 /r",
          "Instruction": "XCHG r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Exchange byte from r/m8 with r8 (byte register)."
        },
        {
          "Opcode": "87 /r",
          "Instruction": "XCHG r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r16 with word from r/m16."
        },
        {
          "Opcode": "87 /r",
          "Instruction": "XCHG r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Exchange word from r/m16 with r16."
        },
        {
          "Opcode": "87 /r",
          "Instruction": "XCHG r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "Exchange r32 with doubleword from r/m32."
        },
        {
          "Opcode": "REX.W + 87 /r",
          "Instruction": "XCHG r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "Exchange r64 with quadword from r/m64."
        },
        {
          "Opcode": "87 /r",
          "Instruction": "XCHG r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "Exchange doubleword from r/m32 with r32."
        },
        {
          "Opcode": "REX.W + 87 /r",
          "Instruction": "XCHG r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "Exchange quadword from r/m64 with r64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "O",
          "Operands": [
            "AX/EAX/RAX (r, w)",
            "opcode + rd (r, w)"
          ]
        },
        {
          "OperandEncoding": "O",
          "Operands": [
            "opcode + rd (r, w)",
            "AX/EAX/RAX (r, w)"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XEND",
      "Description": "Transactional End",
      "Url": "https://www.felixcloutier.com/x86/XEND.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 D5",
          "Instruction": "XEND",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "RTM",
          "Description": "Specifies the end of an RTM code region."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XGETBV",
      "Description": "Get Value of Extended Control Register",
      "Url": "https://www.felixcloutier.com/x86/XGETBV.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 D0",
          "Instruction": "XGETBV",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Reads an XCR specified by ECX into EDX:EAX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XLAT",
      "Description": "Table Look-up Translation",
      "Url": "https://www.felixcloutier.com/x86/XLAT:XLATB.html",
      "Table": [
        {
          "Opcode": "D7",
          "Instruction": "XLAT m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
        },
        {
          "Opcode": "D7",
          "Instruction": "XLATB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
        },
        {
          "Opcode": "REX.W + D7",
          "Instruction": "XLATB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Set AL to memory byte [RBX + unsigned AL]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XLATB",
      "Description": "Table Look-up Translation",
      "Url": "https://www.felixcloutier.com/x86/XLAT:XLATB.html",
      "Table": [
        {
          "Opcode": "D7",
          "Instruction": "XLAT m8",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
        },
        {
          "Opcode": "D7",
          "Instruction": "XLATB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Set AL to memory byte DS:[(E)BX + unsigned AL]."
        },
        {
          "Opcode": "REX.W + D7",
          "Instruction": "XLATB",
          "OperandEncoding": "ZO",
          "CompatLegMode": "N.E.",
          "Description": "Set AL to memory byte [RBX + unsigned AL]."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XOR",
      "Description": "Logical Exclusive OR",
      "Url": "https://www.felixcloutier.com/x86/XOR.html",
      "Table": [
        {
          "Opcode": "34 ib",
          "Instruction": "XOR AL, imm8",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AL XOR imm8."
        },
        {
          "Opcode": "35 iw",
          "Instruction": "XOR AX, imm16",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "AX XOR imm16."
        },
        {
          "Opcode": "35 id",
          "Instruction": "XOR EAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "Valid",
          "Description": "EAX XOR imm32."
        },
        {
          "Opcode": "REX.W + 35 id",
          "Instruction": "XOR RAX, imm32",
          "OperandEncoding": "I",
          "CompatLegMode": "N.E.",
          "Description": "RAX XOR imm32 (sign-extended)."
        },
        {
          "Opcode": "80 /6 ib",
          "Instruction": "XOR r/m8, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m8 XOR imm8."
        },
        {
          "Opcode": "REX + 80 /6 ib",
          "Instruction": "XOR r/m8*, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m8 XOR imm8."
        },
        {
          "Opcode": "81 /6 iw",
          "Instruction": "XOR r/m16, imm16",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m16 XOR imm16."
        },
        {
          "Opcode": "81 /6 id",
          "Instruction": "XOR r/m32, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m32 XOR imm32."
        },
        {
          "Opcode": "REX.W + 81 /6 id",
          "Instruction": "XOR r/m64, imm32",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 XOR imm32 (sign-extended)."
        },
        {
          "Opcode": "83 /6 ib",
          "Instruction": "XOR r/m16, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m16 XOR imm8 (sign-extended)."
        },
        {
          "Opcode": "83 /6 ib",
          "Instruction": "XOR r/m32, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "Valid",
          "Description": "r/m32 XOR imm8 (sign-extended)."
        },
        {
          "Opcode": "REX.W + 83 /6 ib",
          "Instruction": "XOR r/m64, imm8",
          "OperandEncoding": "MI",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 XOR imm8 (sign-extended)."
        },
        {
          "Opcode": "30 /r",
          "Instruction": "XOR r/m8, r8",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m8 XOR r8."
        },
        {
          "Opcode": "REX + 30 /r",
          "Instruction": "XOR r/m8*, r8*",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "r/m8 XOR r8."
        },
        {
          "Opcode": "31 /r",
          "Instruction": "XOR r/m16, r16",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m16 XOR r16."
        },
        {
          "Opcode": "31 /r",
          "Instruction": "XOR r/m32, r32",
          "OperandEncoding": "MR",
          "CompatLegMode": "Valid",
          "Description": "r/m32 XOR r32."
        },
        {
          "Opcode": "REX.W + 31 /r",
          "Instruction": "XOR r/m64, r64",
          "OperandEncoding": "MR",
          "CompatLegMode": "N.E.",
          "Description": "r/m64 XOR r64."
        },
        {
          "Opcode": "32 /r",
          "Instruction": "XOR r8, r/m8",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r8 XOR r/m8."
        },
        {
          "Opcode": "REX + 32 /r",
          "Instruction": "XOR r8*, r/m8*",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "r8 XOR r/m8."
        },
        {
          "Opcode": "33 /r",
          "Instruction": "XOR r16, r/m16",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r16 XOR r/m16."
        },
        {
          "Opcode": "33 /r",
          "Instruction": "XOR r32, r/m32",
          "OperandEncoding": "RM",
          "CompatLegMode": "Valid",
          "Description": "r32 XOR r/m32."
        },
        {
          "Opcode": "REX.W + 33 /r",
          "Instruction": "XOR r64, r/m64",
          "OperandEncoding": "RM",
          "CompatLegMode": "N.E.",
          "Description": "r64 XOR r/m64."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "I",
          "Operands": [
            "AL/AX/EAX/RAX",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MI",
          "Operands": [
            "ModRM:r/m (r, w)",
            "imm8/16/32"
          ]
        },
        {
          "OperandEncoding": "MR",
          "Operands": [
            "ModRM:r/m (r, w)",
            "ModRM:reg (r)"
          ]
        },
        {
          "OperandEncoding": "RM",
          "Operands": [
            "ModRM:reg (r, w)",
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XORPD",
      "Description": "Bitwise Logical XOR of Packed Double Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/XORPD.html",
      "Table": [
        {
          "Opcode": "66 0F 57/r",
          "Instruction": "XORPD xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE2",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.66.0F.WIG 57 /r",
          "Instruction": "VXORPD xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.66.0F.WIG 57 /r",
          "Instruction": "VXORPD ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.66.0F.W1 57 /r",
          "Instruction": "VXORPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in xmm2 and xmm3/m128/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.66.0F.W1 57 /r",
          "Instruction": "VXORPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in ymm2 and ymm3/m256/m64bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.66.0F.W1 57 /r",
          "Instruction": "VXORPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed double-precision floating-point values in zmm2 and zmm3/m512/m64bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "XORPS",
      "Description": "Bitwise Logical XOR of Packed Single Precision Floating-Point Values",
      "Url": "https://www.felixcloutier.com/x86/XORPS.html",
      "Table": [
        {
          "Opcode": "NP 0F 57 /r",
          "Instruction": "XORPS xmm1, xmm2/m128",
          "OperandEncoding": "A",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "SSE",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm1 and xmm2/mem."
        },
        {
          "Opcode": "VEX.NDS.128.0F.WIG 57 /r",
          "Instruction": "VXORPS xmm1,xmm2, xmm3/m128",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/mem."
        },
        {
          "Opcode": "VEX.NDS.256.0F.WIG 57 /r",
          "Instruction": "VXORPS ymm1, ymm2, ymm3/m256",
          "OperandEncoding": "B",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/mem."
        },
        {
          "Opcode": "EVEX.NDS.128.0F.W0 57 /r",
          "Instruction": "VXORPS xmm1 {k1}{z}, xmm2, xmm3/m128/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in xmm2 and xmm3/m128/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.256.0F.W0 57 /r",
          "Instruction": "VXORPS ymm1 {k1}{z}, ymm2, ymm3/m256/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512VL AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in ymm2 and ymm3/m256/m32bcst subject to writemask k1."
        },
        {
          "Opcode": "EVEX.NDS.512.0F.W0 57 /r",
          "Instruction": "VXORPS zmm1 {k1}{z}, zmm2, zmm3/m512/m32bcst",
          "OperandEncoding": "C",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "AVX512DQ",
          "Description": "Return the bitwise logical XOR of packed single-precision floating-point values in zmm2 and zmm3/m512/m32bcst subject to writemask k1."
        }
      ]
    },
    {
      "Mnemonic": "XRELEASE",
      "Description": "Hardware Lock Elision Prefix Hints",
      "Url": "https://www.felixcloutier.com/x86/XACQUIRE:XRELEASE.html",
      "Table": [
        {
          "Opcode": "F3",
          "Instruction": "XRELEASE",
          "CpuidFeatureFlag": "HLE",
          "Description": "A hint used with an “XRELEASE-enabled“ instruction to end lock elision on the instruction memory operand address."
        }
      ]
    },
    {
      "Mnemonic": "XRSTOR",
      "Description": "Restore Processor Extended States",
      "Url": "https://www.felixcloutier.com/x86/XRSTOR.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XRSTORS",
      "Description": "Restore Processor Extended States Supervisor",
      "Url": "https://www.felixcloutier.com/x86/XRSTORS.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (r)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XSAVE",
      "Description": "Save Processor Extended States",
      "Url": "https://www.felixcloutier.com/x86/XSAVE.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XSAVEC",
      "Description": "Save Processor Extended States with Compaction",
      "Url": "https://www.felixcloutier.com/x86/XSAVEC.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XSAVEOPT",
      "Description": "Save Processor Extended States Optimized",
      "Url": "https://www.felixcloutier.com/x86/XSAVEOPT.html",
      "Table": [
        {
          "Opcode": "NP 0F AE /6",
          "Instruction": "XSAVEOPT mem",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "XSAVEOPT",
          "Description": "Save state components specified by EDX:EAX to mem, optimizing if possible."
        },
        {
          "Opcode": "NP REX.W + 0F AE /6",
          "Instruction": "XSAVEOPT64 mem",
          "OperandEncoding": "M",
          "Bit64Bit32ModeSupport": "V/V",
          "CpuidFeatureFlag": "XSAVEOPT",
          "Description": "Save state components specified by EDX:EAX to mem, optimizing if possible."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XSAVES",
      "Description": "Save Processor Extended States Supervisor",
      "Url": "https://www.felixcloutier.com/x86/XSAVES.html",
      "OperandEncoding": [
        {
          "OperandEncoding": "M",
          "Operands": [
            "ModRM:r/m (w)"
          ]
        }
      ]
    },
    {
      "Mnemonic": "XSETBV",
      "Description": "Set Extended Control Register",
      "Url": "https://www.felixcloutier.com/x86/XSETBV.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 D1",
          "Instruction": "XSETBV",
          "OperandEncoding": "ZO",
          "CompatLegMode": "Valid",
          "Description": "Write the value in EDX:EAX to the XCR specified by ECX."
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "ZO",
          "Operands": []
        }
      ]
    },
    {
      "Mnemonic": "XTEST",
      "Description": "Test If In Transactional Execution",
      "Url": "https://www.felixcloutier.com/x86/XTEST.html",
      "Table": [
        {
          "Opcode": "NP 0F 01 D6",
          "Instruction": "XTEST",
          "OperandEncoding": "A",
          "CpuidFeatureFlag": "HLE or RTM",
          "Description": "Test if executing in a transactional region"
        }
      ],
      "OperandEncoding": [
        {
          "OperandEncoding": "A",
          "Operands": []
        }
      ]
    }
  ]
}